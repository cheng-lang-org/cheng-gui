import cheng/gui/ime/legacy_codec
import cheng/gui/ime/utfzh_codec
import cheng/gui/ime/cangwu_types
import cheng/gui/ime/cangwu_assets_loader

fn bytesFromInts(values: int32[]): str =
    var out = ""
    for idx in 0..<len(values):
        out = out + charToStr(char(values[idx]))
    return out

fn miniLegacyAssets(): LegacyAssets =
    var assets: LegacyAssets
    assets.gbkToUnicode = []
    assets.gb2312ToUnicode = []
    assets.gbkKeys = []
    assets.gbkVals = []
    assets.gb2312Keys = []
    assets.gb2312Vals = []

    var g1: CwIntMapEntry
    g1.key = "D6D0"
    g1.value = 0x4E2D
    add(assets.gbkToUnicode, g1)
    add(assets.gb2312ToUnicode, g1)
    add(assets.gbkKeys, 0xD6D0)
    add(assets.gbkVals, 0x4E2D)
    add(assets.gb2312Keys, 0xD6D0)
    add(assets.gb2312Vals, 0x4E2D)

    var g2: CwIntMapEntry
    g2.key = "CEC4"
    g2.value = 0x6587
    add(assets.gbkToUnicode, g2)
    add(assets.gb2312ToUnicode, g2)
    add(assets.gbkKeys, 0xCEC4)
    add(assets.gbkVals, 0x6587)
    add(assets.gb2312Keys, 0xCEC4)
    add(assets.gb2312Vals, 0x6587)

    return assets

fn testDictLoad(): int32 =
    let dict = cwLoadUtfZhDict("src/ime/data")
    if len(dict.codepoints) != 9698:
        return 1
    return 0

fn testUtf8Transcode(): int32 =
    let dict = cwLoadUtfZhDict("src/ime/data")
    let legacy = miniLegacyAssets()
    let raw = "abc" + utfzhEncodeUtf8Codepoint(20013) + utfzhEncodeUtf8Codepoint(25991) + "A"
    let tr = utfZhTranscodeStrict(raw, leUtf8, dict, legacy)
    if ! tr.ok:
        return 101
    let dec = utfZhDecodeStrict(tr.bytes, dict)
    if ! dec.ok:
        return 102
    if dec.text != raw:
        return 103
    return 0

fn testGbkTranscode(): int32 =
    let dict = cwLoadUtfZhDict("src/ime/data")
    let legacy = miniLegacyAssets()
    let rawBytes: int32[] = [0xD6, 0xD0, 0xCE, 0xC4]
    let raw = bytesFromInts(rawBytes)
    let tr = utfZhTranscodeStrict(raw, leGbk, dict, legacy)
    if ! tr.ok:
        return 201
    let dec = utfZhDecodeStrict(tr.bytes, dict)
    if ! dec.ok:
        return 202
    if dec.text != utfzhEncodeUtf8Codepoint(20013) + utfzhEncodeUtf8Codepoint(25991):
        return 203
    return 0

fn testAutoTranscode(): int32 =
    let dict = cwLoadUtfZhDict("src/ime/data")
    let legacy = miniLegacyAssets()
    let rawBytes: int32[] = [0xFF, 0xFE, 0x2D, 0x4E, 0x87, 0x65]
    let raw = bytesFromInts(rawBytes)
    let tr = utfZhTranscodeStrict(raw, leAuto, dict, legacy)
    if ! tr.ok:
        return 301
    if tr.detected != leUtf16Le:
        return 302
    let dec = utfZhDecodeStrict(tr.bytes, dict)
    if ! dec.ok || dec.text != utfzhEncodeUtf8Codepoint(20013) + utfzhEncodeUtf8Codepoint(25991):
        return 303
    return 0

fn testAutoPrefersGbkForHanBytes(): int32 =
    let dict = cwLoadUtfZhDict("src/ime/data")
    let legacy = miniLegacyAssets()
    let rawBytes: int32[] = [0xD6, 0xD0, 0xCE, 0xC4]
    let raw = bytesFromInts(rawBytes)
    let tr = utfZhTranscodeStrict(raw, leAuto, dict, legacy)
    if ! tr.ok:
        return 401
    if tr.detected != leGbk:
        return 402
    let dec = utfZhDecodeStrict(tr.bytes, dict)
    if ! dec.ok || dec.text != utfzhEncodeUtf8Codepoint(20013) + utfzhEncodeUtf8Codepoint(25991):
        return 403
    return 0

fn main(): int32 =
    var rc = testDictLoad()
    if rc != 0:
        return rc
    rc = testUtf8Transcode()
    if rc != 0:
        return rc
    rc = testGbkTranscode()
    if rc != 0:
        return rc
    rc = testAutoTranscode()
    if rc != 0:
        return rc
    rc = testAutoPrefersGbkForHanBytes()
    if rc != 0:
        return rc
    return 0

main()
