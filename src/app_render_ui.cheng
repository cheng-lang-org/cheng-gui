import std/os
import std/times
import tables
import cheng/decentralized/json_parse as jparse
import cheng/runtime/json_ast as json
import cheng/runtime/mobile
import cheng/runtime/mobile_app
import ide/textutils
import cheng/gui/app_core
import cheng/gui/app_render_editor_ops
import cheng/gui/services/syntax as syntax
import cheng/gui/services/diagnostics as diag
import cheng/gui/services/p2p_bridge as p2p_bridge

fn fillRect(pixels: void*, width, height, strideBytes: int32, x, y, w, h: int32, color: uint32) =
    if pixels == nil:
        return
    if width <= 0 || height <= 0:
        return
    var x0: int32 = clampInt(x, 0, width)
    var y0: int32 = clampInt(y, 0, height)
    var x1: int32 = clampInt(x + w, 0, width)
    var y1: int32 = clampInt(y + h, 0, height)
    if x1 <= x0 || y1 <= y0:
        return
    for yy in y0..<y1:
        let row: void* = ptr_add(pixels, yy * strideBytes)
        for xx in x0..<x1:
            let p: uint32* = uint32*(ptr_add(row, xx * 4))
            *p = color

fn colorChannelR(color: uint32): int32 =
    return int32((color >> 16) & 0xFF)

fn colorChannelG(color: uint32): int32 =
    return int32((color >> 8) & 0xFF)

fn colorChannelB(color: uint32): int32 =
    return int32(color & 0xFF)

fn colorChannelA(color: uint32): int32 =
    return int32((color >> 24) & 0xFF)

fn colorPack(r, g, b, a: int32): uint32 =
    return uint32(((a & 0xFF) << 24) | ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF))

fn drawIconMaskScaled(pixels: void*, width, height, strideBytes: int32, mask: IconMask, x, y: int32, scale: float64, color: uint32) =
    if pixels == nil:
        return
    if ! iconMaskValid(mask):
        return
    if scale <= 0.0:
        return
    let dstW: int32 = maxInt(1, int32(float64(mask.w * scale)))
    let dstH: int32 = maxInt(1, int32(float64(mask.h * scale)))
    let srcR: int32 = colorChannelR(color)
    let srcG: int32 = colorChannelG(color)
    let srcB: int32 = colorChannelB(color)
    let srcA: int32 = colorChannelA(color)
    for dy in 0..<dstH:
        let yy: int32 = y + dy
        if yy >= 0 && yy < height:
            let row: void* = ptr_add(pixels, yy * strideBytes)
            var srcY: int32 = int32(float64(dy / scale))
            srcY = clampInt(srcY, 0, mask.h - 1)
            for dx in 0..<dstW:
                let xx: int32 = x + dx
                if xx >= 0 && xx < width:
                    var srcX: int32 = int32(float64(dx / scale))
                    srcX = clampInt(srcX, 0, mask.w - 1)
                    let alpha: int32 = mask.data[srcY * mask.w + srcX]
                    if alpha > 0:
                        let effA: int32 = (alpha * srcA) / 255
                        let p: uint32* = uint32*(ptr_add(row, xx * 4))
                        if effA >= 255:
                            *p = color
                        else:
                            let dst: uint32 = *p
                            let dstR: int32 = colorChannelR(dst)
                            let dstG: int32 = colorChannelG(dst)
                            let dstB: int32 = colorChannelB(dst)
                            let invA: int32 = 255 - effA
                            let outR: int32 = (dstR * invA + srcR * effA + 127) / 255
                            let outG: int32 = (dstG * invA + srcG * effA + 127) / 255
                            let outB: int32 = (dstB * invA + srcB * effA + 127) / 255
                            *p = colorPack(outR, outG, outB, 255)

when defined(android) || defined(ios) || defined(mobile_host):
    import cheng/runtime/mobile
    import cheng/runtime/mobile_app

    const MobileEventStride: int32 = 144
    var mobileColorSpace: cstring = "sRGB"

    var mobileGuiInitialized = false
    var mobileGuiWindow: void* = nil
    var mobileGuiSurface: void* = nil
    var mobileGuiWidth: int32 = defaultGuiWidth
    var mobileGuiHeight: int32 = defaultGuiHeight
    var mobileGuiScale: float64 = 1.0
    var mobileGuiLogicalW: float64 = float64(defaultGuiWidth)
    var mobileGuiLogicalH: float64 = float64(defaultGuiHeight)
    var mobileGuiHostReady = false
    var mobileGuiHostCfg: MobileHostConfig

    fn mobileGuiPlatform(): MobilePlatform =
        when defined(ios):
            mpIos
        else:
            mpAndroid

    fn mobileGuiEnsureHandles() =
        if mobileGuiWindow == nil:
            mobileGuiWindow = alloc 8
        if mobileGuiSurface == nil:
            mobileGuiSurface = alloc 8

    fn mobileGuiEnsureHost(title: str) =
        if mobileGuiHostReady:
            if len title > 0:
                mobileGuiHostCfg.title = title
            return
        let platform = mobileGuiPlatform()
        var cfg = defaultMobileAppConfig platform
        if len title > 0:
            cfg.title = title
        mobileGuiWidth = int32(cfg.width)
        mobileGuiHeight = int32(cfg.height)
        mobileGuiScale = if cfg.highDpi: 2.0 else: 1.0
        if mobileGuiScale <= 0.0:
            mobileGuiScale = 1.0
        mobileGuiLogicalW = float64(mobileGuiWidth / mobileGuiScale)
        mobileGuiLogicalH = float64(mobileGuiHeight / mobileGuiScale)
        mobileGuiHostCfg = toMobileHostConfig(cfg)
        cheng_mobile_host_init(&mobileGuiHostCfg)
        mobileGuiHostReady = true

    fn writeI32(p: void*, offset: int32, value: int32) =
        let ptrVal: int32* = int32*(ptr_add(p, offset))
        *ptrVal = value

    fn writeU32(p: void*, offset: int32, value: uint32) =
        let ptrVal: uint32* = uint32*(ptr_add(p, offset))
        *ptrVal = value

    fn writeF64(p: void*, offset: int32, value: float64) =
        let ptrVal: float64* = float64*(ptr_add(p, offset))
        *ptrVal = value

    fn writeBool(p: void*, offset: int32, value: bool) =
        let ptrVal: uint8* = uint8*(ptr_add(p, offset))
        *ptrVal = if value: uint8(1) else: uint8(0)

    fn writeText64(p: void*, offset: int32, text: str) =
        for idx in 0..<64:
            let ch: char = if idx < total: text[idx] else: '\0'
            let ptrVal: uint8* = uint8*(ptr_add(p, offset + idx))
            let code: int32 = ord ch
            *ptrVal = uint8(code)

    fn mobileEventKind(kind: MobileRuntimeEventKind): int32 =
        case kind
        of mrePointerDown:
            7
        of mrePointerUp:
            8
        of mrePointerMove:
            9
        of mrePointerScroll:
            10
        of mreKeyDown:
            4
        of mreKeyUp:
            5
        of mreTextInput:
            6
        of mreWindowOpened:
            2
        of mreRuntimeStopped:
            1
        else:
            0

    fn writeMobileEvent(dest: void*, ev: MobileRuntimeEvent, kind: int32) =
        writeI32(dest, 0, kind)
        writeF64(dest, 16, ev.pointerX)
        writeF64(dest, 24, ev.pointerY)
        writeF64(dest, 32, float64(mobileGuiWidth))
        writeF64(dest, 40, float64(mobileGuiHeight))
        writeF64(dest, 48, ev.pointerDeltaX)
        writeF64(dest, 56, ev.pointerDeltaY)
        writeU32(dest, 64, uint32(0))
        writeI32(dest, 68, int32(ev.pointerButton))
        writeU32(dest, 72, uint32(ev.keyCode))
        writeBool(dest, 76, ev.keyRepeat)
        if kind == 6:
            writeText64(dest, 77, ev.text)
        else:
            writeText64(dest, 77, "")

    fn chengGuiNativeInitialize() =
        mobileGuiEnsureHost "Cheng IDE GUI"
        mobileGuiEnsureHandles()
        mobileGuiInitialized = true

    fn chengGuiNativeShutdown() =
        if mobileGuiHostReady:
            cheng_mobile_host_shutdown "exit"
        if mobileGuiWindow != nil:
            dealloc mobileGuiWindow
            mobileGuiWindow = nil
        if mobileGuiSurface != nil:
            dealloc mobileGuiSurface
            mobileGuiSurface = nil
        mobileGuiHostReady = false
        mobileGuiInitialized = false

    fn chengGuiNativeCreateDefaultWindow(title: str): void* =
        mobileGuiEnsureHost title
        mobileGuiEnsureHandles()
        let rc = cheng_mobile_host_open_window(&mobileGuiHostCfg)
        rc
        return mobileGuiWindow

    fn chengGuiNativeDestroyWindow(handle: void*) =
        handle

    fn chengGuiNativePollEvents(events: void*, maxEvents: int32, timeoutMs: int32): int32 =
        timeoutMs
        if events == nil || maxEvents <= 0:
            return 0
        var count: int32 = 0
        while count < maxEvents:
            var ev: MobileRuntimeEvent
            let got: int32 = cheng_mobile_host_poll_event(&ev)
            if got == 0:
                break
            let kind: int32 = mobileEventKind(ev.kind)
            if kind == 0:
                continue
            let dest: void* = ptr_add(events, count * MobileEventStride)
            writeMobileEvent(dest, ev, kind)
            count = count + 1
        return count

    fn chengGuiNativeCreateSurface(windowHandle: void*): void* =
        windowHandle
        mobileGuiEnsureHandles()
        return mobileGuiSurface

    fn chengGuiNativeDestroySurface(surfaceHandle: void*) =
        surfaceHandle

    fn chengGuiNativeBeginFrame(surfaceHandle: void*): int32 =
        surfaceHandle
        return 0

    fn chengGuiNativeEndFrame(surfaceHandle: void*): int32 =
        surfaceHandle
        return 0

    fn chengGuiNativeGetSurfaceInfo(surfaceHandle: void*, outInfo: NativeSurfaceInfo*): int32 =
        surfaceHandle
        if outInfo == nil:
            return -1
        outInfo.logicalWidth = mobileGuiLogicalW
        outInfo.logicalHeight = mobileGuiLogicalH
        outInfo.pixelWidth = float64(mobileGuiWidth)
        outInfo.pixelHeight = float64(mobileGuiHeight)
        outInfo.scale = mobileGuiScale
        outInfo.colorSpace = mobileColorSpace
        return 0

    fn chengGuiNativePresentPixels(surfaceHandle: void*, pixels: void*, width: int32, height: int32, strideBytes: int32): int32 =
        surfaceHandle
        if pixels == nil:
            return -1
        mobileHostPresentPixels(pixels, width, height, strideBytes)
        return 0

    fn chengGuiNativeDrawTextBgra(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32 =
        pixels
        width
        height
        strideBytes
        x
        y
        w
        h
        color
        fontSize
        text
        return -1

    fn chengGuiNativeDrawTextBgraLen(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring, textLen: int32): int32 =
        textLen
        return chengGuiNativeDrawTextBgra(pixels, width, height, strideBytes, x, y, w, h, color, fontSize, text)

    fn chengGuiNativeDrawTextBgraCode(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32 =
        return chengGuiNativeDrawTextBgra(pixels, width, height, strideBytes, x, y, w, h, color, fontSize, text)

    fn chengGuiNativeDrawTextBgraIcon(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32 =
        return chengGuiNativeDrawTextBgra(pixels, width, height, strideBytes, x, y, w, h, color, fontSize, text)

    fn chengGuiNativeDrawTextBgraFileIcon(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32 =
        return chengGuiNativeDrawTextBgra(pixels, width, height, strideBytes, x, y, w, h, color, fontSize, text)

    fn chengGuiNativeEventStructSize(): uint =
        return uint(MobileEventStride)

    fn chengGuiNativeTextAvailable(): int32 =
        return 0

    fn chengGuiNativeTextBackend(): cstring =
        return "unavailable"

    fn chengGuiIconFontAvailable(): int32 =
        return 0

    fn chengGuiFileIconFontAvailable(): int32 =
        return 0

    fn chengGuiIconGlyphAvailable(text: cstring): int32 =
        text
        return 0

    fn chengGuiFileIconGlyphAvailable(text: cstring): int32 =
        text
        return 0

    fn chengGuiDrawTextBgra(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32 =
        return chengGuiNativeDrawTextBgra(pixels, width, height, strideBytes, x, y, w, h, color, fontSize, text)

    fn chengGuiTextWidth(text: cstring, fontSize: float64): float64 =
        text
        fontSize
        return 0.0

    fn chengGuiTextWidthCode(text: cstring, fontSize: float64): float64 =
        return chengGuiTextWidth(text, fontSize)

    fn chengGuiTextWidthIcon(text: cstring, fontSize: float64): float64 =
        return chengGuiTextWidth(text, fontSize)

    fn chengGuiTextWidthFileIcon(text: cstring, fontSize: float64): float64 =
        return chengGuiTextWidth(text, fontSize)

    fn chengGuiTextXAtIndex(text: cstring, fontSize: float64, byteIndex: int32): float64 =
        text
        fontSize
        byteIndex
        return 0.0

    fn chengGuiTextXAtIndexCode(text: cstring, fontSize: float64, byteIndex: int32): float64 =
        return chengGuiTextXAtIndex(text, fontSize, byteIndex)

    fn chengGuiTextIndexAtX(text: cstring, fontSize: float64, x: float64): int32 =
        text
        fontSize
        x
        return 0

    fn chengGuiTextIndexAtXCode(text: cstring, fontSize: float64, x: float64): int32 =
        return chengGuiTextIndexAtX(text, fontSize, x)
else:
    @ importc("chengGuiNativeInitialize")
    fn chengGuiNativeInitialize()
    @ importc("chengGuiNativeShutdown")
    fn chengGuiNativeShutdown()
    @ importc("chengGuiNativeCreateDefaultWindow")
    fn chengGuiNativeCreateDefaultWindow(title: str): void*
    @ importc("chengGuiNativeDestroyWindow")
    fn chengGuiNativeDestroyWindow(handle: void*)
    @ importc("chengGuiNativePollEvents")
    fn chengGuiNativePollEvents(events: void*, maxEvents: int32, timeoutMs: int32): int32
    @ importc("chengGuiNativeCreateSurface")
    fn chengGuiNativeCreateSurface(windowHandle: void*): void*
    @ importc("chengGuiNativeDestroySurface")
    fn chengGuiNativeDestroySurface(surfaceHandle: void*)
    @ importc("chengGuiNativeBeginFrame")
    fn chengGuiNativeBeginFrame(surfaceHandle: void*): int32
    @ importc("chengGuiNativeEndFrame")
    fn chengGuiNativeEndFrame(surfaceHandle: void*): int32
    @ importc("chengGuiNativeGetSurfaceInfo")
    fn chengGuiNativeGetSurfaceInfo(surfaceHandle: void*, outInfo: NativeSurfaceInfo*): int32
    @ importc("chengGuiNativePresentPixels")
    fn chengGuiNativePresentPixels(surfaceHandle: void*, pixels: void*, width: int32, height: int32, strideBytes: int32): int32
    @ importc("chengGuiNativeDrawTextBgra")
    fn chengGuiNativeDrawTextBgra(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32
    @ importc("chengGuiNativeDrawTextBgraLen")
    fn chengGuiNativeDrawTextBgraLen(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring, textLen: int32): int32
    @ importc("chengGuiNativeDrawTextBgraCode")
    fn chengGuiNativeDrawTextBgraCode(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32
    @ importc("chengGuiNativeDrawTextBgraIcon")
    fn chengGuiNativeDrawTextBgraIcon(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32
    @ importc("chengGuiNativeDrawTextBgraFileIcon")
    fn chengGuiNativeDrawTextBgraFileIcon(pixels: void*, width: int32, height: int32, strideBytes: int32, x: float64, y: float64, w: float64, h: float64, color: uint32, fontSize: float64, text: cstring): int32
    @ importc("chengGuiNativeEventStructSize")
    fn chengGuiNativeEventStructSize(): uint
    @ importc("chengGuiNativeTextAvailable")
    fn chengGuiNativeTextAvailable(): int32
    @ importc("chengGuiNativeTextBackend")
    fn chengGuiNativeTextBackend(): cstring
    @ importc("chengGuiIconFontAvailable")
    fn chengGuiIconFontAvailable(): int32
    @ importc("chengGuiFileIconFontAvailable")
    fn chengGuiFileIconFontAvailable(): int32
    @ importc("chengGuiIconGlyphAvailable")
    fn chengGuiIconGlyphAvailable(text: cstring): int32
    @ importc("chengGuiFileIconGlyphAvailable")
    fn chengGuiFileIconGlyphAvailable(text: cstring): int32
    @ importc("chengGuiTextWidth")
    fn chengGuiTextWidth(text: cstring, fontSize: float64): float64
    @ importc("chengGuiTextWidthCode")
    fn chengGuiTextWidthCode(text: cstring, fontSize: float64): float64
    @ importc("chengGuiTextWidthIcon")
    fn chengGuiTextWidthIcon(text: cstring, fontSize: float64): float64
    @ importc("chengGuiTextWidthFileIcon")
    fn chengGuiTextWidthFileIcon(text: cstring, fontSize: float64): float64
    @ importc("chengGuiTextXAtIndex")
    fn chengGuiTextXAtIndex(text: cstring, fontSize: float64, byteIndex: int32): float64
    @ importc("chengGuiTextXAtIndexCode")
    fn chengGuiTextXAtIndexCode(text: cstring, fontSize: float64, byteIndex: int32): float64
    @ importc("chengGuiTextIndexAtX")
    fn chengGuiTextIndexAtX(text: cstring, fontSize: float64, x: float64): int32
    @ importc("chengGuiTextIndexAtXCode")
    fn chengGuiTextIndexAtXCode(text: cstring, fontSize: float64, x: float64): int32

@ importc("setenv")
fn cSetEnv(key: str, value: str, overwrite: int32): int32

fn drawTextLine(pixels: void*, width, height, strideBytes: int32, x, y: float64, color: uint32, fontSize: float64, text: str): bool =
    if nativeTextMetricsAvailable() && isPrivateUseGlyph(text):
        if useFileIcons():
            let rcFile: int32 = chengGuiNativeDrawTextBgraFileIcon(pixels, width, height, strideBytes, x, y, 0.0, 0.0, color, fontSize, text)
            if rcFile == 0:
                return true
        if useCodicons():
            let rcIcon: int32 = chengGuiNativeDrawTextBgraIcon(pixels, width, height, strideBytes, x, y, 0.0, 0.0, color, fontSize, text)
            if rcIcon == 0:
                return true
    let rc: int32 = chengGuiNativeDrawTextBgraLen(pixels, width, height, strideBytes, x, y, 0.0, 0.0, color, fontSize, cstring(text), int32(len(text)))
    return rc == 0

fn drawCodeLine(pixels: void*, width, height, strideBytes: int32, x, y: float64, color: uint32, fontSize: float64, text: str): bool =
    let rc: int32 = chengGuiNativeDrawTextBgraCode(pixels, width, height, strideBytes, x, y, 0.0, 0.0, color, fontSize, cstring(text))
    return rc == 0

fn drawTextBlock(pixels: void*, width, height, strideBytes: int32, x, y: float64, color: uint32, fontSize: float64, lineHeight: float64, text: str) =
    for idx in 0..total:
        if idx == total || text[idx] == '\n':
            let line = if idx > lineStart: text[lineStart ..< idx] else: ""
            if len(line) > 0:
                drawTextLine(pixels, width, height, strideBytes, x, lineY, color, fontSize, line)
            lineY = lineY + lineHeight
            lineStart = idx + 1

fn nativeTextMetricsAvailable(): bool =
    if chengGuiNativeTextAvailable() == 0:
        return false
    let backend: str = $chengGuiNativeTextBackend()
    return startsWithPrefix(backend, "macos")

fn textWidthForToken(text: str, layout: GuiLayout): float64 =
    if len(text) == 0:
        return 0.0
    if nativeTextMetricsAvailable():
        let width: float64 = chengGuiTextWidthCode(text, layout.fontSize)
        if width > 0.0:
            return width
    return float64(len(text) * layout.advance)

fn textWidthForCodeFont(text: str, fontSize: float64, layout: GuiLayout): float64 =
    if len(text) == 0:
        return 0.0
    if nativeTextMetricsAvailable():
        let width: float64 = chengGuiTextWidthCode(text, fontSize)
        if width > 0.0:
            return width
    var scale: float64 = 1.0
    if layout.fontSize > 0.0:
        scale = fontSize / layout.fontSize
    return float64(len(text) * layout.advance * scale)

fn textWidthForFont(text: str, fontSize: float64, layout: GuiLayout): float64 =
    if len(text) == 0:
        return 0.0
    if nativeTextMetricsAvailable():
        if isPrivateUseGlyph(text):
            if useFileIcons():
                let fileWidth: float64 = chengGuiTextWidthFileIcon(text, fontSize)
                if fileWidth > 0.0:
                    return fileWidth
            if useCodicons():
                let iconWidth: float64 = chengGuiTextWidthIcon(text, fontSize)
                if iconWidth > 0.0:
                    return iconWidth
        let width: float64 = chengGuiTextWidth(text, fontSize)
        if width > 0.0:
            return width
    var scale: float64 = 1.0
    if layout.fontSize > 0.0:
        scale = fontSize / layout.fontSize
    return float64(len(text) * layout.advance * scale)

fn textXForCol(text: str, col: int32, layout: GuiLayout): float64 =
    let clamped: int32 = clampInt(col, 0, len(text))
    if nativeTextMetricsAvailable() && len(text) > 0:
        let xVal: float64 = chengGuiTextXAtIndexCode(text, layout.fontSize, clamped)
        if xVal < 0.0:
            return 0.0
        return xVal
    return float64(clamped * layout.advance)

fn textColForX(text: str, x: float64, layout: GuiLayout): int32 =
    if x <= 0.0 || len(text) == 0:
        return 0
    if nativeTextMetricsAvailable():
        let idx: int32 = chengGuiTextIndexAtXCode(text, layout.fontSize, x)
        return utf8SnapForward(text, clampInt(idx, 0, len(text)))
    let col: int32 = int32(x / layout.advance)
    return utf8SnapForward(text, clampInt(col, 0, len(text)))

fn drawToken(pixels: void*, width, height, strideBytes: int32, x, y: float64, color: uint32, layout: GuiLayout, token: str): float64 =
    if len(token) == 0:
        return x
    drawCodeLine(pixels, width, height, strideBytes, x, y, color, layout.fontSize, token)
    return x + textWidthForToken(token, layout)

fn lineChecksum(text: str): int32 =
    var hash: int32 = 5381
    for idx in 0..<total:
        hash = hash * 33 + int32(ord(text[idx]))
    return hash

fn syntaxTokenCacheReset(bufferId: int32) =
    if syntaxTokenCacheBufferId != bufferId:
        syntaxTokenCacheBufferId = bufferId
        syntaxTokenCacheTick = 0
        syntaxTokenCache.len = 0

fn findSyntaxTokenCacheLine(lineIdx: int32): int32 =
    for idx in 0..<len(syntaxTokenCache):
        if syntaxTokenCache[idx].line == lineIdx:
            return idx
    return -1

fn vectorToSyntaxTokenSeq(tokens: syntax.seq_SyntaxToken): syntax.SyntaxToken[] =
    let count: int32 = tokens.len
    if count <= 0:
        return default[syntax.SyntaxToken[]]
    var outVal: syntax.SyntaxToken[count]
    for idx in 0..<count:
        outVal[idx] = syntax.get_SyntaxToken(tokens, idx)
    return outVal

fn trimSyntaxTokenCache() =
    if len(syntaxTokenCache) <= SyntaxTokenCacheMaxEntries:
        return
    var oldestIdx: int32 = 0
    var oldestStamp: int32 = syntaxTokenCache[0].stamp
    for idx in 1..<len(syntaxTokenCache):
        if syntaxTokenCache[idx].stamp < oldestStamp:
            oldestStamp = syntaxTokenCache[idx].stamp
            oldestIdx = idx
    let last: int32 = len(syntaxTokenCache) - 1
    if oldestIdx != last:
        syntaxTokenCache[oldestIdx] = syntaxTokenCache[last]
    syntaxTokenCache.len = last

fn syntaxTokensForLine(bufferId: int32, lineIdx: int32, lineText: str): syntax.SyntaxToken[] =
    syntaxTokenCacheReset(bufferId)
    let checksum: int32 = lineChecksum(lineText)
    let pos: int32 = findSyntaxTokenCacheLine(lineIdx)
    syntaxTokenCacheTick = syntaxTokenCacheTick + 1
    if pos >= 0:
        var entry = syntaxTokenCache[pos]
        if entry.hash == checksum:
            entry.stamp = syntaxTokenCacheTick
            syntaxTokenCache[pos] = entry
            return entry.tokens
    let scanned: syntax.seq_SyntaxToken = syntax.scanLineTokens(lineText)
    let tokens: syntax.SyntaxToken[] = vectorToSyntaxTokenSeq(scanned)
    var entry: SyntaxTokenCacheEntry
    entry.line = lineIdx
    entry.hash = checksum
    entry.stamp = syntaxTokenCacheTick
    entry.tokens = tokens
    if pos >= 0:
        syntaxTokenCache[pos] = entry
    else:
        syntaxTokenCache.add(entry)
        trimSyntaxTokenCache()
    return tokens

fn drawCodeLineColored(pixels: void*, width, height, strideBytes: int32, x, y: float64, layout: GuiLayout, theme: GuiTheme, bufferId: int32, lineIdx: int32, line: str) =
    var cursorX: float64 = x
    let tokens: syntax.SyntaxToken[] = syntaxTokensForLine(bufferId, lineIdx, line)
    for i in 0..<len(tokens):
        let token: syntax.SyntaxToken = tokens[i]
        var color: uint32 = theme.text
        if token.kind == syntax.tkKeyword:
            color = theme.keyword
        elif token.kind == syntax.tkType:
            color = theme.typeColor
        elif token.kind == syntax.tkString:
            color = theme.stringColor
        elif token.kind == syntax.tkNumber:
            color = theme.number
        elif token.kind == syntax.tkComment:
            color = theme.comment
        cursorX = drawToken(pixels, width, height, strideBytes, cursorX, y, color, layout, token.text)

fn drawMinimap(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState, x, y, w, h: int32) =
    if w <= 4 || h <= 4:
        return
    if state.editor.largeFile:
        return
    let totalVisible: int32 = visibleLineCount(state.editor)
    if totalVisible <= 0:
        return
    fillRect(pixels, width, height, strideBytes, x, y, w, h, theme.panel)
    let maxMarks: int32 = maxInt(1, h)
    let step: int32 = maxInt(1, totalVisible / maxMarks)
    var offset: int32 = 0
    var lastY: int32 = -1
    while offset < totalVisible:
        let lineIdx: int32 = visibleLineAtOffset(state.editor, 0, offset)
        let lineText = seqGetString(state.editor.lines, lineIdx)
        let markColor: uint32 = if len(trimLine(lineText)) == 0: theme.border else: theme.subText
        let yPos: int32 = y + int32(float64(offset * float64(h) / float64(totalVisible)))
        if yPos != lastY:
            let markW: int32 = maxInt(1, w - 4)
            fillRect(pixels, width, height, strideBytes, x + 2, yPos, markW, 1, markColor)
            lastY = yPos
        offset = offset + step
    let pane: int32 = if state.editor.splitActive: state.editor.splitPane else: 0
    let paneMetrics: EditorPaneMetrics = editorPaneMetrics(state.layout, pane, state.editor.splitActive)
    let visibleLines: int32 = maxInt(1, int32(float64(paneMetrics.h / state.layout.lineHeight)))
    let startLine: int32 = normalizeVisibleLine(state.editor, scrollLineForPane(state.editor, pane))
    let topOffset: int32 = visibleRowForLine(state.editor, 0, startLine, totalVisible)
    if topOffset >= 0:
        let bottomOffset: int32 = minInt(totalVisible, topOffset + visibleLines)
        let y0: int32 = y + int32(float64(topOffset * float64(h) / float64(totalVisible)))
        let y1: int32 = y + int32(float64(bottomOffset * float64(h) / float64(totalVisible)))
        let viewH: int32 = maxInt(2, y1 - y0)
        fillRect(pixels, width, height, strideBytes, x + 1, y0, maxInt(1, w - 2), viewH, theme.selection)
    let cursorOffset: int32 = visibleRowForLine(state.editor, 0, state.editor.cursorLine, totalVisible)
    if cursorOffset >= 0:
        let yCursor: int32 = y + int32(float64(cursorOffset * float64(h) / float64(totalVisible)))
        fillRect(pixels, width, height, strideBytes, x + 1, yCursor, maxInt(1, w - 2), 1, theme.accent)

fn guiDiagSeverityRank(sev: diag.GuiDiagSeverity): int32 =
    if sev == diag.gdsError:
        return 3
    if sev == diag.gdsWarning:
        return 2
    if sev == diag.gdsInfo:
        return 1
    return 0

fn guiDiagColor(theme: GuiTheme, sev: diag.GuiDiagSeverity): uint32 =
    if sev == diag.gdsError:
        return theme.diagError
    if sev == diag.gdsWarning:
        return theme.diagWarning
    if sev == diag.gdsInfo:
        return theme.diagInfo
    return 0

fn guiDiagLineSeverity(diags: diag.seq_GuiDiagnostic, line: int32): diag.GuiDiagSeverity =
    var best: diag.GuiDiagSeverity = diag.gdsNone
    var bestRank: int32 = 0
    for idx in 0..<diags.len:
        let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(diags, idx)
        if entry.line == line:
            let rank: int32 = guiDiagSeverityRank(entry.severity)
            if rank > bestRank:
                bestRank = rank
                best = entry.severity
                if rank >= 3:
                    return best
    return best

fn guiDiagLineCache(diags: diag.seq_GuiDiagnostic, lineCount: int32): diag.GuiDiagSeverity[] =
    if lineCount <= 0:
        return default[diag.GuiDiagSeverity[]]
    var outVal: diag.GuiDiagSeverity[lineCount]
    for idx in 0..<diags.len:
        let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(diags, idx)
        let line: int32 = entry.line
        if line >= 0 && line < lineCount:
            let rank: int32 = guiDiagSeverityRank(entry.severity)
            let current: diag.GuiDiagSeverity = outVal[line]
            let currentRank: int32 = guiDiagSeverityRank(current)
            if rank > currentRank:
                outVal[line] = entry.severity
    return outVal

fn guiDiagLabel(entry: diag.GuiDiagnostic): str =
    let lineText = intToStr(int32(entry.line + 1))
    let colText = intToStr(int32(entry.col + 1))
    return lineText + ":" + colText + " " + entry.message

fn guiDiagSeverityLabel(sev: diag.GuiDiagSeverity): str =
    if sev == diag.gdsError:
        return "error"
    if sev == diag.gdsWarning:
        return "warning"
    if sev == diag.gdsInfo:
        return "info"
    return ""

fn guiDiagMessageAt(diags: diag.seq_GuiDiagnostic, line: int32, col: int32): str =
    var bestIdx: int32 = -1
    var bestDist: int32 = 999999
    for idx in 0..<diags.len:
        let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(diags, idx)
        if entry.line == line:
            let dist: int32 = absInt(col - entry.col)
            if dist <= 8 && dist < bestDist:
                bestDist = dist
                bestIdx = idx
    if bestIdx < 0:
        return ""
    let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(diags, bestIdx)
    let label = guiDiagSeverityLabel(entry.severity)
    if len(label) > 0:
        return label + ": " + entry.message
    return entry.message

fn guiDiagFindIndexAtLine(diags: diag.seq_GuiDiagnostic, line: int32, col: int32): int32 =
    var bestIdx: int32 = -1
    var bestDist: int32 = 0x7fffffff
    for idx in 0..<diags.len:
        let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(diags, idx)
        if entry.line == line:
            let dist: int32 = absInt(col - entry.col)
            if dist < bestDist:
                bestDist = dist
                bestIdx = idx
    return bestIdx

fn guiDiagQuotedChar(message: str, which: int32): char =
    if which <= 0:
        return '\0'
    var idx: int32 = 0
    var count: int32 = 0
    let total: int32 = len(message)
    while idx + 1 < total:
        if message[idx] == '\'':
            count = count + 1
            if count == which:
                return message[idx + 1]
            idx = idx + 2
            continue
        idx = idx + 1
    return '\0'

fn guiEnsureDiagnostics(state: GuiState): GuiState =
    if state.diagnosticsDirty:
        return guiUpdateDiagnostics(state)
    return state

fn quickFixField(entry: str, fieldIndex: int32): str =
    let total: int32 = len(entry)
    for idx in 0..total:
        let isEnd: bool = idx == total
        if isEnd || entry[idx] == '|':
            if field == fieldIndex:
                if idx <= start:
                    return ""
                return sliceRange(entry, start, idx - 1)
            field = field + 1
            start = idx + 1
    return ""

fn makeQuickFixEntry(kind: str, line, col: int32, ch: char, label: str): str =
    return kind + "|" + intToStr(line) + "|" + intToStr(col) + "|" + charToStr(ch) + "|" + label

fn quickFixKind(entry: str): str =
    return quickFixField(entry, 0)

fn quickFixLine(entry: str): int32 =
    return parseInt32(quickFixField(entry, 1), 0)

fn quickFixCol(entry: str): int32 =
    return parseInt32(quickFixField(entry, 2), 0)

fn quickFixChar(entry: str): char =
    let text: str = quickFixField(entry, 3)
    if len(text) > 0:
        return text[0]
    return '\0'

fn quickFixLabel(entry: str): str =
    return quickFixField(entry, 4)

fn lineHasTrailingWhitespace(line: str): bool =
    if len(line) == 0:
        return false
    let last: char = line[len(line) - 1]
    return last == ' ' || last == '\t'

fn lineHasTab(line: str): bool =
    if len(line) == 0:
        return false
    for idx in 0..<len(line):
        if line[idx] == '\t':
            return true
    return false

fn fileHasTrailingWhitespace(lines: str[]): bool =
    for idx in 0..<seqLenString(lines):
        if lineHasTrailingWhitespace(seqGetString(lines, idx)):
            return true
    return false

fn fileHasTab(lines: str[]): bool =
    for idx in 0..<seqLenString(lines):
        if lineHasTab(seqGetString(lines, idx)):
            return true
    return false

fn fileMissingFinalNewline(lines: str[]): bool =
    let count: int32 = seqLenString(lines)
    if count <= 0:
        return false
    let lastLine = seqGetString(lines, count - 1)
    return len(lastLine) > 0

fn fileHasExtraTrailingBlankLines(lines: str[]): bool =
    let count: int32 = seqLenString(lines)
    if count <= 1:
        return false
    var blanks: int32 = 0
    let idxBase = count - 1
    if idxBase >= 0:
        for idxRev in 0..idxBase:
            let idx = idxBase - idxRev
            let lineText = seqGetString(lines, idx)
            if len(trimLine(lineText)) == 0:
                blanks = blanks + 1
                continue
            break
        let lineText = seqGetString(lines, idx)
        if len(trimLine(lineText)) == 0:
            blanks = blanks + 1
            continue
        break
    return blanks > 1

fn fileHasDuplicateBlankLines(lines: str[]): bool =
    for idx in 0..<seqLenString(lines):
        let lineText = seqGetString(lines, idx)
        let isBlank: bool = len(trimLine(lineText)) == 0
        if isBlank && prevBlank:
            return true
        prevBlank = isBlank
    return false

fn guiQuickFixEntriesForDiag(entry: diag.GuiDiagnostic): str[] =
    var outVal: str[] = default[str[]]
    let msg: str = entry.message
    if startsWithPrefix(msg, "missing '"):
        let expected: char = guiDiagQuotedChar(msg, 1)
        if expected != '\0':
            let label: str = "Insert '" + charToStr(expected) + "'"
            addPtr_string(&outVal, makeQuickFixEntry("insert", entry.line, entry.col, expected, label))
        return outVal
    if startsWithPrefix(msg, "unterminated str"):
        addPtr_string(&outVal, makeQuickFixEntry("insert", entry.line, entry.col, '"', "Insert '\"'"))
        return outVal
    if startsWithPrefix(msg, "unterminated char"):
        addPtr_string(&outVal, makeQuickFixEntry("insert", entry.line, entry.col, '\'', "Insert '''"))
        return outVal
    if startsWithPrefix(msg, "unmatched '"):
        let actual: char = guiDiagQuotedChar(msg, 1)
        if actual != '\0':
            let label: str = "Remove '" + charToStr(actual) + "'"
            addPtr_string(&outVal, makeQuickFixEntry("remove", entry.line, entry.col, actual, label))
        return outVal
    if startsWithPrefix(msg, "mismatched '"):
        let expected: char = guiDiagQuotedChar(msg, 2)
        if expected != '\0':
            let label: str = "Replace with '" + charToStr(expected) + "'"
            addPtr_string(&outVal, makeQuickFixEntry("replace", entry.line, entry.col, expected, label))
        return outVal
    return outVal

fn guiQuickFixEntriesAtPosition(state: GuiState, lineIdx: int32, colIdx: int32): str[] =
    var outVal: str[] = default[str[]]
    let diagIdx: int32 = guiDiagFindIndexAtLine(state.diagnostics, lineIdx, colIdx)
    if diagIdx >= 0:
        let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(state.diagnostics, diagIdx)
        let diagFixes: str[] = guiQuickFixEntriesForDiag(entry)
        for dIdx in 0..<seqLenString(diagFixes):
            addPtr_string(&outVal, seqGetString(diagFixes, dIdx))
    if lineIdx >= 0 && lineIdx < seqLenString(state.editor.lines):
        let lineText = seqGetString(state.editor.lines, lineIdx)
        if lineHasTrailingWhitespace(lineText):
            addPtr_string(&outVal, makeQuickFixEntry("trim-trailing", lineIdx, 0, '\0', "Trim trailing whitespace"))
        if lineHasTab(lineText):
            addPtr_string(&outVal, makeQuickFixEntry("tabs-to-spaces", lineIdx, 0, '\0', "Convert tabs to spaces"))
        let dedentTarget: int32 = dedentLineTargetIndent(state.editor.lines, lineIdx)
        if dedentTarget >= 0:
            addPtr_string(&outVal, makeQuickFixEntry("align-indent", lineIdx, dedentTarget, '\0', "Align indentation"))
        let closeTarget: int32 = closeBracketTargetIndent(state.editor.lines, lineIdx)
        if closeTarget >= 0:
            addPtr_string(&outVal, makeQuickFixEntry("align-close", lineIdx, closeTarget, '\0', "Align closing bracket"))
    if fileHasTrailingWhitespace(state.editor.lines):
        addPtr_string(&outVal, makeQuickFixEntry("trim-trailing-file", 0, 0, '\0', "Trim trailing whitespace (file)"))
    if fileHasTab(state.editor.lines):
        addPtr_string(&outVal, makeQuickFixEntry("tabs-to-spaces-file", 0, 0, '\0', "Convert tabs to spaces (file)"))
    if fileHasExtraTrailingBlankLines(state.editor.lines):
        addPtr_string(&outVal, makeQuickFixEntry("trim-blank-eof", 0, 0, '\0', "Trim trailing empty lines (file)"))
    if fileHasDuplicateBlankLines(state.editor.lines):
        addPtr_string(&outVal, makeQuickFixEntry("collapse-blank-lines", 0, 0, '\0', "Collapse blank lines (file)"))
    if fileMissingFinalNewline(state.editor.lines):
        addPtr_string(&outVal, makeQuickFixEntry("ensure-final-newline", 0, 0, '\0', "Ensure final newline (file)"))
    let importBlock: LineRange = findImportBlock(state.editor.lines)
    if importBlock.active && importBlockUnsorted(state.editor.lines, importBlock):
        addPtr_string(&outVal, makeQuickFixEntry("sort-imports", importBlock.startLine, 0, '\0', "Sort imports (file)"))
    return outVal

fn guiApplyQuickFixEntry(state: GuiState, entry: str): GuiState =
    let kind: str = quickFixKind(entry)
    let lineIdx: int32 = quickFixLine(entry)
    let colIdx: int32 = quickFixCol(entry)
    let ch: char = quickFixChar(entry)
    if kind == "insert":
        if ch == '\0':
            state.statusMsg = "action: invalid"
            return state
        return guiQuickFixInsertChar(state, lineIdx, ch)
    if kind == "remove":
        if ch == '\0':
            state.statusMsg = "action: invalid"
            return state
        return guiQuickFixRemoveChar(state, lineIdx, colIdx, ch)
    if kind == "replace":
        if ch == '\0':
            state.statusMsg = "action: invalid"
            return state
        return guiQuickFixReplaceChar(state, lineIdx, colIdx, ch)
    if kind == "trim-trailing":
        return guiQuickFixTrimTrailing(state, lineIdx)
    if kind == "tabs-to-spaces":
        return guiQuickFixTabsToSpaces(state, lineIdx)
    if kind == "align-indent":
        return guiQuickFixReindentLine(state, lineIdx, colIdx, "action: align indentation")
    if kind == "align-close":
        return guiQuickFixReindentLine(state, lineIdx, colIdx, "action: align closing bracket")
    if kind == "trim-trailing-file":
        return guiQuickFixTrimTrailingFile(state)
    if kind == "tabs-to-spaces-file":
        return guiQuickFixTabsToSpacesFile(state)
    if kind == "trim-blank-eof":
        return guiQuickFixTrimTrailingBlankLines(state)
    if kind == "collapse-blank-lines":
        return guiQuickFixCollapseBlankLinesFile(state)
    if kind == "ensure-final-newline":
        return guiQuickFixEnsureFinalNewline(state)
    if kind == "sort-imports":
        return guiQuickFixSortImportsFile(state)
    state.statusMsg = "action: unsupported"
    return state

fn guiListQuickFixesAtCursor(state: GuiState): GuiState =
    var next: GuiState = guiEnsureDiagnostics(state)
    let fixes: str[] = guiQuickFixEntriesAtPosition(next, next.editor.cursorLine, next.editor.cursorCol)
    if seqLenString(fixes) == 0:
        next.statusMsg = "action: no fixes"
        return next
    next.terminal = pushTerminalLine(next.terminal, "action: " + intToStr(seqLenString(fixes)))
    for idx in 0..<seqLenString(fixes):
        let entry = seqGetString(fixes, idx)
        let lineText = intToStr(idx + 1) + ". " + quickFixLabel(entry)
        next.terminal = pushTerminalLine(next.terminal, lineText)
    next.statusMsg = "action: listed"
    return next

fn guiApplyQuickFixAtCursorIndex(state: GuiState, index: int32): GuiState =
    var next: GuiState = guiEnsureDiagnostics(state)
    let fixes: str[] = guiQuickFixEntriesAtPosition(next, next.editor.cursorLine, next.editor.cursorCol)
    if seqLenString(fixes) == 0:
        next.statusMsg = "action: no fixes"
        return next
    if index < 0 || index >= seqLenString(fixes):
        next.statusMsg = "action: index out of range"
        return next
    let entry = seqGetString(fixes, index)
    return guiApplyQuickFixEntry(next, entry)

fn guiMergeDiagnostics(primary: diag.seq_GuiDiagnostic, extra: diag.seq_GuiDiagnostic): diag.seq_GuiDiagnostic =
    let total: int32 = primary.len + extra.len
    var outVal: diag.seq_GuiDiagnostic = diag.guiDiagNewSeq_GuiDiagnostic(0, total)
    for idx in 0..<primary.len:
        diag.guiDiagAddPtr_GuiDiagnostic(&outVal, diag.guiDiagGet_GuiDiagnostic(primary, idx))
    for idx in 0..<extra.len:
        diag.guiDiagAddPtr_GuiDiagnostic(&outVal, diag.guiDiagGet_GuiDiagnostic(extra, idx))
    return outVal

fn guiDiagScanStart(state: GuiState): GuiState =
    var next: GuiState = state
    next.diagScanActive = true
    next.diagScanLine = 0
    next.diagScanVersion = next.editor.bufferVersion
    next.diagScanStack = diag.guiDiagNewSeq_GuiDiagStackEntry(0, 0)
    next.diagScanDiags = diag.guiDiagNewSeq_GuiDiagnostic(0, 0)
    return next

fn guiDiagScanTick(state: GuiState, maxLines: int32, budgetMs: int32): GuiState =
    if ! state.diagnosticsDirty:
        return state
    if state.editor.largeFile:
        var next: GuiState = state
        next.diagnostics = next.langDiagnostics
        next.diagLineSev = guiDiagLineCache(next.diagnostics, seqLenString(next.editor.lines))
        next.diagnosticsDirty = false
        next.renderDirty = true
        return next
    var next: GuiState = state
    if ! next.diagScanActive || next.diagScanVersion != next.editor.bufferVersion:
        next = guiDiagScanStart(next)
    let total: int32 = seqLenString(next.editor.lines)
    var lineIdx: int32 = next.diagScanLine
    var processed: int32 = 0
    let startMs: int64 = guiNowMs()
    while lineIdx < total:
        if maxLines > 0 && processed >= maxLines:
            break
        if budgetMs > 0 && guiMsDiff(startMs, guiNowMs()) >= budgetMs:
            break
        let lineText = seqGetString(next.editor.lines, lineIdx)
        var i: int32 = 0
        let totalChars: int32 = len(lineText)
        while i < totalChars:
            let ch: char = lineText[i]
            if ch == '#':
                break
            if ch == '"' || ch == '\'':
                let quote: char = ch
                let start: int32 = i
                i = i + 1
                var closed = false
                while i < totalChars:
                    let c: char = lineText[i]
                    if c == '\\':
                        if i + 1 < totalChars:
                            i = i + 2
                        else:
                            i = i + 1
                    elif c == quote:
                        i = i + 1
                        closed = true
                        break
                    else:
                        i = i + 1
                if ! closed:
                    let msg = if quote == '"': "unterminated str(literal" else: "unterminated char(literal"
                    diag.guiDiagAdd(&next.diagScanDiags, diag.gdsError, lineIdx, start, msg)
                continue
            if diag.guiDiagIsOpenBrace(ch):
                var entry: diag.GuiDiagStackEntry
                entry.ch = ch
                entry.line = lineIdx
                entry.col = i
                diag.guiDiagAddPtr_GuiDiagStackEntry(&next.diagScanStack, entry)
                i = i + 1
                continue
            if diag.guiDiagIsCloseBrace(ch):
                if next.diagScanStack.len <= 0:
                    diag.guiDiagAdd(&next.diagScanDiags, diag.gdsError, lineIdx, i, "unmatched '" + charToStr(ch) + "'")
                    i = i + 1
                    continue
                let top: diag.GuiDiagStackEntry = diag.guiDiagGet_GuiDiagStackEntry(next.diagScanStack, next.diagScanStack.len - 1)
                if diag.guiDiagBraceMatches(top.ch, ch):
                    next.diagScanStack.len = next.diagScanStack.len - 1
                else:
                    let expected: char = diag.guiDiagClosingFor(top.ch)
                    diag.guiDiagAdd(&next.diagScanDiags, diag.gdsError, lineIdx, i, "mismatched '" + charToStr(ch) + "')), expected '" + charToStr(expected) + "'")
                    next.diagScanStack.len = next.diagScanStack.len - 1
                i = i + 1
                continue
            i = i + 1
        lineIdx = lineIdx + 1
        processed = processed + 1
    next.diagScanLine = lineIdx
    if lineIdx >= total:
        let sIdxBase = next.diagScanStack.len - 1
        if sIdxBase >= 0:
            for sIdxRev in 0..sIdxBase:
                let sIdx = sIdxBase - sIdxRev
                let entry: diag.GuiDiagStackEntry = diag.guiDiagGet_GuiDiagStackEntry(next.diagScanStack, sIdx)
                let expected: char = diag.guiDiagClosingFor(entry.ch)
                diag.guiDiagAdd(&next.diagScanDiags, diag.gdsError, entry.line, entry.col, "missing '" + charToStr(expected) + "'")
        next.diagnostics = guiMergeDiagnostics(next.diagScanDiags, next.langDiagnostics)
        next.diagLineSev = guiDiagLineCache(next.diagnostics, seqLenString(next.editor.lines))
        next.diagnosticsDirty = false
        next.diagScanActive = false
        next.renderDirty = true
        next = guiDesktopBridgeSave(next)
    return next

fn guiUpdateDiagnostics(state: GuiState): GuiState =
    var next: GuiState = state
    next.diagScanActive = false
    next.diagScanLine = 0
    if next.editor.largeFile:
        next.diagnostics = next.langDiagnostics
        next.diagLineSev = guiDiagLineCache(next.diagnostics, seqLenString(next.editor.lines))
        next.diagnosticsDirty = false
        next.renderDirty = true
        next = guiDesktopBridgeSave(next)
        return next
    let syntaxDiags: diag.seq_GuiDiagnostic = diag.guiDiagScanLines(next.editor.lines)
    next.diagnostics = guiMergeDiagnostics(syntaxDiags, next.langDiagnostics)
    next.diagLineSev = guiDiagLineCache(next.diagnostics, seqLenString(next.editor.lines))
    next.diagnosticsDirty = false
    next.renderDirty = true
    next = guiDesktopBridgeSave(next)
    return next

fn guiSetDiagnosticsDirty(state: GuiState): GuiState =
    state.diagnosticsDirty = true
    state.editor.bufferVersion = state.editor.bufferVersion + 1
    state.editor = invalidateSemanticState(state.editor, false)
    state.editor.outlineReady = false
    state.editor.outlineEntries = default[str[]]
    state.editor.outlineScanActive = false
    state.editor.outlineScanLine = 0
    state.editor.outlineScanVersion = state.editor.bufferVersion
    state.editor.outlineScanEntries = default[str[]]
    state.diagScanActive = false
    state.diagScanLine = 0
    state.diagScanVersion = state.editor.bufferVersion
    state.diagScanStack = diag.guiDiagNewSeq_GuiDiagStackEntry(0, 0)
    state.diagScanDiags = diag.guiDiagNewSeq_GuiDiagnostic(0, 0)
    if state.editor.largeFile:
        state.diagPending = false
        state.diagCooldown = 0
    elif state.diagAuto:
        state.diagPending = true
        state.diagCooldown = AutoDiagCooldownFrames
    if state.autoSave:
        state.autoSavePending = true
        state.autoSaveCooldown = AutoSaveCooldownFrames
    if state.recoveryEnabled && ! state.autoSave && state.editor.dirty:
        state.recoveryPending = true
        state.recoveryCooldown = RecoveryCooldownFrames
    return state

fn guiQuickFixUpdateLine(state: GuiState, lineIdx: int32, newLine: str, cursorCol: int32, status: str): GuiState =
    if lineIdx < 0 || lineIdx >= seqLenString(state.editor.lines):
        state.statusMsg = "action: invalid line"
        return state
    var next: GuiState = state
    next.editor = pushUndo(next.editor)
    seqSetString(&next.editor.lines, lineIdx, newLine)
    next.editor.cursorLine = lineIdx
    next.editor.cursorCol = clampInt(cursorCol, 0, len(newLine))
    next.editor.desiredCol = desiredColForLineText(newLine, next.editor.cursorCol)
    next.editor.selectionActive = false
    next.editor = clearMultiCursors(next.editor)
    next.editor.dirty = true
    next = guiInvalidateProjectIndex(next)
    next = guiSetDiagnosticsDirty(next)
    next.statusMsg = status
    return next

fn guiQuickFixInsertChar(state: GuiState, lineIdx: int32, ch: char): GuiState =
    if lineIdx < 0 || lineIdx >= seqLenString(state.editor.lines):
        state.statusMsg = "action: invalid line"
        return state
    let lineText = seqGetString(state.editor.lines, lineIdx)
    let commentIdx: int32 = commentStartIndex(lineText)
    let insertCol: int32 = if commentIdx >= 0: commentIdx else: len(lineText)
    let newLine = insertCharAt(lineText, insertCol, ch)
    return guiQuickFixUpdateLine(state, lineIdx, newLine, insertCol + 1, "action: insert '" + charToStr(ch) + "'")

fn guiQuickFixRemoveChar(state: GuiState, lineIdx: int32, col: int32, ch: char): GuiState =
    if lineIdx < 0 || lineIdx >= seqLenString(state.editor.lines):
        state.statusMsg = "action: invalid line"
        return state
    let lineText = seqGetString(state.editor.lines, lineIdx)
    if len(lineText) == 0:
        state.statusMsg = "action: nothing to remove"
        return state
    var targetCol: int32 = clampInt(col, 0, len(lineText) - 1)
    if targetCol >= 0 && targetCol < len(lineText) && lineText[targetCol] != ch:
        if targetCol > 0 && lineText[targetCol - 1] == ch:
            targetCol = targetCol - 1
    if targetCol < 0 || targetCol >= len(lineText):
        state.statusMsg = "action: no match"
        return state
    if lineText[targetCol] != ch:
        state.statusMsg = "action: no match"
        return state
    let newLine = removeCharAt(lineText, targetCol)
    return guiQuickFixUpdateLine(state, lineIdx, newLine, targetCol, "action: remove '" + charToStr(ch) + "'")

fn guiQuickFixReplaceChar(state: GuiState, lineIdx: int32, col: int32, ch: char): GuiState =
    if lineIdx < 0 || lineIdx >= seqLenString(state.editor.lines):
        state.statusMsg = "action: invalid line"
        return state
    let lineText = seqGetString(state.editor.lines, lineIdx)
    if len(lineText) == 0:
        state.statusMsg = "action: nothing to replace"
        return state
    let targetCol: int32 = clampInt(col, 0, len(lineText) - 1)
    if targetCol < 0 || targetCol >= len(lineText):
        state.statusMsg = "action: no match"
        return state
    let prefix = if targetCol > 0: sliceRange(lineText, 0, targetCol - 1) else: ""
    let suffix = if targetCol + 1 < len(lineText): sliceFrom(lineText, targetCol + 1) else: ""
    let newLine = prefix + charToStr(ch) + suffix
    return guiQuickFixUpdateLine(state, lineIdx, newLine, targetCol + 1, "action: replace with '" + charToStr(ch) + "'")

fn reindentLineText(lineText: str, targetIndent: int32): str =
    let trimmed = trimLeadingWhitespace(lineText)
    if len(trimmed) == 0:
        return ""
    if targetIndent <= 0:
        return trimmed
    return makeSpaces(targetIndent) + trimmed

fn guiQuickFixReindentLine(state: GuiState, lineIdx: int32, targetIndent: int32, status: str): GuiState =
    if lineIdx < 0 || lineIdx >= seqLenString(state.editor.lines):
        state.statusMsg = "action: invalid line"
        return state
    if targetIndent < 0:
        state.statusMsg = "action: no change"
        return state
    let lineText = seqGetString(state.editor.lines, lineIdx)
    let newLine = reindentLineText(lineText, targetIndent)
    if newLine == lineText:
        state.statusMsg = "action: no change"
        return state
    let oldIndent: int32 = leadingWhitespaceLen(lineText)
    let relCol: int32 = maxInt(0, state.editor.cursorCol - oldIndent)
    let newCol: int32 = targetIndent + relCol
    return guiQuickFixUpdateLine(state, lineIdx, newLine, newCol, status)

fn guiQuickFixTrimTrailing(state: GuiState, lineIdx: int32): GuiState =
    if lineIdx < 0 || lineIdx >= seqLenString(state.editor.lines):
        state.statusMsg = "action: invalid line"
        return state
    let lineText = seqGetString(state.editor.lines, lineIdx)
    let newLine = trimTrailingSpaces(lineText)
    if newLine == lineText:
        state.statusMsg = "action: no change"
        return state
    let cursorCol: int32 = minInt(state.editor.cursorCol, len(newLine))
    return guiQuickFixUpdateLine(state, lineIdx, newLine, cursorCol, "action: trim trailing whitespace")

fn guiQuickFixTabsToSpaces(state: GuiState, lineIdx: int32): GuiState =
    if lineIdx < 0 || lineIdx >= seqLenString(state.editor.lines):
        state.statusMsg = "action: invalid line"
        return state
    let lineText = seqGetString(state.editor.lines, lineIdx)
    let newLine = replaceTabs(lineText, TabSize)
    if newLine == lineText:
        state.statusMsg = "action: no change"
        return state
    let cursorCol: int32 = minInt(state.editor.cursorCol, len(newLine))
    return guiQuickFixUpdateLine(state, lineIdx, newLine, cursorCol, "action: convert tabs to spaces")

fn guiQuickFixUpdateFile(state: GuiState, newLines: str[], status: str): GuiState =
    var next: GuiState = state
    next.editor = pushUndo(next.editor)
    if seqLenString(newLines) == 0:
        var lines: str[] = default[str[]]
        addPtr_string(&lines, "")
        next.editor.lines = lines
    else:
        next.editor.lines = newLines
    let lineIdx: int32 = clampIndex(next.editor.cursorLine, seqLenString(next.editor.lines))
    next.editor.cursorLine = lineIdx
    let lineText = seqGetString(next.editor.lines, lineIdx)
    let col: int32 = clampInt(next.editor.cursorCol, 0, len(lineText))
    next.editor.cursorCol = col
    next.editor.desiredCol = desiredColForLineText(lineText, col)
    next.editor.selectionActive = false
    next.editor = clearMultiCursors(next.editor)
    next.editor.dirty = true
    next = guiInvalidateProjectIndex(next)
    next = guiSetDiagnosticsDirty(next)
    next.statusMsg = status
    return next

fn guiQuickFixTrimTrailingFile(state: GuiState): GuiState =
    var changed: bool = false
    var lines: str[] = default[str[]]
    for idx in 0..<seqLenString(state.editor.lines):
        let lineText = seqGetString(state.editor.lines, idx)
        let trimmed = trimTrailingSpaces(lineText)
        if trimmed != lineText:
            changed = true
        addPtr_string(&lines, trimmed)
    if ! changed:
        state.statusMsg = "action: no change"
        return state
    return guiQuickFixUpdateFile(state, lines, "action: trim trailing whitespace (file)")

fn guiQuickFixTabsToSpacesFile(state: GuiState): GuiState =
    var changed: bool = false
    var lines: str[] = default[str[]]
    for idx in 0..<seqLenString(state.editor.lines):
        let lineText = seqGetString(state.editor.lines, idx)
        let replaced = replaceTabs(lineText, TabSize)
        if replaced != lineText:
            changed = true
        addPtr_string(&lines, replaced)
    if ! changed:
        state.statusMsg = "action: no change"
        return state
    return guiQuickFixUpdateFile(state, lines, "action: convert tabs to spaces (file)")

fn guiQuickFixTrimTrailingBlankLines(state: GuiState): GuiState =
    let total: int32 = seqLenString(state.editor.lines)
    if total <= 1:
        state.statusMsg = "action: no change"
        return state
    var blanks: int32 = 0
    let idxBase = total - 1
    if idxBase >= 0:
        for idxRev in 0..idxBase:
            let idx = idxBase - idxRev
            let lineText = seqGetString(state.editor.lines, idx)
            if len(trimLine(lineText)) == 0:
                blanks = blanks + 1
                continue
            break
        let lineText = seqGetString(state.editor.lines, idx)
        if len(trimLine(lineText)) == 0:
            blanks = blanks + 1
            continue
        break
    if blanks <= 1:
        state.statusMsg = "action: no change"
        return state
    let keepCount: int32 = total - (blanks - 1)
    var lines: str[] = default[str[]]
    for i in 0..<keepCount:
        var lineText = seqGetString(state.editor.lines, i)
        if i == keepCount - 1 && len(trimLine(lineText)) == 0:
            lineText = ""
        addPtr_string(&lines, lineText)
    return guiQuickFixUpdateFile(state, lines, "action: trim trailing empty lines (file)")

fn guiQuickFixCollapseBlankLinesFile(state: GuiState): GuiState =
    var changed: bool = false
    var lines: str[] = default[str[]]
    for idx in 0..<seqLenString(state.editor.lines):
        let lineText = seqGetString(state.editor.lines, idx)
        let isBlank: bool = len(trimLine(lineText)) == 0
        if isBlank:
            if prevBlank:
                changed = true
            else:
                addPtr_string(&lines, "")
                prevBlank = true
        else:
            addPtr_string(&lines, lineText)
            prevBlank = false
    if ! changed:
        state.statusMsg = "action: no change"
        return state
    return guiQuickFixUpdateFile(state, lines, "action: collapse blank lines (file)")

fn guiQuickFixEnsureFinalNewline(state: GuiState): GuiState =
    if ! fileMissingFinalNewline(state.editor.lines):
        state.statusMsg = "action: no change"
        return state
    var lines: str[] = default[str[]]
    for idx in 0..<seqLenString(state.editor.lines):
        addPtr_string(&lines, seqGetString(state.editor.lines, idx))
    addPtr_string(&lines, "")
    return guiQuickFixUpdateFile(state, lines, "action: ensure final newline (file)")

fn guiQuickFixSortImportsFile(state: GuiState): GuiState =
    let blockRange: LineRange = findImportBlock(state.editor.lines)
    if ! blockRange.active:
        state.statusMsg = "action: no import block"
        return state
    if ! importBlockUnsorted(state.editor.lines, blockRange):
        state.statusMsg = "action: imports already sorted"
        return state
    let sortedLines: str[] = sortedImportLines(state.editor.lines, blockRange)
    var newLines: str[] = default[str[]]
    for idx in 0..<blockRange.startLine:
        addPtr_string(&newLines, seqGetString(state.editor.lines, idx))
    for idx in 0..<seqLenString(sortedLines):
        addPtr_string(&newLines, seqGetString(sortedLines, idx))
    for idx in blockRange.endLine + 1..<seqLenString(state.editor.lines):
        addPtr_string(&newLines, seqGetString(state.editor.lines, idx))
    return guiQuickFixUpdateFile(state, newLines, "action: sort imports (file)")

fn guiApplyQuickFixAtCursor(state: GuiState): GuiState =
    return guiApplyQuickFixAtCursorIndex(state, 0)

fn guiTickAutoDiagnostics(state: GuiState, eventCount: int32): GuiState =
    if ! state.diagAuto:
        return state
    if state.diagCooldown > 0:
        state.diagCooldown = state.diagCooldown - 1
    if state.diagPending && state.diagCooldown <= 0 && eventCount == 0:
        if state.taskRunner.active && state.taskRunner.job.kind == tkDiagnostics:
            return state
        state.diagPending = false
        return guiRunLanguageDiagnostics(state)
    return state

fn guiTickAutoSave(state: GuiState, eventCount: int32): GuiState =
    if ! state.autoSave:
        return state
    if state.autoSaveCooldown > 0:
        state.autoSaveCooldown = state.autoSaveCooldown - 1
    if state.autoSavePending && state.autoSaveCooldown <= 0 && eventCount == 0:
        state.autoSavePending = false
        return saveEditorAuto(state)
    return state

fn guiTickRecovery(state: GuiState, eventCount: int32): GuiState =
    if ! state.recoveryEnabled:
        return state
    if state.autoSave:
        return state
    if state.recoveryCooldown > 0:
        state.recoveryCooldown = state.recoveryCooldown - 1
    if state.recoveryPending && state.recoveryCooldown <= 0 && eventCount == 0:
        state.recoveryPending = false
        return guiRecoveryWriteAll(state)
    return state

fn drawCompletionPanel(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState) =
    if ! state.completion.active:
        return
    let count: int32 = seqLenString(state.completion.items)
    if count <= 0:
        return
    let layout: GuiLayout = state.layout
    let maxItems: int32 = minInt(6, count)
    let panelW: int32 = minInt(int32(240.0 * layout.scale), maxInt(0, layout.editorW - 8))
    if panelW <= 0:
        return
    let minX: int32 = layout.editorX + 4
    let maxX: int32 = layout.editorX + layout.editorW - panelW - 4
    var panelX: int32 = clampInt(int32(layout.codeX), minX, maxX)
    let pane: int32 = if state.editor.splitActive: state.editor.splitPane else: 0
    let paneMetrics: EditorPaneMetrics = editorPaneMetrics(layout, pane, state.editor.splitActive)
    let visibleLines: int32 = maxInt(1, int32(float64(paneMetrics.h / layout.lineHeight)))
    let startLine: int32 = normalizeVisibleLine(state.editor, scrollLineForPane(state.editor, pane))
    var cursorRow: int32 = visibleRowForLine(state.editor, startLine, state.editor.cursorLine, visibleLines)
    if cursorRow < 0:
        cursorRow = 0
    var panelY: int32 = int32(paneMetrics.codeY + float64(cursorRow + 1 * layout.lineHeight))
    let panelH: int32 = maxItems * int32(layout.lineHeight + int32(8.0 * layout.scale))
    let viewBottom: int32 = paneMetrics.y + paneMetrics.h
    if panelY + panelH > viewBottom:
        panelY = int32(paneMetrics.codeY + float64(cursorRow - maxItems * layout.lineHeight))
        if panelY < paneMetrics.y + 4:
            panelY = paneMetrics.y + 4
    fillRect(pixels, width, height, strideBytes, panelX, panelY, panelW, panelH, theme.panelAlt)
    fillRect(pixels, width, height, strideBytes, panelX, panelY, panelW, 1, theme.border)
    fillRect(pixels, width, height, strideBytes, panelX, panelY + panelH - 1, panelW, 1, theme.border)
    for idx in 0..<maxItems:
        let item = seqGetString(state.completion.items, idx)
        let lineY = float64(panelY + 6.0 * layout.scale + float64(idx * layout.lineHeight))
        if idx == state.completion.selected:
            fillRect(pixels, width, height, strideBytes, panelX + 1, int32(lineY), panelW - 2, int32(layout.lineHeight), theme.selection)
        drawTextLine(pixels, width, height, strideBytes, float64(panelX + 8), lineY, theme.text, layout.smallFont, item)

fn drawSignaturePanel(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState) =
    if ! state.signatureActive:
        return
    if state.overlay.kind != okNone:
        return
    if state.focus != fkEditor:
        return
    if state.completion.active:
        return
    if len(state.signatureText) == 0:
        return
    let layout: GuiLayout = state.layout
    let scale: float64 = layout.scale
    let pane: int32 = if state.editor.splitActive: state.editor.splitPane else: 0
    let paneMetrics: EditorPaneMetrics = editorPaneMetrics(layout, pane, state.editor.splitActive)
    let visibleLines: int32 = maxInt(1, int32(float64(paneMetrics.h / layout.lineHeight)))
    let startLine: int32 = normalizeVisibleLine(state.editor, scrollLineForPane(state.editor, pane))
    let cursorRow: int32 = visibleRowForLine(state.editor, startLine, state.editor.cursorLine, visibleLines)
    if cursorRow < 0:
        return
    let lineText = seqGetString(state.editor.lines, state.editor.cursorLine)
    let cursorX: float64 = layout.codeX + textXForCol(lineText, state.editor.cursorCol, layout)
    var charAdvance: float64 = layout.advance
    if layout.fontSize > 0.0:
        charAdvance = layout.advance * (layout.smallFont / layout.fontSize)
    if charAdvance < 1.0:
        charAdvance = 1.0
    let maxPanelW: int32 = maxInt(0, layout.editorW - 8)
    let maxChars: int32 = maxInt(4, int32((float64(maxPanelW - 16.0 * scale)) / charAdvance))
    let label = if len(state.signatureText) > maxChars: truncateMiddle(state.signatureText, maxChars) else: state.signatureText
    let textW: float64 = textWidthForFont(label, layout.smallFont, layout)
    let panelW: int32 = minInt(maxPanelW, maxInt(int32(textW + 16.0 * scale), int32(80.0 * scale)))
    let panelH: int32 = maxInt(1, int32(layout.lineHeight + int32(8.0 * scale)))
    if panelW <= 4 || panelH <= 4:
        return
    var panelX: int32 = int32(cursorX - 8.0 * scale)
    let minX: int32 = layout.editorX + 4
    let maxX: int32 = maxInt(minX, layout.editorX + layout.editorW - panelW - 4)
    panelX = clampInt(panelX, minX, maxX)
    let cursorTop: float64 = paneMetrics.codeY + float64(cursorRow * layout.lineHeight)
    var panelY: int32 = int32(cursorTop - float64(panelH - 6.0 * scale))
    let minY: int32 = paneMetrics.y + 4
    let maxY: int32 = maxInt(minY, paneMetrics.y + paneMetrics.h - panelH - 4)
    if panelY < minY:
        panelY = int32(cursorTop + layout.lineHeight + 4.0 * scale)
    panelY = clampInt(panelY, minY, maxY)
    fillRect(pixels, width, height, strideBytes, panelX, panelY, panelW, panelH, theme.panelAlt)
    fillRect(pixels, width, height, strideBytes, panelX, panelY, panelW, 1, theme.border)
    fillRect(pixels, width, height, strideBytes, panelX, panelY + panelH - 1, panelW, 1, theme.border)
    fillRect(pixels, width, height, strideBytes, panelX, panelY, 1, panelH, theme.border)
    fillRect(pixels, width, height, strideBytes, panelX + panelW - 1, panelY, 1, panelH, theme.border)
    let textX: float64 = float64(panelX + 8.0 * scale)
    let textY: float64 = float64(panelY + 6.0 * scale)
    drawTextLine(pixels, width, height, strideBytes, textX, textY, theme.text, layout.smallFont, label)

fn drawHoverPanel(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState) =
    if ! state.hoverActive:
        return
    if state.overlay.kind != okNone:
        return
    if state.focus != fkEditor:
        return
    if state.completion.active:
        return
    if len(state.hoverText) == 0:
        return
    let layout: GuiLayout = state.layout
    let scale: float64 = layout.scale
    let maxPanelW: int32 = maxInt(0, width - 8)
    var charAdvance: float64 = layout.advance
    if layout.fontSize > 0.0:
        charAdvance = layout.advance * (layout.smallFont / layout.fontSize)
    if charAdvance < 1.0:
        charAdvance = 1.0
    let maxChars: int32 = maxInt(4, int32((float64(maxPanelW - 16.0 * scale)) / charAdvance))
    let hoverText = if len(state.hoverText) > maxChars: truncateMiddle(state.hoverText, maxChars) else: state.hoverText
    let textW: float64 = textWidthForFont(hoverText, layout.smallFont, layout)
    let panelW: int32 = minInt(maxPanelW, maxInt(int32(textW + 16.0 * scale), int32(60.0 * scale)))
    let panelH: int32 = maxInt(1, int32(layout.lineHeight + int32(8.0 * scale)))
    if panelW <= 4 || panelH <= 4:
        return
    var panelX: int32 = int32(state.hoverX + 12.0 * scale)
    var panelY: int32 = int32(state.hoverY + 16.0 * scale)
    let minX: int32 = 4
    let maxX: int32 = maxInt(minX, width - panelW - 4)
    panelX = clampInt(panelX, minX, maxX)
    let minY: int32 = layout.contentY + 4
    let maxY: int32 = maxInt(minY, layout.bottomY - panelH - 4)
    if panelY > maxY:
        panelY = int32(state.hoverY - panelH - 8.0 * scale)
    panelY = clampInt(panelY, minY, maxY)
    fillRect(pixels, width, height, strideBytes, panelX, panelY, panelW, panelH, theme.panelAlt)
    fillRect(pixels, width, height, strideBytes, panelX, panelY, panelW, 1, theme.border)
    fillRect(pixels, width, height, strideBytes, panelX, panelY + panelH - 1, panelW, 1, theme.border)
    fillRect(pixels, width, height, strideBytes, panelX, panelY, 1, panelH, theme.border)
    fillRect(pixels, width, height, strideBytes, panelX + panelW - 1, panelY, 1, panelH, theme.border)
    let textX: float64 = float64(panelX + 8.0 * scale)
    let textY: float64 = float64(panelY + 6.0 * scale)
    drawTextLine(pixels, width, height, strideBytes, textX, textY, theme.text, layout.smallFont, hoverText)

fn drawTabStripButton(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, layout: GuiLayout, x, y, size: float64, glyph: str, hovered: bool, enabled: bool) =
    if len(glyph) == 0:
        return
    if size <= 0.0:
        return
    if hovered && enabled:
        fillRect(pixels, width, height, strideBytes, int32(x), int32(y), int32(size), int32(size), theme.panel)
    let glyphW: float64 = textWidthForFont(glyph, layout.smallFont, layout)
    let glyphX: float64 = x + (size - glyphW) * 0.5
    let glyphY: float64 = tabTextY(y, int32(size), layout)
    var glyphColor: uint32 = theme.subText
    if ! enabled:
        glyphColor = theme.border
    elif hovered:
        glyphColor = theme.text
    drawTextLine(pixels, width, height, strideBytes, glyphX, glyphY, glyphColor, layout.smallFont, glyph)

fn drawTabStripControls(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState) =
    let layout: GuiLayout = state.layout
    let scale: float64 = layout.scale
    let size: float64 = tabStripControlSize(layout)
    if size <= 0.0:
        return
    let gap: float64 = tabStripControlGap(layout)
    let needsScroll: bool = tabStripNeedsScrollButtons(state, width, layout)
    let tabTop: float64 = tabStripTop(layout)
    let tabH: int32 = tabStripHeight(layout)
    if tabH <= 0:
        return
    let y: float64 = tabTop + (float64(tabH - size)) * 0.5
    var x: float64 = tabStripControlsStartX(state, width, layout)
    let maxScroll: float64 = tabStripMaxScroll(state, width)
    let canLeft: bool = state.tabScrollX > 0.0
    let canRight: bool = state.tabScrollX < maxScroll
    if needsScroll:
        let leftGlyph = tabStripControlGlyph(TabControlLeft)
        let leftHover: bool = state.hoverTabControl == TabControlLeft
        drawTabStripButton(pixels, width, height, strideBytes, theme, layout, x, y, size, leftGlyph, leftHover, canLeft)
        x = x + size + gap
        let rightGlyph = tabStripControlGlyph(TabControlRight)
        let rightHover: bool = state.hoverTabControl == TabControlRight
        drawTabStripButton(pixels, width, height, strideBytes, theme, layout, x, y, size, rightGlyph, rightHover, canRight)
        x = x + size + gap
        let newGlyph = tabStripControlGlyph(TabControlNew)
        let newHover: bool = state.hoverTabControl == TabControlNew
        drawTabStripButton(pixels, width, height, strideBytes, theme, layout, x, y, size, newGlyph, newHover, true)
    else:
        let newGlyph = tabStripControlGlyph(TabControlNew)
        let newHover: bool = state.hoverTabControl == TabControlNew
        drawTabStripButton(pixels, width, height, strideBytes, theme, layout, x, y, size, newGlyph, newHover, true)

fn drawTabs(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState) =
    let count: int32 = bufferLen(state.buffers)
    if count <= 0:
        drawTabStripControls(pixels, width, height, strideBytes, theme, state)
        return
    let layout: GuiLayout = state.layout
    let scale: float64 = layout.scale
    let tabTop: float64 = tabStripTop(layout)
    let tabH: int32 = tabStripHeight(layout)
    if tabH <= 0:
        return
    var x: float64 = tabStripStartX(layout) - state.tabScrollX
    let tabsEndX: float64 = tabStripTabsEndX(state, width, layout)
    let y: float64 = tabTop
    let textY: float64 = tabTextY(y, tabH, layout)
    let gap: float64 = tabStripGap(layout)
    for idx in 0..<count:
        let buffer: EditorState = bufferGet(state.buffers, idx)
        let label = tabLabel(state, buffer)
        let iconGlyph = tabIconGlyph(buffer)
        let iconColor = tabIconColor(theme, buffer)
        let reserveGlyph = tabReserveGlyph()
        let tabW: int32 = int32(tabWidthForBuffer(layout, label, iconGlyph, reserveGlyph))
        let iconReserve: float64 = tabIconReserve(layout, iconGlyph)
        let reserveW: float64 = if len(reserveGlyph) > 0: textWidthForFont(reserveGlyph, layout.smallFont, layout) else: 0.0
        let isActive: bool = idx == state.activeBuffer
        let isHover: bool = idx == state.hoverTab
        let showClose: bool = tabShowClose(isActive, isHover)
        let displayGlyph = tabDisplayGlyph(buffer, isActive, isHover)
        let displayW: float64 = if len(displayGlyph) > 0: textWidthForFont(displayGlyph, layout.smallFont, layout) else: 0.0
        if x + float64(tabW) > tabsEndX:
            break
        var tabColor: uint32 = theme.tabInactive
        if isActive:
            tabColor = theme.tabActive
        elif isHover:
            tabColor = theme.panel
        fillRect(pixels, width, height, strideBytes, int32(x), int32(y), tabW, tabH, tabColor)
        if isActive:
            fillRect(pixels, width, height, strideBytes, int32(x), int32(y), tabW, maxInt(1, int32(1.0 * scale)), theme.accent)
        if ! isActive:
            fillRect(pixels, width, height, strideBytes, int32(x), int32(y + float64(tabH - 1)), tabW, 1, theme.border)
        var textX: float64 = x + tabPaddingLeft(layout)
        if len(iconGlyph) > 0:
            let iconW: float64 = textWidthForFont(iconGlyph, layout.smallFont, layout)
            drawTextLine(pixels, width, height, strideBytes, textX, textY, iconColor, layout.smallFont, iconGlyph)
            textX = textX + iconW + tabIconGap(layout)
        var labelMaxW: float64 = float64(tabW - tabPaddingLeft(layout) - tabPaddingRight(layout) - reserveW - tabCloseGap(layout, reserveW) - iconReserve)
        if labelMaxW < 0.0:
            labelMaxW = 0.0
        var labelText = truncateFileLabelToWidth(label, labelMaxW, layout.smallFont)
        labelText = ensureChengSuffix(labelText, buffer.filePath)
        let labelColor: uint32 = if isActive || isHover: theme.text else: theme.subText
        drawTextLine(pixels, width, height, strideBytes, textX, textY, labelColor, layout.smallFont, labelText)
        if len(displayGlyph) > 0:
            var closeX: float64 = x + float64(tabW - tabPaddingRight(layout) - reserveW)
            if displayW < reserveW:
                closeX = closeX + (reserveW - displayW) * 0.5
            var glyphColor: uint32 = tabCloseColor(theme, isActive, buffer.dirty)
            if showClose && isHover && ! isActive:
                glyphColor = theme.text
            if ! showClose && buffer.dirty:
                glyphColor = theme.accent
            drawTextLine(pixels, width, height, strideBytes, closeX, textY, glyphColor, layout.smallFont, displayGlyph)
        x = x + float64(tabW + gap)
    drawTabStripControls(pixels, width, height, strideBytes, theme, state)

fn drawTerminalTabs(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState) =
    let count: int32 = terminalSessionLen(state.terminalSessions)
    if count <= 1:
        return
    let layout: GuiLayout = state.layout
    let scale: float64 = layout.scale
    let title: str = terminalHeaderTitle(state)
    let titleW: float64 = textWidthForFont(title, layout.headerFont, layout)
    var x: float64 = float64(layout.editorX + panelPaddingX(layout) + titleW + 12.0 * scale)
    let y: float64 = panelHeaderTextY(layout, bottomPaneContentTop(layout))
    let maxX: float64 = float64(layout.editorX + layout.editorW - panelPaddingX(layout))
    for idx in 0..<count:
        if ! (x < maxX):
            break
        let session: TerminalState = terminalSessionGet(state.terminalSessions, idx)
        let labelBase = terminalTabLabel(session, idx)
        let label = if idx == state.terminalSessionActive: "[" + labelBase + "]" else: labelBase
        let textW: float64 = textWidthForFont(label, layout.smallFont, layout)
        if x + textW > maxX:
            break
        var color: uint32 = theme.subText
        if idx == state.terminalSessionActive:
            color = theme.accent
            # VS Code terminal tabs often have an underline or top border if they are panel tabs
            # drawing a small underline for better visibility
            let underlineH: int32 = maxInt(1, int32(1.0 * scale))
            fillRect(pixels, width, height, strideBytes, int32(x), int32(y + layout.smallFont + 4.0 * scale), int32(textW), underlineH, theme.accent)
            
        drawTextLine(pixels, width, height, strideBytes, x, y, color, layout.smallFont, label)
        x = x + textW + 12.0 * scale

type
    EventLayout = enum
        elMac
        elWin
        elX11

fn detectEventLayout(evStride: int32): EventLayout =
    if evStride >= 300:
        return elMac
    if evStride >= 160:
        return elX11
    return elWin

fn eventTextLen(layout: EventLayout): int32 =
    if layout == elMac:
        return 256
    return 64

fn eventTextOffset(layout: EventLayout): int32 =
    if layout == elMac:
        return 77
    if layout == elX11:
        return 100
    return 77

fn eventModifiersOffset(layout: EventLayout): int32 =
    if layout == elMac:
        return 68
    if layout == elX11:
        return 88
    return 64

fn eventKeyCodeOffset(layout: EventLayout): int32 =
    if layout == elX11:
        return 96
    return 72

fn eventXOffset(layout: EventLayout): int32 =
    if layout == elMac:
        return 8
    return 16

fn eventYOffset(layout: EventLayout): int32 =
    if layout == elMac:
        return 16
    return 24

fn eventDeltaYOffset(layout: EventLayout): int32 =
    if layout == elMac:
        return 48
    return 56

fn eventButtonOffset(layout: EventLayout): int32 =
    if layout == elMac:
        return 64
    if layout == elX11:
        return 92
    return 68

fn loadI32(p: void*, offset: int32): int32 =
    let ptrVal: int32* = int32*(ptr_add(p, offset))
    return *ptrVal

fn loadU32(p: void*, offset: int32): uint32 =
    let ptrVal: uint32* = uint32*(ptr_add(p, offset))
    return *ptrVal

fn loadF64(p: void*, offset: int32): float64 =
    let ptrVal: float64* = float64*(ptr_add(p, offset))
    return *ptrVal

fn loadText(p: void*, offset: int32): str =
    let ptrVal: void* = ptr_add(p, offset)
    return str(ptrVal)

fn scalePointer(rawX, rawY: float64, inputScale: float64, width, height: int32, outPx, outPy: var float64) =
    var px = rawX * inputScale
    var py = rawY * inputScale
    if inputScale > 0.0:
        let maxX: float64 = float64(width + 8.0)
        let maxY: float64 = float64(height + 8.0)
        if px < -8.0 || px > maxX || py < -8.0 || py > maxY:
            px = rawX
            py = rawY
    outPx = px
    outPy = py

fn modHas(mods: uint32, mask: uint32): bool =
    return (mods + mask) != 0

fn modsLookLikeMac(mods: uint32): bool =
    return modHas(mods, ModShiftMac) || modHas(mods, ModCtrlMac) || modHas(mods, ModAltMac) || modHas(mods, ModMetaMac)

fn hasShift(layout: EventLayout, mods: uint32): bool =
    if layout == elMac || modsLookLikeMac(mods):
        return modHas(mods, ModShiftMac)
    if layout == elX11:
        return modHas(mods, ModShiftX11)
    return modHas(mods, ModShiftWin)

fn hasCtrl(layout: EventLayout, mods: uint32): bool =
    if layout == elMac || modsLookLikeMac(mods):
        return modHas(mods, ModCtrlMac)
    if layout == elX11:
        return modHas(mods, ModCtrlX11)
    return modHas(mods, ModCtrlWin)

fn hasAlt(layout: EventLayout, mods: uint32): bool =
    if layout == elMac || modsLookLikeMac(mods):
        return modHas(mods, ModAltMac)
    if layout == elX11:
        return modHas(mods, ModAltX11)
    return modHas(mods, ModAltWin)

fn hasMeta(layout: EventLayout, mods: uint32): bool =
    if layout == elMac || modsLookLikeMac(mods):
        return modHas(mods, ModMetaMac)
    if layout == elX11:
        return modHas(mods, ModMetaX11)
    return modHas(mods, ModMetaWin)

fn hasPrimaryModifier(layout: EventLayout, mods: uint32): bool =
    if layout == elMac || modsLookLikeMac(mods):
        return modHas(mods, ModMetaMac)
    return hasCtrl(layout, mods)

fn wordMoveModifier(layout: EventLayout, mods: uint32): bool =
    if layout == elMac || modsLookLikeMac(mods):
        return hasAlt(layout, mods) && ! hasPrimaryModifier(layout, mods) && ! hasCtrl(layout, mods)
    return hasCtrl(layout, mods) && ! hasAlt(layout, mods)

fn gotoClickModifier(layout: EventLayout, mods: uint32): bool =
    if layout == elMac || modsLookLikeMac(mods):
        let cmdHeld: bool = hasPrimaryModifier(layout, mods)
        let ctrlHeld: bool = hasCtrl(layout, mods)
        return (cmdHeld || ctrlHeld) && ! hasAlt(layout, mods) && ! hasShift(layout, mods)
    return hasCtrl(layout, mods) && ! hasAlt(layout, mods) && ! hasShift(layout, mods)

fn shiftSymbolForKey(ch: char): char =
    if ch == '1': return '!'
    if ch == '2': return '@'
    if ch == '3': return '#'
    if ch == '4': return '$'
    if ch == '5': return '%'
    if ch == '6': return '^'
    if ch == '7': return '&'
    if ch == '8': return '*'
    if ch == '9': return '('
    if ch == '0': return ')'
    if ch == '-': return '_'
    if ch == '=': return '+'
    if ch == '[': return '{'
    if ch == ']': return '}'
    if ch == '\\': return '|'
    if ch == ';': return ':'
    if ch == '\'': return '"'
    if ch == ',': return '<'
    if ch == '.': return '>'
    if ch == '/': return '?'
    if ch == '`': return '~'
    return '\0'

fn macKeyCodeBaseChar(keyCode: uint32): char =
    if keyCode == 18: return '1'
    if keyCode == 19: return '2'
    if keyCode == 20: return '3'
    if keyCode == 21: return '4'
    if keyCode == 23: return '5'
    if keyCode == 22: return '6'
    if keyCode == 26: return '7'
    if keyCode == 28: return '8'
    if keyCode == 25: return '9'
    if keyCode == 29: return '0'
    if keyCode == 27: return '-'
    if keyCode == 24: return '='
    if keyCode == 33: return '['
    if keyCode == 30: return ']'
    if keyCode == 42: return '\\'
    if keyCode == 41: return ';'
    if keyCode == 39: return '\''
    if keyCode == 43: return ','
    if keyCode == 47: return '.'
    if keyCode == 44: return '/'
    if keyCode == 50: return '`'
    return '\0'

fn keyCodeBaseChar(layout: EventLayout, keyCode: uint32): char =
    if layout == elMac:
        return macKeyCodeBaseChar(keyCode)
    if layout == elWin:
        if keyCode >= 48 && keyCode <= 57:
            return chr(ord('0') + int32(keyCode - 48))
        if keyCode == 189: return '-'
        if keyCode == 187: return '='
        if keyCode == 219: return '['
        if keyCode == 221: return ']'
        if keyCode == 220: return '\\'
        if keyCode == 186: return ';'
        if keyCode == 222: return '\''
        if keyCode == 188: return ','
        if keyCode == 190: return '.'
        if keyCode == 191: return '/'
        if keyCode == 192: return '`'
        return '\0'
    if layout == elX11:
        if keyCode >= 48 && keyCode <= 57:
            return chr(ord('0') + int32(keyCode - 48))
        if keyCode == 45: return '-'
        if keyCode == 61: return '='
        if keyCode == 91: return '['
        if keyCode == 93: return ']'
        if keyCode == 92: return '\\'
        if keyCode == 59: return ';'
        if keyCode == 39: return '\''
        if keyCode == 44: return ','
        if keyCode == 46: return '.'
        if keyCode == 47: return '/'
        if keyCode == 96: return '`'
        return '\0'
    return '\0'

fn keyCodeBaseCharForMods(layout: EventLayout, mods: uint32, keyCode: uint32): char =
    if layout == elMac || modsLookLikeMac(mods):
        return macKeyCodeBaseChar(keyCode)
    return keyCodeBaseChar(layout, keyCode)

fn normalizeFullWidthAscii(text: str): str =
    if len(text) == 0:
        return text
    var outVal: str = ""
    var idx: int32 = 0
    while idx < len(text):
        let b0: int32 = byteValue(text[idx])
        if b0 < 128:
            outVal = outVal + charToStr(text[idx])
            idx = idx + 1
            continue
        if b0 == 0xEF && idx + 2 < len(text):
            let b1: int32 = byteValue(text[idx + 1])
            let b2: int32 = byteValue(text[idx + 2])
            if (b1 == 0xBC || b1 == 0xBD) && b2 >= 0x80 && b2 <= 0xBF:
                let cp: int32 = 0xFF00 + (b1 - 0xBC) * 64 + (b2 - 0x80)
                if cp >= 0xFF01 && cp <= 0xFF5E:
                    let ascii: int32 = cp - 0xFEE0
                    outVal = outVal + charToStr(chr(ascii))
                    idx = idx + 3
                    continue
        if b0 == 0xE3 && idx + 2 < len(text):
            let b1: int32 = byteValue(text[idx + 1])
            let b2: int32 = byteValue(text[idx + 2])
            if b1 == 0x80 && b2 == 0x80:
                outVal = outVal + " "
                idx = idx + 3
                continue
        var step: int32 = utf8SeqLen(text[idx])
        if step <= 0:
            step = 1
        if idx + step > len(text):
            step = len(text) - idx
        outVal = outVal + sliceRange(text, idx, idx + step - 1)
        idx = idx + step
    return outVal

fn isAsciiWordChar(ch: char): bool =
    if ch >= 'a' && ch <= 'z':
        return true
    if ch >= 'A' && ch <= 'Z':
        return true
    if ch >= '0' && ch <= '9':
        return true
    return ch == '_'

fn debugEscapeText(text: str, maxLen: int32): str =
    var outVal: str = ""
    let limit: int32 = if maxLen > 0: maxLen else: 0
    for idx in 0..<len(text):
        if idx >= limit:
            break
        let ch: char = text[idx]
        if ch == '\n':
            outVal = outVal + "\\n"
        elif ch == '\r':
            outVal = outVal + "\\r"
        elif ch == '\t':
            outVal = outVal + "\\t"
        else:
            outVal = outVal + charToStr(ch)
    if len(text) > limit:
        outVal = outVal + "..."
    return outVal

fn applyShiftTextInput(text: str, layout: EventLayout, mods: uint32): str =
    if len(text) != 1:
        return text
    if ! hasShift(layout, mods):
        return text
    if hasPrimaryModifier(layout, mods) || hasCtrl(layout, mods) || hasAlt(layout, mods):
        return text
    let ch: char = text[0]
    if ch >= 'a' && ch <= 'z':
        return charToStr(chr(ord(ch) - 32))
    let mapped: char = shiftSymbolForKey(ch)
    if mapped != '\0':
        return charToStr(mapped)
    return text

fn maxCharsForWidth(maxWidth: float64, fontSize: float64): int32 =
    if maxWidth <= 0.0 || fontSize <= 0.0:
        return 0
    let advance: float64 = fontSize * 0.6
    if advance <= 0.0:
        return 0
    let count: int32 = int32(maxWidth / advance)
    if count < 0:
        return 0
    return count

fn truncateTextToWidth(text: str, maxWidth: float64, fontSize: float64): str =
    if len(text) == 0:
        return text
    if maxWidth <= 0.0 || fontSize <= 0.0:
        return ""
    if nativeTextMetricsAvailable():
        let width: float64 = chengGuiTextWidth(text, fontSize)
        if width > 0.0 && width <= maxWidth:
            return text
    let maxChars: int32 = maxCharsForWidth(maxWidth, fontSize)
    if maxChars <= 0:
        return ""
    if len(text) <= maxChars:
        return text
    if nativeTextMetricsAvailable():
        var lo: int32 = 0
        var hi: int32 = len(text)
        while lo < hi:
            let mid: int32 = (lo + hi + 1) / 2
            let part = sliceRange(text, 0, mid - 1)
            let w: float64 = chengGuiTextWidth(part, fontSize)
            if w <= 0.0 || w <= maxWidth:
                lo = mid
            else:
                hi = mid - 1
        if lo <= 0:
            return ""
        return sliceRange(text, 0, lo - 1)
    return sliceRange(text, 0, maxChars - 1)

fn truncateFileLabelToWidth(text: str, maxWidth: float64, fontSize: float64): str =
    if len(text) == 0:
        return text
    var baseText = text
    var loweredText = textutils.toLowerAscii(baseText)
    if endsWithSuffix(loweredText, ".che") && ! endsWithSuffix(loweredText, ".cheng"):
        baseText = baseText + "ng"
        loweredText = textutils.toLowerAscii(baseText)
    if maxWidth <= 0.0 || fontSize <= 0.0:
        return ""
    if nativeTextMetricsAvailable():
        let width: float64 = chengGuiTextWidth(baseText, fontSize)
        if width > 0.0 && width <= maxWidth:
            return baseText
    let maxChars: int32 = maxCharsForWidth(maxWidth, fontSize)
    if maxChars <= 0:
        return ""
    if len(baseText) <= maxChars:
        return baseText
    let dotIdx: int32 = lastIndexOfCharBefore(baseText, '.', len(baseText) - 1)
    if dotIdx > 0 && dotIdx < len(baseText) - 1:
        var suffix = sliceFrom(baseText, dotIdx)
        if endsWithSuffix(loweredText, ".cheng"):
            suffix = ".cheng"
        let suffixLen: int32 = len(suffix)
        let ellipsis = "..."
        if nativeTextMetricsAvailable():
            let suffixW: float64 = chengGuiTextWidth(suffix, fontSize)
            let ellipsisW: float64 = chengGuiTextWidth(ellipsis, fontSize)
            let maxPrefixW: float64 = maxWidth - suffixW - ellipsisW
            if maxPrefixW > 0.0:
                var lo: int32 = 0
                var hi: int32 = dotIdx
                while lo < hi:
                    let mid: int32 = (lo + hi + 1) / 2
                    let part = sliceRange(baseText, 0, mid - 1)
                    let w: float64 = chengGuiTextWidth(part, fontSize)
                    if w <= 0.0 || w <= maxPrefixW:
                        lo = mid
                    else:
                        hi = mid - 1
                if lo > 0:
                    return sliceRange(baseText, 0, lo - 1) + ellipsis + suffix
        let ellipsisLen: int32 = len(ellipsis)
        if suffixLen + ellipsisLen >= maxChars:
            if suffixLen <= maxChars:
                return suffix
            return sliceRange(suffix, suffixLen - maxChars, suffixLen - 1)
        let prefixLen: int32 = maxChars - suffixLen - ellipsisLen
        if prefixLen > 0:
            let prefix = sliceRange(baseText, 0, prefixLen - 1)
            return prefix + ellipsis + suffix
    let truncated = truncateTextToWidth(baseText, maxWidth, fontSize)
    if endsWithSuffix(loweredText, ".cheng"):
        let truncatedLower = textutils.toLowerAscii(truncated)
        if endsWithSuffix(truncatedLower, ".che") && ! endsWithSuffix(truncatedLower, ".cheng"):
            return truncated + "ng"
    return truncated

fn ensureChengSuffix(label: str, path: str): str =
    if len(label) == 0 || len(path) == 0:
        return label
    let pathLower = textutils.toLowerAscii(path)
    if ! endsWithSuffix(pathLower, ".cheng"):
        return label
    let labelLower = textutils.toLowerAscii(label)
    if endsWithSuffix(labelLower, ".cheng"):
        return label
    if endsWithSuffix(labelLower, ".che"):
        return label + "ng"
    if endsWithSuffix(labelLower, ".ch"):
        return label + "eng"
    return label

fn keyIsBackspace(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 51
    if layout == elWin:
        return keyCode == 8
    return keyCode == 65288

fn keyIsDelete(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 117
    if layout == elWin:
        return keyCode == 46
    return keyCode == 65535

fn keyIsEnter(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 36
    if layout == elWin:
        return keyCode == 13
    return keyCode == 65293

fn keyIsEscape(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 53
    if layout == elWin:
        return keyCode == 27
    return keyCode == 65307

fn keyIsSave(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 1
    if layout == elWin:
        return keyCode == 83
    return keyCode == 115 || keyCode == 83

fn keyIsOpen(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 31
    if layout == elWin:
        return keyCode == 79
    return keyCode == 111 || keyCode == 79

fn keyIsNewFile(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 45
    if layout == elWin:
        return keyCode == 78
    return keyCode == 110 || keyCode == 78

fn keyIsFind(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 3
    if layout == elWin:
        return keyCode == 70
    return keyCode == 102 || keyCode == 70

fn keyIsReplace(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 4
    if layout == elWin:
        return keyCode == 72
    return keyCode == 104 || keyCode == 72

fn keyIsCloseTab(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 13
    if layout == elWin:
        return keyCode == 87
    return keyCode == 119 || keyCode == 87

fn keyIsGotoLine(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 5
    if layout == elWin:
        return keyCode == 71
    return keyCode == 103 || keyCode == 71

fn keyIsF12(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 111
    if layout == elWin:
        return keyCode == 123
    return keyCode == 65481

fn keyIsComplete(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 49
    if layout == elWin:
        return keyCode == 32
    return keyCode == 32

fn keyIsQuickOpen(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 35
    if layout == elWin:
        return keyCode == 80
    return keyCode == 112 || keyCode == 80

fn keyIsWorkspaceSymbol(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 17
    if layout == elWin:
        return keyCode == 84
    return keyCode == 116 || keyCode == 84

fn keyIsToggleTerminal(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 50
    if layout == elWin:
        return keyCode == 192
    return keyCode == 96 || keyCode == 126

fn keyIsToggleExplorer(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 11
    if layout == elWin:
        return keyCode == 66
    return keyCode == 98 || keyCode == 66

fn keyIsToggleSecondarySidebar(layout: EventLayout, keyCode: uint32): bool =
    return keyIsToggleExplorer(layout, keyCode)

fn keyIsTogglePanel(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 38
    if layout == elWin:
        return keyCode == 74
    return keyCode == 106 || keyCode == 74

fn keyIsToggleSplit(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 42
    if layout == elWin:
        return keyCode == 220
    return keyCode == 92 || keyCode == 124

fn keyIsToggleComment(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 44
    if layout == elWin:
        return keyCode == 191
    return keyCode == 47

fn keyIsSelectLine(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 37
    if layout == elWin:
        return keyCode == 76
    return keyCode == 108 || keyCode == 76

fn keyIsDuplicateLine(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 2
    if layout == elWin:
        return keyCode == 68
    return keyCode == 100 || keyCode == 68

fn keyIsDeleteLine(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 40
    if layout == elWin:
        return keyCode == 75
    return keyCode == 107 || keyCode == 75

fn keyIsSelectAll(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 0
    if layout == elWin:
        return keyCode == 65
    return keyCode == 97 || keyCode == 65

fn keyIsCopy(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 8
    if layout == elWin:
        return keyCode == 67
    return keyCode == 99 || keyCode == 67

fn keyIsCut(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 7
    if layout == elWin:
        return keyCode == 88
    return keyCode == 120 || keyCode == 88

fn keyIsPaste(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 9
    if layout == elWin:
        return keyCode == 86
    return keyCode == 118 || keyCode == 86

fn keyIsUndo(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 6
    if layout == elWin:
        return keyCode == 90
    return keyCode == 122 || keyCode == 90

fn keyIsRedo(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 16
    if layout == elWin:
        return keyCode == 89
    return keyCode == 121 || keyCode == 89

fn keyIsArrowUp(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 126
    if layout == elWin:
        return keyCode == 38
    return keyCode == 65362

fn keyIsArrowDown(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 125
    if layout == elWin:
        return keyCode == 40
    return keyCode == 65364

fn keyIsArrowLeft(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 123
    if layout == elWin:
        return keyCode == 37
    return keyCode == 65361

fn keyIsArrowRight(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 124
    if layout == elWin:
        return keyCode == 39
    return keyCode == 65363

fn keyIsPageUp(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 116
    if layout == elWin:
        return keyCode == 33
    return keyCode == 65365

fn keyIsPageDown(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 121
    if layout == elWin:
        return keyCode == 34
    return keyCode == 65366

fn keyIsHome(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 115
    if layout == elWin:
        return keyCode == 36
    return keyCode == 65360

fn keyIsEnd(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 119
    if layout == elWin:
        return keyCode == 35
    return keyCode == 65367

fn keyIsTab(layout: EventLayout, keyCode: uint32): bool =
    if layout == elMac:
        return keyCode == 48
    if layout == elWin:
        return keyCode == 9
    return keyCode == 65289

fn keyIsEditKey(layout: EventLayout, keyCode: uint32): bool =
    return keyIsBackspace(layout, keyCode) || keyIsDelete(layout, keyCode) || keyIsEnter(layout, keyCode) || keyIsTab(layout, keyCode)

fn guiBaseNameFromPath(path: str): str =
    if len(path) == 0:
        return ""
    let norm = textutils.toForwardSlashes(path)
    let lastSlash: int32 = lastIndexOfCharBefore(norm, '/', len(norm) - 1)
    if lastSlash < 0:
        return norm
    if lastSlash + 1 >= len(norm):
        return ""
    return sliceFrom(norm, lastSlash + 1)

fn tabLabel(state: GuiState, buffer: EditorState): str =
    var name = if len(buffer.filePath) > 0: guiBaseNameFromPath(buffer.filePath) else: "<untitled>"
    if len(name) == 0:
        return "<untitled>"
    if len(buffer.filePath) > 0 && endsWithSuffix(textutils.toLowerAscii(buffer.filePath), ".cheng"):
        let lowered = textutils.toLowerAscii(name)
        if endsWithSuffix(lowered, ".che") && ! endsWithSuffix(lowered, ".cheng"):
            name = name + "ng"
    return name

fn tabFileIconEntry(buffer: EditorState): FileIconEntry =
    let name = if len(buffer.filePath) > 0: guiBaseNameFromPath(buffer.filePath) else: "<untitled>"
    return fileIconEntryForName(name)

fn tabIconGlyph(buffer: EditorState): str =
    let entry: FileIconEntry = tabFileIconEntry(buffer)
    if len(entry.glyph) > 0:
        return entry.glyph
    return ""

fn tabIconColor(theme: GuiTheme, buffer: EditorState): uint32 =
    let entry: FileIconEntry = tabFileIconEntry(buffer)
    if len(entry.glyph) == 0:
        return theme.subText
    if entry.hasColor:
        return entry.color
    return theme.subText

fn tabIconGap(layout: GuiLayout): float64 =
    return 6.0 * layout.scale

fn tabIconReserve(layout: GuiLayout, glyph: str): float64 =
    if len(glyph) == 0:
        return 0.0
    let iconW: float64 = textWidthForFont(glyph, layout.smallFont, layout)
    return iconW + tabIconGap(layout)

fn tabReserveGlyph(): str =
    if useCodicons():
        let glyph = codiconGlyph(CodiconClose)
        if len(glyph) > 0:
            return glyph
    return "x"

fn tabDirtyGlyph(): str =
    if useCodicons():
        let glyph = codiconGlyph(CodiconCloseDirty)
        if len(glyph) > 0:
            return glyph
    return "*"

fn tabShowClose(active: bool, hovered: bool): bool =
    return active || hovered

fn tabDisplayGlyph(buffer: EditorState, active: bool, hovered: bool): str =
    if tabShowClose(active, hovered):
        if useCodicons():
            let glyph = codiconGlyph(CodiconClose)
            if len(glyph) > 0:
                return glyph
        return "x"
    if buffer.dirty:
        return tabDirtyGlyph()
    return ""

fn tabCloseColor(theme: GuiTheme, active: bool, dirty: bool): uint32 =
    if dirty:
        return theme.accent
    if active:
        return theme.text
    return theme.subText

fn tabPaddingLeft(layout: GuiLayout): float64 =
    return 12.0 * layout.scale

fn tabPaddingRight(layout: GuiLayout): float64 =
    return 10.0 * layout.scale

fn tabStripControlGlyph(kind: int32): str =
    if kind == TabControlLeft:
        if useCodicons():
            let glyph = codiconGlyph(CodiconChevronLeft)
            if len(glyph) > 0:
                return glyph
        return "<"
    if kind == TabControlRight:
        if useCodicons():
            let glyph = codiconGlyph(CodiconChevronRight)
            if len(glyph) > 0:
                return glyph
        return ">"
    if kind == TabControlNew:
        if useCodicons():
            let glyph = codiconGlyph(CodiconAdd)
            if len(glyph) > 0:
                return glyph
        return "+"
    return ""

fn tabStripControlSize(layout: GuiLayout): float64 =
    let tabH: int32 = tabStripHeight(layout)
    let inner: int32 = maxInt(1, tabH - int32(6.0 * layout.scale))
    return float64(inner)

fn tabStripControlGap(layout: GuiLayout): float64 =
    return 4.0 * layout.scale

fn tabStripBaseAvailableWidth(width: int32, layout: GuiLayout): float64 =
    let avail: float64 = tabStripEndX(width, layout) - tabStripStartX(layout)
    if avail <= 0.0:
        return 0.0
    return avail

fn tabStripNeedsScrollButtons(state: GuiState, width: int32, layout: GuiLayout): bool =
    let baseAvail: float64 = tabStripBaseAvailableWidth(width, layout)
    if baseAvail <= 0.0:
        return false
    let plusReserve: float64 = tabStripControlSize(layout) + tabStripControlGap(layout)
    let avail: float64 = baseAvail - plusReserve
    if avail <= 0.0:
        return true
    let total: float64 = tabStripTotalWidth(state, layout)
    return total > avail

fn tabStripControlCount(state: GuiState, width: int32, layout: GuiLayout): int32 =
    if tabStripNeedsScrollButtons(state, width, layout):
        return 3
    return 1

fn tabStripControlsWidth(state: GuiState, width: int32, layout: GuiLayout): float64 =
    let count: int32 = tabStripControlCount(state, width, layout)
    if count <= 0:
        return 0.0
    let size: float64 = tabStripControlSize(layout)
    let gap: float64 = tabStripControlGap(layout)
    let total: float64 = float64(count * size + float64(count - 1 * gap))
    return total

fn tabStripControlsStartX(state: GuiState, width: int32, layout: GuiLayout): float64 =
    let endX: float64 = tabStripEndX(width, layout)
    let controlsW: float64 = tabStripControlsWidth(state, width, layout)
    if controlsW <= 0.0:
        return endX
    return endX - controlsW

fn tabStripTabsEndX(state: GuiState, width: int32, layout: GuiLayout): float64 =
    let endX: float64 = tabStripEndX(width, layout)
    let controlsW: float64 = tabStripControlsWidth(state, width, layout)
    if controlsW <= 0.0:
        return endX
    let tabsEnd: float64 = endX - controlsW
    let minX: float64 = tabStripStartX(layout)
    if tabsEnd < minX:
        return minX
    return tabsEnd

fn tabStripAvailableWidth(state: GuiState, width: int32): float64 =
    let avail: float64 = tabStripTabsEndX(state, width, state.layout) - tabStripStartX(state.layout)
    if avail <= 0.0:
        return 0.0
    return avail

fn tabStripStartX(layout: GuiLayout): float64 =
    return float64(layout.leftW)

fn tabStripEndX(width: int32, layout: GuiLayout): float64 =
    return float64(width - 8.0 * layout.scale)

fn tabStripWidth(layout: GuiLayout): int32 =
    return layout.leftW + layout.editorW + layout.rightW

fn tabStripTotalWidth(state: GuiState, layout: GuiLayout): float64 =
    let count: int32 = bufferLen(state.buffers)
    if count <= 0:
        return 0.0
    let reserveGlyph = tabReserveGlyph()
    let gap: float64 = tabStripGap(layout)
    var total: float64 = 0.0
    for idx in 0..<count:
        let buffer: EditorState = bufferGet(state.buffers, idx)
        let label = tabLabel(state, buffer)
        let iconGlyph = tabIconGlyph(buffer)
        total = total + tabWidthForBuffer(layout, label, iconGlyph, reserveGlyph)
        if idx < count - 1:
            total = total + gap
    return total

fn tabStripMaxScroll(state: GuiState, width: int32): float64 =
    let avail: float64 = tabStripAvailableWidth(state, width)
    let total: float64 = tabStripTotalWidth(state, state.layout)
    if total <= avail:
        return 0.0
    return total - avail

fn tabStripClamp(state: GuiState, width: int32): GuiState =
    var next: GuiState = state
    let maxScroll: float64 = tabStripMaxScroll(next, width)
    if maxScroll <= 0.0:
        next.tabScrollX = 0.0
        return next
    if next.tabScrollX < 0.0:
        next.tabScrollX = 0.0
    elif next.tabScrollX > maxScroll:
        next.tabScrollX = maxScroll
    return next

fn tabStripScroll(state: GuiState, width: int32, delta: float64): GuiState =
    var next: GuiState = state
    let maxScroll: float64 = tabStripMaxScroll(next, width)
    if maxScroll <= 0.0:
        next.tabScrollX = 0.0
        return next
    next.tabScrollX = next.tabScrollX + delta
    if next.tabScrollX < 0.0:
        next.tabScrollX = 0.0
    elif next.tabScrollX > maxScroll:
        next.tabScrollX = maxScroll
    return next

fn tabStripEnsureActiveVisible(state: GuiState): GuiState =
    var next: GuiState = state
    let count: int32 = bufferLen(next.buffers)
    if count <= 0:
        return next
    let width: int32 = tabStripWidth(next.layout)
    if width <= 0:
        return next
    let avail: float64 = tabStripAvailableWidth(next, width)
    if avail <= 0.0:
        return next
    let reserveGlyph = tabReserveGlyph()
    let gap: float64 = tabStripGap(next.layout)
    let baseX: float64 = tabStripStartX(next.layout)
    var x: float64 = baseX
    for idx in 0..<count:
        let buffer: EditorState = bufferGet(next.buffers, idx)
        let label = tabLabel(next, buffer)
        let iconGlyph = tabIconGlyph(buffer)
        let tabW: float64 = tabWidthForBuffer(next.layout, label, iconGlyph, reserveGlyph)
        if idx == activeIdx:
            let tabLeft: float64 = x
            let tabRight: float64 = x + tabW
            var scroll: float64 = next.tabScrollX
            let viewLeft: float64 = baseX + scroll
            let viewRight: float64 = viewLeft + avail
            if tabLeft < viewLeft:
                scroll = tabLeft - baseX
            elif tabRight > viewRight:
                scroll = tabRight - avail - baseX
            next.tabScrollX = scroll
            return tabStripClamp(next, width)
        x = x + tabW + gap
    return next

fn tabCloseGap(layout: GuiLayout, closeW: float64): float64 =
    if closeW > 0.0:
        return 10.0 * layout.scale
    return 0.0

fn tabMinWidth(layout: GuiLayout): float64 =
    return 60.0 * layout.scale

fn tabTextY(tabTop: float64, tabH: int32, layout: GuiLayout): float64 =
    let textBox: float64 = layout.smallFont * 1.2
    let offset: float64 = (float64(tabH - textBox)) * 0.5
    return tabTop + offset

fn tabWidthForBuffer(layout: GuiLayout, label: str, iconGlyph: str, closeGlyph: str): float64 =
    let textW: float64 = textWidthForFont(label, layout.smallFont, layout)
    let iconW: float64 = tabIconReserve(layout, iconGlyph)
    let closeW: float64 = if len(closeGlyph) > 0: textWidthForFont(closeGlyph, layout.smallFont, layout) else: 0.0
    let rawW: float64 = tabPaddingLeft(layout) + iconW + textW + tabCloseGap(layout, closeW) + closeW + tabPaddingRight(layout)
    var extra: float64 = 2.0 * layout.scale
    if extra < 1.0:
        extra = 1.0
    let paddedW: float64 = rawW + extra
    let minW: float64 = tabMinWidth(layout)
    if paddedW < minW:
        return minW
    return paddedW

fn tabIndexAtPoint(state: GuiState, px: float64, py: float64): int32 =
    let count: int32 = bufferLen(state.buffers)
    if count <= 0:
        return -1
    var x: float64 = tabStripStartX(state.layout) - state.tabScrollX
    let width: int32 = tabStripWidth(state.layout)
    let tabsEndX: float64 = tabStripTabsEndX(state, width, state.layout)
    let tabTop: float64 = tabStripTop(state.layout)
    let tabHInt: int32 = tabStripHeight(state.layout)
    if tabHInt <= 0:
        return -1
    let y0: float64 = tabTop
    let y1: float64 = y0 + float64(tabHInt)
    if py < y0 || py > y1:
        return -1
    let gap: float64 = tabStripGap(state.layout)
    for idx in 0..<count:
        let buffer: EditorState = bufferGet(state.buffers, idx)
        let label = tabLabel(state, buffer)
        let iconGlyph = tabIconGlyph(buffer)
        let reserveGlyph = tabReserveGlyph()
        let tabW: float64 = tabWidthForBuffer(state.layout, label, iconGlyph, reserveGlyph)
        if x + tabW > tabsEndX:
            break
        let tabX0: float64 = x
        let tabX1: float64 = x + tabW
        if px >= tabX0 && px <= tabX1:
            return idx
        x = x + tabW + gap
    return -1

fn tabCloseIndexAtPoint(state: GuiState, px: float64, py: float64): int32 =
    let count: int32 = bufferLen(state.buffers)
    if count <= 0:
        return -1
    let scale: float64 = state.layout.scale
    var x: float64 = tabStripStartX(state.layout) - state.tabScrollX
    let width: int32 = tabStripWidth(state.layout)
    let tabsEndX: float64 = tabStripTabsEndX(state, width, state.layout)
    let tabTop: float64 = tabStripTop(state.layout)
    let tabHInt: int32 = tabStripHeight(state.layout)
    if tabHInt <= 0:
        return -1
    let y0: float64 = tabTop
    let y1: float64 = y0 + float64(tabHInt)
    if py < y0 || py > y1:
        return -1
    let gap: float64 = tabStripGap(state.layout)
    for idx in 0..<count:
        let buffer: EditorState = bufferGet(state.buffers, idx)
        let label = tabLabel(state, buffer)
        let iconGlyph = tabIconGlyph(buffer)
        let reserveGlyph = tabReserveGlyph()
        let reserveW: float64 = if len(reserveGlyph) > 0: textWidthForFont(reserveGlyph, state.layout.smallFont, state.layout) else: 0.0
        let tabW: float64 = tabWidthForBuffer(state.layout, label, iconGlyph, reserveGlyph)
        if x + tabW > tabsEndX:
            break
        let isActive: bool = idx == state.activeBuffer
        let isHover: bool = idx == state.hoverTab
        let showClose: bool = tabShowClose(isActive, isHover)
        if showClose && reserveW > 0.0:
            let closeX: float64 = x + tabW - tabPaddingRight(state.layout) - reserveW
            let hitPad: float64 = 4.0 * scale
            if px >= closeX - hitPad && px <= closeX + reserveW + hitPad:
                return idx
        x = x + tabW + gap
    return -1

fn tabHoverInfoAtPoint(state: GuiState, px: float64, py: float64): TabHover =
    var outVal: TabHover
    outVal.idx = -1
    outVal.onClose = false
    let count: int32 = bufferLen(state.buffers)
    if count <= 0:
        return outVal
    let scale: float64 = state.layout.scale
    var x: float64 = tabStripStartX(state.layout) - state.tabScrollX
    let width: int32 = tabStripWidth(state.layout)
    let tabsEndX: float64 = tabStripTabsEndX(state, width, state.layout)
    let tabTop: float64 = tabStripTop(state.layout)
    let tabHInt: int32 = tabStripHeight(state.layout)
    if tabHInt <= 0:
        return outVal
    let y0: float64 = tabTop
    let y1: float64 = y0 + float64(tabHInt)
    if py < y0 || py > y1:
        return outVal
    let gap: float64 = tabStripGap(state.layout)
    for idx in 0..<count:
        let buffer: EditorState = bufferGet(state.buffers, idx)
        let label = tabLabel(state, buffer)
        let iconGlyph = tabIconGlyph(buffer)
        let reserveGlyph = tabReserveGlyph()
        let reserveW: float64 = if len(reserveGlyph) > 0: textWidthForFont(reserveGlyph, state.layout.smallFont, state.layout) else: 0.0
        let tabW: float64 = tabWidthForBuffer(state.layout, label, iconGlyph, reserveGlyph)
        if x + tabW > tabsEndX:
            break
        let tabX0: float64 = x
        let tabX1: float64 = x + tabW
        if px >= tabX0 && px <= tabX1:
            outVal.idx = idx
            if reserveW > 0.0:
                let closeX: float64 = x + tabW - tabPaddingRight(state.layout) - reserveW
                let hitPad: float64 = 4.0 * scale
                if px >= closeX - hitPad && px <= closeX + reserveW + hitPad:
                    outVal.onClose = true
            return outVal
        x = x + tabW + gap
    return outVal

fn tabStripControlHit(state: GuiState, width: int32, px: float64, py: float64): int32 =
    let layout: GuiLayout = state.layout
    let scale: float64 = layout.scale
    let size: float64 = tabStripControlSize(layout)
    if size <= 0.0:
        return TabControlNone
    let gap: float64 = tabStripControlGap(layout)
    let tabH: int32 = tabStripHeight(layout)
    if tabH <= 0:
        return TabControlNone
    let tabTop: float64 = tabStripTop(layout)
    let y0: float64 = tabTop + (float64(tabH - size)) * 0.5
    let y1: float64 = y0 + size
    if py < y0 || py > y1:
        return TabControlNone
    let needsScroll: bool = tabStripNeedsScrollButtons(state, width, layout)
    let startX: float64 = tabStripControlsStartX(state, width, layout)
    if needsScroll:
        let leftX: float64 = startX
        let rightX: float64 = leftX + size + gap
        let newX: float64 = rightX + size + gap
        if px >= leftX && px <= leftX + size:
            return TabControlLeft
        if px >= rightX && px <= rightX + size:
            return TabControlRight
        if px >= newX && px <= newX + size:
            return TabControlNew
    else:
        if px >= startX && px <= startX + size:
            return TabControlNew
    return TabControlNone

fn terminalHeaderTitle(state: GuiState): str =
    let rawCount: int32 = terminalSessionLen(state.terminalSessions)
    let count: int32 = if rawCount > 0: rawCount else: 1
    let base = if state.terminal.mode == tmPty: "TERMINAL (PTY)" else: "TERMINAL"
    if count > 1:
        return base + " (" + intToStr(count) + ")"
    return base

fn terminalTabLabel(session: TerminalState, idx: int32): str =
    let base = if len(session.label) > 0: session.label else: "term-" + intToStr(idx + 1)
    return intToStr(idx + 1) + ":" + base

fn terminalTabIndexAtPoint(state: GuiState, px: float64, py: float64): int32 =
    if state.bottomPaneTab != bpTerminal:
        return -1
    let count: int32 = terminalSessionLen(state.terminalSessions)
    if count <= 1:
        return -1
    let layout: GuiLayout = state.layout
    let scale: float64 = layout.scale
    let title: str = terminalHeaderTitle(state)
    let titleW: float64 = textWidthForFont(title, layout.headerFont, layout)
    let y: float64 = panelHeaderTextY(layout, bottomPaneContentTop(layout))
    let y1: float64 = y + layout.lineHeight
    if py < y || py > y1:
        return -1
    var x: float64 = float64(layout.editorX + panelPaddingX(layout) + titleW + 12.0 * scale)
    let maxX: float64 = float64(layout.editorX + layout.editorW - 16.0 * scale)
    for idx in 0..<count:
        if ! (x < maxX):
            break
        let session: TerminalState = terminalSessionGet(state.terminalSessions, idx)
        let labelBase = terminalTabLabel(session, idx)
        let label = if idx == state.terminalSessionActive: "[" + labelBase + "]" else: labelBase
        let tabW: float64 = textWidthForFont(label, layout.smallFont, layout)
        if x + tabW > maxX:
            break
        if px >= x && px <= x + tabW:
            return idx
        x = x + tabW + 12.0 * scale
    return -1

fn leftPaneTabIndexAtPoint(state: GuiState, px: float64, py: float64): int32 =
    let layout: GuiLayout = state.layout
    let barW: int32 = activityBarWidth(layout)
    if barW <= 0:
        return -1
    if px < 0.0 || px > float64(barW):
        return -1
    let top: float64 = float64(layout.contentY)
    let bottom: float64 = float64(layout.contentY + layout.contentH)
    if py < top || py > bottom:
        return -1
    let slotH: float64 = 48.0 * layout.scale
    if slotH <= 0.0:
        return -1
    let relY: float64 = py - top
    let idx: int32 = int32(relY / slotH)
    if idx < 0 || idx >= leftPaneTabCount():
        return -1
    return idx

fn activityBottomCount(): int32 =
    return 2

fn activityBottomGlyph(idx: int32): str =
    if idx == ActivityBottomAccount:
        return codiconGlyph(CodiconAccount)
    if idx == ActivityBottomSettings:
        return codiconGlyph(CodiconSettingsGear)
    return ""

fn activityBottomIndexAtPoint(state: GuiState, px: float64, py: float64): int32 =
    let layout: GuiLayout = state.layout
    let barW: int32 = activityBarWidth(layout)
    if barW <= 0:
        return -1
    if px < 0.0 || px > float64(barW):
        return -1
    let contentTop: float64 = float64(layout.contentY)
    let contentBottom: float64 = float64(layout.contentY + layout.contentH)
    if py < contentTop || py > contentBottom:
        return -1
    let slotH: float64 = 48.0 * layout.scale
    if slotH <= 0.0:
        return -1
    let count: int32 = activityBottomCount()
    if count <= 0:
        return -1
    let bottomStartY: float64 = contentBottom - slotH * float64(count)
    if py < bottomStartY:
        return -1
    let relY: float64 = py - bottomStartY
    let idx: int32 = int32(relY / slotH)
    if idx < 0 || idx >= count:
        return -1
    return idx

fn rightPaneTabIndexAtPoint(state: GuiState, px: float64, py: float64): int32 =
    let layout: GuiLayout = state.layout
    if layout.rightW <= 0:
        return -1
    let tabTop: float64 = float64(rightPaneTabBarTop(layout))
    let tabBottom: float64 = tabTop + float64(rightPaneTabBarHeight(layout))
    if py < tabTop || py > tabBottom:
        return -1
    let rightX: int32 = layout.leftW + layout.editorW
    var x: float64 = float64(rightX + panelPaddingX(layout))
    let maxX: float64 = float64(rightX + layout.rightW - panelPaddingX(layout))
    let count: int32 = rightPaneTabCount()
    for idx in 0..<count:
        if ! (x < maxX):
            break
        let tab: RightPaneTab = rightPaneTabFromIndex(idx)
        let label = rightPaneTabDisplay(tab)
        let tabW: float64 = textWidthForFont(label, layout.smallFont, layout) + 12.0 * layout.scale
        if px >= x && px <= x + tabW:
            return idx
        x = x + tabW + 8.0 * layout.scale
    return -1

fn bottomPaneTabIndexAtPoint(state: GuiState, px: float64, py: float64): int32 =
    let layout: GuiLayout = state.layout
    if layout.bottomH <= 0:
        return -1
    let tabTop: float64 = float64(layout.bottomY)
    let tabH: float64 = float64(bottomPaneTabBarHeight(layout))
    let tabBottom: float64 = tabTop + tabH
    if py < tabTop || py > tabBottom:
        return -1
    let panelX: float64 = float64(layout.editorX)
    let panelW: float64 = float64(layout.editorW)
    if px < panelX || px > panelX + panelW:
        return -1
    var x: float64 = panelX + panelPaddingX(layout)
    let maxX: float64 = panelX + panelW - panelPaddingX(layout)
    let count: int32 = bottomPaneTabCount()
    for idx in 0..<count:
        if ! (x < maxX):
            break
        let tab: BottomPaneTab = bottomPaneTabFromIndex(idx)
        let label = bottomPaneTabDisplay(tab)
        let tabW: float64 = textWidthForFont(label, layout.smallFont, layout) + 16.0 * layout.scale
        if px >= x && px <= x + tabW:
            return idx
        x = x + tabW + 8.0 * layout.scale
    return -1

fn clampPaneSizes(state: GuiState, width, height: int32, scale: float64): GuiState =
    var next: GuiState = state
    let titleH: int32 = int32(35.0 * scale)
    let tabH: int32 = int32(35.0 * scale)
    let topH: int32 = minInt(titleH + tabH, height / 3)
    let statusH: int32 = minInt(int32(22.0 * scale), height / 6)
    let minEditorW: int32 = maxInt(int32(360.0 * scale), 240)
    let minEditorH: int32 = maxInt(int32(200.0 * scale), 140)
    let maxPanelsW: int32 = maxInt(0, width - minEditorW)
    var minLeft: int32 = minInt(int32(160.0 * scale), maxPanelsW)
    let wantRight: bool = next.rightPaneVisible
    var minRight: int32 = if wantRight: minInt(int32(200.0 * scale), maxPanelsW) else: 0
    if minLeft + minRight > maxPanelsW:
        if maxPanelsW <= 0:
            minLeft = 0
            minRight = 0
        else:
            let half: int32 = maxPanelsW / 2
            minLeft = minInt(minLeft, half)
            minRight = maxPanelsW - minLeft
    let defaultLeft: int32 = int32(300.0 * scale)
    let defaultRight: int32 = int32(300.0 * scale)
    let defaultBottom: int32 = int32(300.0 * scale)
    let maxLeft: int32 = maxPanelsW - minRight
    var leftStored: int32 = if next.leftPaneWidth > 0: next.leftPaneWidth else: defaultLeft
    leftStored = clampInt(leftStored, minLeft, maxLeft)
    let barW: int32 = minInt(int32(48.0 * scale), maxPanelsW)
    let leftActual: int32 = if next.leftPaneVisible: leftStored else: barW
    var rightStored: int32 = next.rightPaneWidth
    if rightStored <= 0:
        rightStored = if wantRight: defaultRight else: 0
    let maxRight: int32 = maxPanelsW - leftActual
    rightStored = clampInt(rightStored, minRight, maxRight)
    let contentH: int32 = maxInt(0, height - topH - statusH)
    let maxBottom: int32 = maxInt(0, contentH - minEditorH)
    let minBottom: int32 = minInt(int32(120.0 * scale), maxBottom)
    var bottomStored: int32 = if next.bottomPaneHeight > 0: next.bottomPaneHeight else: defaultBottom
    bottomStored = clampInt(bottomStored, minBottom, maxBottom)
    next.leftPaneWidth = leftStored
    next.rightPaneWidth = rightStored
    next.bottomPaneHeight = bottomStored
    return next

fn calcLayoutKey(state: GuiState, width, height: int32, scale: float64): int64 =
    var key: int64 = int64(width)
    key = key * 1315423911 + int64(height)
    key = key * 1315423911 + int64(scale * 1000.0)
    var leftFlag: int64 = 0
    var rightFlag: int64 = 0
    var bottomFlag: int64 = 0
    if state.leftPaneVisible:
        leftFlag = 1
    if state.rightPaneVisible:
        rightFlag = 1
    if state.bottomPaneVisible:
        bottomFlag = 1
    key = key * 1315423911 + leftFlag
    key = key * 1315423911 + rightFlag
    key = key * 1315423911 + bottomFlag
    key = key * 1315423911 + int64(state.leftPaneWidth)
    key = key * 1315423911 + int64(state.rightPaneWidth)
    key = key * 1315423911 + int64(state.bottomPaneHeight)
    return key

fn editorTopPadding(layout: GuiLayout): float64 =
    return 28.0 * layout.scale

fn titleBarHeight(layout: GuiLayout): int32 =
    let desired: int32 = int32(35.0 * layout.scale)
    if desired <= 0:
        return minInt(35, layout.topH)
    return minInt(desired, layout.topH)

fn tabStripHeight(layout: GuiLayout): int32 =
    let h: int32 = layout.topH - titleBarHeight(layout)
    if h < 0:
        return 0
    return h

fn tabStripTop(layout: GuiLayout): float64 =
    return float64(titleBarHeight(layout))

fn tabStripGap(layout: GuiLayout): float64 =
    return 0.0 * layout.scale

fn calcLayout(state: GuiState, width, height: int32, scale: float64): GuiLayout =
    var layout: GuiLayout
    layout.scale = scale
    let titleH: int32 = int32(35.0 * scale)
    let tabH: int32 = int32(35.0 * scale)
    layout.topH = minInt(titleH + tabH, height / 3)
    layout.statusH = minInt(int32(22.0 * scale), height / 6)
    let minEditorW: int32 = maxInt(int32(360.0 * scale), 240)
    let maxPanelsW: int32 = maxInt(0, width - minEditorW)
    let barW: int32 = minInt(int32(48.0 * scale), maxPanelsW)
    layout.leftW = if state.leftPaneVisible: maxInt(0, state.leftPaneWidth) else: barW
    layout.rightW = if state.rightPaneVisible: maxInt(0, state.rightPaneWidth) else: 0
    layout.bottomH = if state.bottomPaneVisible: maxInt(0, state.bottomPaneHeight) else: 0
    layout.contentY = layout.topH
    layout.contentH = maxInt(0, height - layout.topH - layout.statusH)
    layout.editorH = maxInt(0, layout.contentH - layout.bottomH)
    layout.bottomY = layout.contentY + layout.editorH
    layout.editorX = layout.leftW
    layout.editorY = layout.contentY
    layout.editorW = maxInt(0, width - layout.leftW - layout.rightW)
    layout.gutterW = int32(48.0 * scale)
    layout.headerFont = 13.0 * scale
    layout.fontSize = 12.0 * scale
    layout.smallFont = 12.0 * scale
    layout.lineHeight = 18.0 * scale
    layout.advance = layout.fontSize * 0.6
    layout.codeX = float64(layout.editorX + layout.gutterW + 8)
    layout.codeY = float64(layout.contentY + editorTopPadding(layout))
    return layout

fn splitHandlePad(layout: GuiLayout): float64 =
    let size: float64 = 4.0 * layout.scale
    if size < 4.0:
        return 4.0
    return size

fn splitHitTest(layout: GuiLayout, px, py: float64): ResizeDragKind =
    let pad: float64 = splitHandlePad(layout)
    let contentTop: float64 = float64(layout.contentY)
    let contentBottom: float64 = float64(layout.contentY + layout.contentH)
    if py < contentTop || py > contentBottom:
        return rdNone
    let leftX: float64 = float64(layout.leftW)
    if layout.leftW > 0 && px >= leftX - pad && px <= leftX + pad:
        return rdLeft
    let rightX: float64 = float64(layout.leftW + layout.editorW)
    if layout.rightW > 0 && px >= rightX - pad && px <= rightX + pad:
        return rdRight
    let bottomY: float64 = float64(layout.bottomY)
    if layout.bottomH > 0 && py >= bottomY - pad && py <= bottomY + pad:
        if px >= float64(layout.editorX) && px <= float64(layout.editorX + layout.editorW):
            return rdBottom
    return rdNone

fn applyResizeDrag(state: GuiState, width, height: int32, scale: float64, px, py: float64): GuiState =
    var next: GuiState = state
    if next.resizeDrag == rdLeft:
        next.leftPaneWidth = int32(px)
    elif next.resizeDrag == rdRight:
        next.rightPaneWidth = maxInt(0, width - int32(px))
    elif next.resizeDrag == rdBottom:
        let statusH: int32 = minInt(int32(22.0 * scale), height / 6)
        next.bottomPaneHeight = maxInt(0, height - statusH - int32(py))
    next = clampPaneSizes(next, width, height, scale)
    next.layout = calcLayout(next, width, height, scale)
    next.layoutKey = calcLayoutKey(next, width, height, scale)
    return next

fn splitGap(layout: GuiLayout): int32 =
    return maxInt(1, int32(2.0 * layout.scale))

fn editorPaneMetrics(layout: GuiLayout, pane: int32, splitActive: bool): EditorPaneMetrics =
    var metrics: EditorPaneMetrics
    if ! splitActive:
        metrics.y = layout.contentY
        metrics.h = layout.editorH
    else:
        let gap: int32 = splitGap(layout)
        let topH: int32 = maxInt(1, (layout.editorH - gap) / 2)
        let bottomH: int32 = maxInt(1, layout.editorH - gap - topH)
        if pane <= 0:
            metrics.y = layout.contentY
            metrics.h = topH
        else:
            metrics.y = layout.contentY + topH + gap
            metrics.h = bottomH
    metrics.codeY = float64(metrics.y + editorTopPadding(layout))
    return metrics

fn editorPaneIndex(layout: GuiLayout, py: float64, splitActive: bool): int32 =
    if ! splitActive:
        return 0
    let gap: int32 = splitGap(layout)
    let topH: int32 = maxInt(1, (layout.editorH - gap) / 2)
    let splitY: int32 = layout.contentY + topH + gap
    if py < float64(splitY):
        return 0
    return 1

fn minimapWidth(layout: GuiLayout): int32 =
    let minContent: int32 = int32(200.0 * layout.scale)
    let desired: int32 = int32(80.0 * layout.scale)
    let avail: int32 = layout.editorW - minContent
    if avail <= 0:
        return 0
    return minInt(desired, avail)

fn panelPaddingX(layout: GuiLayout): float64 =
    return 12.0 * layout.scale

fn panelHeaderHeight(layout: GuiLayout): int32 =
    return maxInt(1, int32(24.0 * layout.scale))

fn panelHeaderTextY(layout: GuiLayout, top: int32): float64 =
    return float64(top + 16.0 * layout.scale)

fn panelListStartY(layout: GuiLayout, top: int32): float64 =
    return float64(top + panelHeaderHeight(layout) + 6.0 * layout.scale)

fn panelListVisibleLines(layout: GuiLayout, panelH: int32): int32 =
    let avail = float64(panelH - panelHeaderHeight(layout) - 8.0 * layout.scale)
    return maxInt(1, int32(avail / layout.lineHeight))

fn explorerTitleY(layout: GuiLayout): float64 =
    return panelHeaderTextY(layout, layout.contentY)

fn explorerListStartY(layout: GuiLayout): float64 =
    return panelListStartY(layout, layout.contentY)

fn explorerDebugLineOffset(layout: GuiLayout): int32 =
    if len(iconDebugLabel(layout)) > 0:
        return 1
    return 0

fn explorerVisibleLines(layout: GuiLayout): int32 =
    return panelListVisibleLines(layout, layout.contentH)

fn activityBarWidth(layout: GuiLayout): int32 =
    if layout.leftW <= 0:
        return 0
    let desired: int32 = int32(48.0 * layout.scale)
    if layout.leftW <= desired:
        return layout.leftW
    return desired

fn explorerHeaderActionFont(layout: GuiLayout): float64 =
    let minFont: float64 = layout.fontSize - 1.0 * layout.scale
    if layout.smallFont > minFont:
        return layout.smallFont
    return minFont

fn explorerHeaderActionGap(layout: GuiLayout): float64 =
    return 10.0 * layout.scale

fn explorerHeaderActionPad(layout: GuiLayout): float64 =
    return 4.0 * layout.scale

fn explorerHeaderActionHit(layout: GuiLayout, px: float64, py: float64): int32 =
    let headerTop: float64 = float64(layout.contentY)
    let headerBottom: float64 = headerTop + float64(panelHeaderHeight(layout))
    if py < headerTop || py > headerBottom:
        return ExplorerActionNone
    let barW: int32 = activityBarWidth(layout)
    let leftContentW: int32 = maxInt(0, layout.leftW - barW)
    if leftContentW <= 0:
        return ExplorerActionNone
    let actionFont: float64 = explorerHeaderActionFont(layout)
    let gap: float64 = explorerHeaderActionGap(layout)
    let pad: float64 = explorerHeaderActionPad(layout)
    var x: float64 = float64(barW + leftContentW - panelPaddingX(layout))
    let idxBase = explorerHeaderActionCount() - 1
    if idxBase >= 0:
        for idxRev in 0..idxBase:
            let idx = idxBase - idxRev
            let kind = explorerHeaderActionFromIndex(idx)
            let glyph = explorerHeaderActionGlyph(kind)
            if len(glyph) > 0:
                let w: float64 = textWidthForFont(glyph, actionFont, layout)
                x = x - w
                if px >= x - pad && px <= x + w + pad:
                    return kind
                x = x - gap
    return ExplorerActionNone

fn searchHeaderActionHit(layout: GuiLayout, px: float64, py: float64): int32 =
    let headerTop: float64 = float64(layout.contentY)
    let headerBottom: float64 = headerTop + float64(panelHeaderHeight(layout))
    if py < headerTop || py > headerBottom:
        return SearchActionNone
    let barW: int32 = activityBarWidth(layout)
    let leftContentW: int32 = maxInt(0, layout.leftW - barW)
    if leftContentW <= 0:
        return SearchActionNone
    let actionFont: float64 = explorerHeaderActionFont(layout)
    let gap: float64 = explorerHeaderActionGap(layout)
    let pad: float64 = explorerHeaderActionPad(layout)
    var x: float64 = float64(barW + leftContentW - panelPaddingX(layout))
    let idxBase = searchHeaderActionCount() - 1
    if idxBase >= 0:
        for idxRev in 0..idxBase:
            let idx = idxBase - idxRev
            let kind = searchHeaderActionFromIndex(idx)
            let glyph = searchHeaderActionGlyph(kind)
            if len(glyph) > 0:
                let w: float64 = textWidthForFont(glyph, actionFont, layout)
                x = x - w
                if px >= x - pad && px <= x + w + pad:
                    return kind
                x = x - gap
    return SearchActionNone

fn vcsHeaderActionHit(layout: GuiLayout, px: float64, py: float64): int32 =
    let headerTop: float64 = float64(layout.contentY)
    let headerBottom: float64 = headerTop + float64(panelHeaderHeight(layout))
    if py < headerTop || py > headerBottom:
        return VcsActionNone
    let barW: int32 = activityBarWidth(layout)
    let leftContentW: int32 = maxInt(0, layout.leftW - barW)
    if leftContentW <= 0:
        return VcsActionNone
    let actionFont: float64 = explorerHeaderActionFont(layout)
    let gap: float64 = explorerHeaderActionGap(layout)
    let pad: float64 = explorerHeaderActionPad(layout)
    var x: float64 = float64(barW + leftContentW - panelPaddingX(layout))
    let idxBase = vcsHeaderActionCount() - 1
    if idxBase >= 0:
        for idxRev in 0..idxBase:
            let idx = idxBase - idxRev
            let kind = vcsHeaderActionFromIndex(idx)
            let glyph = vcsHeaderActionGlyph(kind)
            if len(glyph) > 0:
                let w: float64 = textWidthForFont(glyph, actionFont, layout)
                x = x - w
                if px >= x - pad && px <= x + w + pad:
                    return kind
                x = x - gap
    return VcsActionNone

fn bottomPaneTabBarHeight(layout: GuiLayout): int32 =
    return panelHeaderHeight(layout)

fn bottomPaneTabTextY(layout: GuiLayout): float64 =
    return panelHeaderTextY(layout, layout.bottomY)

fn bottomPaneContentTop(layout: GuiLayout): int32 =
    return layout.bottomY + bottomPaneTabBarHeight(layout)

fn bottomPaneContentHeight(layout: GuiLayout): int32 =
    return maxInt(0, layout.bottomH - bottomPaneTabBarHeight(layout))

fn rightPaneTabBarTop(layout: GuiLayout): int32 =
    return layout.contentY

fn rightPaneTabBarHeight(layout: GuiLayout): int32 =
    return panelHeaderHeight(layout)

fn rightPaneTabTextY(layout: GuiLayout): float64 =
    return panelHeaderTextY(layout, rightPaneTabBarTop(layout))

fn rightPaneContentTitleY(layout: GuiLayout): float64 =
    let contentTop: int32 = rightPaneTabBarTop(layout) + rightPaneTabBarHeight(layout)
    return panelHeaderTextY(layout, contentTop)

fn rightPaneContentListStartY(layout: GuiLayout): float64 =
    let contentTop: int32 = rightPaneTabBarTop(layout) + rightPaneTabBarHeight(layout)
    return panelListStartY(layout, contentTop)

fn rightPaneContentVisibleLines(layout: GuiLayout): int32 =
    let contentH: int32 = maxInt(0, layout.contentH - rightPaneTabBarHeight(layout))
    return panelListVisibleLines(layout, contentH)

fn rightPanelSplitY(layout: GuiLayout): int32 =
    let minSectionH: int32 = int32(6.0 * layout.lineHeight + 40.0 * layout.scale)
    let preferred: int32 = layout.contentY + int32(float64(layout.contentH * 0.55))
    let minSplit: int32 = layout.contentY + minSectionH
    let maxSplit: int32 = layout.contentY + layout.contentH - minSectionH
    if maxSplit <= minSplit:
        return layout.contentY + layout.contentH / 2
    return clampInt(preferred, minSplit, maxSplit)

fn rightPanelSplitY2(layout: GuiLayout): int32 =
    let minSectionH: int32 = int32(5.0 * layout.lineHeight + 40.0 * layout.scale)
    let topSplit: int32 = rightPanelSplitY(layout)
    let minSplit: int32 = topSplit + minSectionH
    let maxSplit: int32 = layout.contentY + layout.contentH - minSectionH
    let preferred: int32 = layout.contentY + int32(float64(layout.contentH * 0.72))
    if maxSplit <= minSplit:
        return minSplit
    return clampInt(preferred, minSplit, maxSplit)

fn rightPanelSplitY3(layout: GuiLayout): int32 =
    let minSectionH: int32 = int32(4.0 * layout.lineHeight + 40.0 * layout.scale)
    let topSplit: int32 = rightPanelSplitY2(layout)
    let minSplit: int32 = topSplit + minSectionH
    let maxSplit: int32 = layout.contentY + layout.contentH - minSectionH
    let preferred: int32 = layout.contentY + int32(float64(layout.contentH * 0.82))
    if maxSplit <= minSplit:
        return minSplit
    return clampInt(preferred, minSplit, maxSplit)

fn rightPanelSplitY4(layout: GuiLayout): int32 =
    let minSectionH: int32 = int32(4.0 * layout.lineHeight + 40.0 * layout.scale)
    let topSplit: int32 = rightPanelSplitY3(layout)
    let minSplit: int32 = topSplit + minSectionH
    let maxSplit: int32 = layout.contentY + layout.contentH - minSectionH
    let preferred: int32 = layout.contentY + int32(float64(layout.contentH * 0.9))
    if maxSplit <= minSplit:
        return minSplit
    return clampInt(preferred, minSplit, maxSplit)

fn outlineTitleY(layout: GuiLayout): float64 =
    return float64(layout.contentY + 18.0 * layout.scale)

fn outlineListStartY(layout: GuiLayout): float64 =
    return outlineTitleY(layout) + 20.0 * layout.scale

fn outlineVisibleLines(layout: GuiLayout): int32 =
    let splitY: int32 = rightPanelSplitY(layout)
    let startY: float64 = outlineListStartY(layout)
    let avail: float64 = float64(splitY - startY)
    return maxInt(1, int32(avail / layout.lineHeight))

fn diagnosticsTitleY(layout: GuiLayout): float64 =
    return float64(rightPanelSplitY(layout) + 18.0 * layout.scale)

fn diagnosticsListStartY(layout: GuiLayout): float64 =
    return diagnosticsTitleY(layout) + 20.0 * layout.scale

fn diagnosticsVisibleLines(layout: GuiLayout): int32 =
    let startY: float64 = diagnosticsListStartY(layout)
    let bottom: float64 = float64(rightPanelSplitY2(layout))
    let avail: float64 = bottom - startY
    return maxInt(1, int32(avail / layout.lineHeight))

fn debuggerTitleY(layout: GuiLayout): float64 =
    return float64(rightPanelSplitY2(layout) + 18.0 * layout.scale)

fn debuggerListStartY(layout: GuiLayout): float64 =
    return debuggerTitleY(layout) + 20.0 * layout.scale

fn debuggerVisibleLines(layout: GuiLayout): int32 =
    let startY: float64 = debuggerListStartY(layout)
    let bottom: float64 = float64(rightPanelSplitY3(layout))
    let avail: float64 = bottom - startY
    return maxInt(1, int32(avail / layout.lineHeight))

fn vcsTitleY(layout: GuiLayout): float64 =
    return float64(rightPanelSplitY3(layout) + 18.0 * layout.scale)

fn vcsListStartY(layout: GuiLayout): float64 =
    return vcsTitleY(layout) + 20.0 * layout.scale

fn vcsVisibleLines(layout: GuiLayout): int32 =
    let startY: float64 = vcsListStartY(layout)
    let bottom: float64 = float64(rightPanelSplitY4(layout))
    let avail: float64 = bottom - startY
    return maxInt(1, int32(avail / layout.lineHeight))

fn tasksTitleY(layout: GuiLayout): float64 =
    return float64(rightPanelSplitY4(layout) + 18.0 * layout.scale)

fn tasksListStartY(layout: GuiLayout): float64 =
    return tasksTitleY(layout) + 20.0 * layout.scale

fn tasksVisibleLines(layout: GuiLayout): int32 =
    let startY: float64 = tasksListStartY(layout)
    let bottom: float64 = float64(layout.contentY + layout.contentH)
    let avail: float64 = bottom - startY
    return maxInt(1, int32(avail / layout.lineHeight))

fn commitTerminalInput(state: TerminalState): TerminalState =
    if len(state.input) > 0:
        addPtr_string(&state.lines, state.input)
    state.input = ""
    return state

fn guiTerminalAppendLines(state: TerminalState, lines: str[]): TerminalState =
    var next: TerminalState = state
    for idx in 0..<seqLenString(lines):
        next = pushTerminalLine(next, seqGetString(lines, idx))
    return next

fn guiTerminalAppendOutput(state: TerminalState, output: str): TerminalState =
    if len(output) == 0:
        return state
    let lines: str[] = splitLinesSimple(output)
    return guiTerminalAppendLines(state, lines)

fn terminalVisibleLineCount(state: TerminalState): int32 =
    let base: int32 = seqLenString(state.lines)
    if state.mode == tmPty && len(state.ptyRemainder) > 0:
        return base + 1
    return base

fn terminalLineAt(state: TerminalState, idx: int32): str =
    let base: int32 = seqLenString(state.lines)
    if idx >= 0 && idx < base:
        return seqGetString(state.lines, idx)
    if state.mode == tmPty && idx == base && len(state.ptyRemainder) > 0:
        return state.ptyRemainder
    return ""

fn guiPtySupported(): bool =
    return ptySupported()

fn guiPtyStart(state: GuiState, command: str): GuiState =
    if state.terminal.ptyActive:
        state.statusMsg = "pty: already running"
        return state
    if ! guiPtySupported():
        state.statusMsg = "pty: unsupported"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    var fd: int32 = -1
    var pid: int64 = 0
    let workDir = if len(state.projectRoot) > 0: state.projectRoot else: getCurrentDir()
    let ok: bool = ptySpawn(command, workDir, &fd, &pid)
    if ! ok:
        state.statusMsg = "pty: spawn failed"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    state.terminal.mode = tmPty
    state.terminal.ptyActive = true
    state.terminal.ptyFd = fd
    state.terminal.ptyPid = pid
    state.terminal.ptyRemainder = ""
    state.terminal.ptyAnsiRemainder = ""
    if len(command) > 0:
        state.statusMsg = "pty: " + command
    else:
        state.statusMsg = "pty: shell"
    state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
    return state

fn guiPtyStop(state: GuiState, reason: str): GuiState =
    if ! state.terminal.ptyActive:
        state.statusMsg = "pty: not running"
        return state
    ptyClose(state.terminal.ptyFd)
    var exitCode: int32 = -1
    ptyWait(state.terminal.ptyPid, &exitCode)
    state.terminal.ptyActive = false
    state.terminal.ptyFd = -1
    state.terminal.ptyPid = 0
    state.terminal.mode = tmCommand
    state.terminal.ptyRemainder = ""
    state.terminal.ptyAnsiRemainder = ""
    if len(reason) > 0:
        state.statusMsg = "pty: " + reason
    else:
        state.statusMsg = "pty: stopped"
    state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
    return state

fn skipAnsiSequence(text: str, startIdx: int32): int32 =
    if startIdx < 0 || startIdx >= len(text):
        return -1
    if startIdx + 1 >= len(text):
        return -1
    let next: char = text[startIdx + 1]
    if next == '[':
        for idx in startIdx + 2..<len(text):
            let ch: char = text[idx]
            if ch >= '@' && ch <= '~':
                return idx + 1
        return -1
    if next == ']':
        for idx in startIdx + 2..<len(text):
            let ch: char = text[idx]
            if ch == '\x07':
                return idx + 1
            if ch == '\\' && idx > startIdx + 1 && text[idx - 1] == '\x1b':
                return idx + 1
        return -1
    return startIdx + 2

fn guiPtyConsumeOutput(state: GuiState, output: str): GuiState =
    if len(output) == 0:
        return state
    var text = state.terminal.ptyAnsiRemainder + output
    state.terminal.ptyAnsiRemainder = ""
    var lineBuf: str = state.terminal.ptyRemainder
    var idx: int32 = 0
    var segStart: int32 = 0
    let total: int32 = len(text)
    while idx < total:
        let ch: char = text[idx]
        if ch == '\x1b':
            if segStart < idx:
                lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
            let nextIdx: int32 = skipAnsiSequence(text, idx)
            if nextIdx < 0:
                state.terminal.ptyAnsiRemainder = sliceFrom(text, idx)
                segStart = idx
                break
            idx = nextIdx
            segStart = idx
            continue
        if ch == '\r':
            if segStart < idx:
                lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
            if idx + 1 < total && text[idx + 1] == '\n':
                state.terminal = pushTerminalLine(state.terminal, lineBuf)
                lineBuf = ""
                idx = idx + 2
                segStart = idx
                continue
            lineBuf = ""
            idx = idx + 1
            segStart = idx
            continue
        if ch == '\n':
            if segStart < idx:
                lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
            state.terminal = pushTerminalLine(state.terminal, lineBuf)
            lineBuf = ""
            idx = idx + 1
            segStart = idx
            continue
        if ch == chr(8):
            if segStart < idx:
                lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
            let bufLen: int32 = len(lineBuf)
            if bufLen > 0:
                lineBuf = slicePrefix(lineBuf, bufLen - 1)
            idx = idx + 1
            segStart = idx
            continue
        idx = idx + 1
    if idx > segStart:
        lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
    state.terminal.ptyRemainder = lineBuf
    state.renderDirty = true
    return state

fn guiPtyTick(state: GuiState): GuiState =
    if ! state.terminal.ptyActive:
        return state
    for loops in 0..<8:
        var eof: int32 = 0
        let chunk: str = ptyRead(state.terminal.ptyFd, 4096, &eof)
        if eof != 0:
            return guiPtyStop(state, "exit")
        if len(chunk) == 0:
            break
        state = guiPtyConsumeOutput(state, chunk)
    return state

fn guiPtySendInput(state: GuiState, input: str): GuiState =
    if ! state.terminal.ptyActive:
        state.statusMsg = "pty: not running"
        return state
    let payload = input + "\n"
    ptyWrite(state.terminal.ptyFd, payload)
    state.terminal.input = ""
    return state

fn guiPtySendRawInput(state: GuiState, input: str): GuiState =
    if ! state.terminal.ptyActive:
        state.statusMsg = "pty: not running"
        return state
    if len(input) == 0:
        return state
    ptyWrite(state.terminal.ptyFd, input)
    return state

fn guiSpawnDetached(command: str, workDir: str): bool =
    if len(command) == 0:
        return false
    if ptySupported():
        var fd: int32 = -1
        var pid: int64 = 0
        if ptySpawn(command, workDir, &fd, &pid):
            if fd >= 0:
                ptyClose(fd)
            return true
    if guiIsWindows():
        let cmd = "start \"\" " + command
        let result: ExecCmdResult = execCmdEx(cmd, {poStdErrToStdOut}, workDir)
        return result.exitCode == 0
    let cmd = command + " >/dev/null 2>&1 &"
    let result: ExecCmdResult = execCmdEx(cmd, {poStdErrToStdOut}, workDir)
    return result.exitCode == 0

fn guiOpenUrl(state: GuiState, url: str): GuiState =
    var next: GuiState = state
    let trimmed = trimLine(url)
    if len(trimmed) == 0:
        next.statusMsg = "open: empty"
        return next
    codexLog("open: url")
    var cmd = ""
    if guiIsWindows():
        cmd = "start \"\" " + guiShellQuote(trimmed)
    elif guiIsMac():
        cmd = "open " + guiShellQuote(trimmed)
    else:
        cmd = "xdg-open " + guiShellQuote(trimmed)
    let workDir = guiWorkspaceActiveRoot(next)
    if guiSpawnDetached(cmd, workDir):
        next.statusMsg = "open: url"
    else:
        next.statusMsg = "open: failed"
    return next

fn guiShellQuote(text: str): str =
    var outVal: str = "\""
    for i in 0..<len(text):
        let ch: char = text[i]
        if ch == '"' || ch == '\\' || ch == '$' || ch == '`':
            outVal = outVal + "\\" + charToStr(ch)
        else:
            outVal = outVal + charToStr(ch)
    return outVal + "\""

fn guiWindowEnvPrefix(root: str, openPath: str): str =
    if guiIsWindows():
        return ""
    var outVal: str = ""
    if len(root) > 0:
        outVal = outVal + "IDE_ROOT=" + guiShellQuote(root) + " "
    if len(openPath) > 0:
        outVal = outVal + "IDE_OPEN=" + guiShellQuote(openPath) + " "
    return outVal

fn guiNewWindowCommand(state: GuiState, openPath: str): str =
    let override = getEnv("IDE_NEW_WINDOW_CMD")
    var baseCmd: str = override
    if len(baseCmd) == 0:
        let binOverride = getEnv("IDE_BIN")
        if len(binOverride) > 0:
            baseCmd = binOverride
        else:
            let root = getEnv("IDE_ROOT")
            if len(root) > 0:
                baseCmd = joinPath(root, "build/main_local")
            else:
                baseCmd = "./ide/main_local"
        if guiIsWindows() && ! endsWithSuffix(baseCmd, ".exe"):
            baseCmd = baseCmd + ".exe"
    let root = guiWorkspaceActiveRoot(state)
    let envPrefix = guiWindowEnvPrefix(root, openPath)
    return envPrefix + baseCmd

fn guiOpenNewWindow(state: GuiState, path: str): GuiState =
    var target = trimLine(path)
    if len(target) == 0 && len(state.editor.filePath) > 0:
        target = state.editor.filePath
    let resolved = if len(target) > 0: resolveWorkspacePath(state, target) else: ""
    let cmd = guiNewWindowCommand(state, resolved)
    if len(cmd) == 0:
        state.statusMsg = "window: no command"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    let workDir = guiWorkspaceActiveRoot(state)
    if guiSpawnDetached(cmd, workDir):
        state.statusMsg = "window: launched"
    else:
        state.statusMsg = "window: failed"
    state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
    return state

fn guiJoinShellArgs(args: str[]): str =
    var outVal: str = ""
    for idx in 0..<seqLenString(args):
        let arg = seqGetString(args, idx)
        if len(outVal) > 0:
            outVal = outVal + " "
        outVal = outVal + guiShellQuote(arg)
    return outVal

fn guiExtractFlagValue(args: str[], prefix: str): str =
    for idx in 0..<seqLenString(args):
        let arg = seqGetString(args, idx)
        if startsWithPrefix(arg, prefix):
            return sliceFrom(arg, len(prefix))
    return ""

fn guiDefaultChengName(path: str): str =
    let base = extractFilename(path)
    if endsWithSuffix(base, ".cheng"):
        return sliceRange(base, 0, len(base) - 7)
    return base

fn guiParseTaskInput(state: GuiState, tokens: str[], startIdx: int32): TaskInput =
    var outVal: TaskInput
    outVal.optionArgs = default[str[]]
    outVal.runArgs = default[str[]]
    var inRunArgs = false
    for idx in startIdx..<seqLenString(tokens):
        let tok = seqGetString(tokens, idx)
        if tok == "--":
            inRunArgs = true
            continue
        if ! inRunArgs && len(outVal.filePath) == 0 && len(tok) > 0 && tok[0] != '-':
            outVal.filePath = resolveWorkspacePath(state, tok)
        else:
            if inRunArgs:
                addPtr_string(&outVal.runArgs, tok)
            else:
                addPtr_string(&outVal.optionArgs, tok)
    if len(outVal.filePath) == 0 && len(state.editor.filePath) > 0:
        outVal.filePath = state.editor.filePath
    outVal.hasFile = len(outVal.filePath) > 0
    return outVal

fn guiReplaceAllText(text: str, needle: str, replacement: str): str =
    let res: ReplaceResult = replaceAllInLine(text, needle, replacement)
    return res.text

fn guiPathMatches(pathPart: str, filePath: str): bool =
    if len(pathPart) == 0:
        return true
    if len(filePath) == 0:
        return true
    let normPart = textutils.toForwardSlashes(pathPart)
    let normFile = textutils.toForwardSlashes(filePath)
    if normPart == normFile:
        return true
    let base = extractFilename(normFile)
    if len(base) > 0 && endsWithSuffix(normPart, base):
        return true
    if endsWithSuffix(normFile, normPart):
        return true
    return false

fn guiParseDiagOutput(output: str, filePath: str): diag.seq_GuiDiagnostic =
    var outVal: diag.seq_GuiDiagnostic = diag.guiDiagNewSeq_GuiDiagnostic(0, 0)
    let lines: str[] = splitLinesSimple(output)
    for idx in 0..<seqLenString(lines):
        let raw = trimLine(seqGetString(lines, idx))
        if len(raw) == 0:
            continue
        let c1: int32 = indexOfSubstr(raw, ":", 0)
        if c1 < 0:
            continue
        let c2: int32 = indexOfSubstr(raw, ":", c1 + 1)
        if c2 < 0:
            continue
        let c3: int32 = indexOfSubstr(raw, ":", c2 + 1)
        if c3 < 0:
            continue
        let pathPart = if c1 > 0: sliceRange(raw, 0, c1 - 1) else: ""
        if ! guiPathMatches(pathPart, filePath):
            continue
        let lineStr = if c2 > c1 + 1: sliceRange(raw, c1 + 1, c2 - 1) else: ""
        let colStr = if c3 > c2 + 1: sliceRange(raw, c2 + 1, c3 - 1) else: ""
        let lineVal: int32 = parseInt32(lineStr, 0)
        let colVal: int32 = parseInt32(colStr, 0)
        if lineVal <= 0:
            continue
        let msg = if c3 + 1 <= len(raw) - 1: trimLine(sliceRange(raw, c3 + 1, len(raw) - 1)) else: ""
        var sev: diag.GuiDiagSeverity = diag.gdsError
        let lowered = textutils.toLowerAscii(msg)
        if startsWithPrefix(lowered, "warning") || startsWithPrefix(lowered, "warn"):
            sev = diag.gdsWarning
        elif startsWithPrefix(lowered, "hint") || startsWithPrefix(lowered, "info"):
            sev = diag.gdsInfo
        diag.guiDiagAdd(&outVal, sev, lineVal - 1, maxInt(colVal - 1, 0), msg)
    return outVal

fn guiLangDiagCommand(state: GuiState, filePath: str): str =
    let override = getEnv("IDE_DIAG_CMD")
    let quoted = guiShellQuote(filePath)
    if len(override) > 0:
        if indexOfSubstr(override, "{file}", 0) >= 0:
            return guiReplaceAllText(override, "{file}", quoted)
        return override + " " + quoted
    let root = guiWorkspaceRootForResolved(state, filePath)
    let baseRoot = if len(root) > 0: root else: guiWorkspaceActiveRoot(state)
    let localChengc = joinPath(baseRoot, "src/tooling/chengc.sh")
    let outFile = guiShellQuote(".tmp_cheng_ide_diag.o")
    let driverEnv = "BACKEND_DRIVER_DIRECT=0 "
    if fileExists(localChengc):
        return driverEnv + guiShellQuote("./src/tooling/chengc.sh") + " " + quoted + " --emit-obj --obj-out:" + outFile
    let chengRoot = getEnv("ROOT")
    if len(chengRoot) > 0:
        let rootChengc = joinPath(chengRoot, "src/tooling/chengc.sh")
        if fileExists(rootChengc):
            return driverEnv + guiShellQuote(rootChengc) + " " + quoted + " --emit-obj --obj-out:" + outFile
    return ""

fn guiRunLanguageDiagnosticsExternal(state: GuiState): GuiState =
    if len(state.editor.filePath) == 0:
        state.statusMsg = "diag: no file"
        return state
    let cmd = guiLangDiagCommand(state, state.editor.filePath)
    if len(cmd) == 0:
        state.statusMsg = "diag: no runner"
        return state
    var next: GuiState = state
    if next.editor.dirty:
        next.terminal = pushTerminalLine(next.terminal, "diag: warning, unsaved changes")
    let root = guiWorkspaceRootForResolved(next, next.editor.filePath)
    let workDir = if len(root) > 0: root else: guiWorkspaceActiveRoot(state)
    var job: TaskJob
    job.kind = tkDiagnostics
    job.command = cmd
    job.workDir = workDir
    job.filePath = next.editor.filePath
    if next.taskRunner.active && next.taskRunner.job.kind == tkDiagnostics:
        next.diagPending = true
        next.statusMsg = "diag: queued"
        return next
    next.diagPending = false
    return guiTaskRunnerEnqueue(next, job)

fn guiRunLanguageDiagnostics(state: GuiState): GuiState =
    return guiRunLanguageDiagnosticsExternal(state)

fn guiTaskCommand(kind: str): str =
    if kind == "build":
        let cmd = getEnv("IDE_BUILD_CMD")
        if len(cmd) > 0:
            return cmd
        let chengRoot = getEnv("ROOT")
        let ideRoot = getEnv("IDE_ROOT")
        if len(chengRoot) > 0 && len(ideRoot) > 0:
            let script = joinPath(chengRoot, "cheng/tooling/build_ide_gui.sh")
            let outPath = joinPath(ideRoot, "build/main_local")
            return guiShellQuote(script) + " --out:" + guiShellQuote(outPath)
        return "./cheng/tooling/build_ide_gui.sh --out:./ide/main_local"
    if kind == "run":
        let cmd = getEnv("IDE_RUN_CMD")
        if len(cmd) > 0:
            return cmd
        let binOverride = getEnv("IDE_BIN")
        if len(binOverride) > 0:
            return guiShellQuote(binOverride) + " gui"
        let ideRoot = getEnv("IDE_ROOT")
        if len(ideRoot) > 0:
            let binPath = joinPath(ideRoot, "build/main_local")
            return guiShellQuote(binPath) + " gui"
        return "./ide/main_local gui"
    if kind == "test":
        let cmd = getEnv("IDE_TEST_CMD")
        if len(cmd) > 0:
            return cmd
        let chengRoot = getEnv("ROOT")
        if len(chengRoot) > 0:
            let script = joinPath(chengRoot, "cheng/tooling/bootstrap_pure.sh")
            return guiShellQuote(script) + " --fullspec"
        return "./cheng/tooling/bootstrap_pure.sh --fullspec"
    if kind == "package":
        let cmd = getEnv("IDE_PACKAGE_CMD")
        if len(cmd) > 0:
            return cmd
        let chengRoot = getEnv("ROOT")
        if len(chengRoot) > 0:
            let script = joinPath(chengRoot, "cheng/tooling/package_ide.sh")
            return guiShellQuote(script)
        return "./cheng/tooling/package_ide.sh"
    return ""

fn guiTaskRunWithDir(state: GuiState, command: str, workDir: str): GuiState =
    if len(command) == 0:
        return state
    var job: TaskJob
    job.kind = tkCommand
    job.command = command
    job.workDir = workDir
    return guiTaskRunnerEnqueue(state, job)

fn guiTaskRun(state: GuiState, command: str): GuiState =
    return guiTaskRunWithDir(state, command, "")

fn guiTaskShowHelp(state: GuiState): GuiState =
    state.terminal = pushTerminalLine(state.terminal, "commands: build, run, test, package, cheng <build|run>, mobile <export|android|ios>, diag, action [list|<idx>], search <text>, replace <find=>replace> [--project], fmt, refs [name], rename <old> <new> [--project], saveall, vcs, diff [path|--staged], blame [path|path:line|line], history [path|path:line|line], stage [path], unstage [path], commit <message>, branch, checkout <name>, switch <name>, conflicts, shell [cmd], shell stop, term [list|new|next|prev|switch <idx>|close], window [new|open <path>], debug, bp, watch, theme [dark|light], autosave [on|off], format-on-save [on|off], split [on|off], :exec <cmd>, !<cmd>")
    state.terminal = pushTerminalLine(state.terminal, "file: new <path>, mkdir <path>, rm <path>, mv <src> <dst>")
    state.terminal = pushTerminalLine(state.terminal, "cheng: build|run [file] [--name:<exe>] [--jobs:<N>] [-- <args>]")
    state.terminal = pushTerminalLine(state.terminal, "mobile: export|android|ios [file] [--name:<app>] [--out:<dir>] [--assets:<dir>] [--with-bridge] [--with-android-project] [--with-ios-project] [--with-projects]")
    state.terminal = pushTerminalLine(state.terminal, "debug: status/load/refresh/sync/clear/run/continue/step/next/pause/stop, bp add/del/clear, frames set/clear, vars set/clear, watch add/del/clear")
    state.terminal = pushTerminalLine(state.terminal, "codex: login <token>|logout|auth|approve|decline|open [path]|new [preview]|connect|interrupt|ask <text>|asksel|askfile|review <text>|reviewsel|reviewfile|todo|add <text>|addsel|addfile|exec <text>|preview <path>|previewdiff|apply <path>|applydiff|status <text>|threads|sessions|use <id>|resume <id>|stop|clear")
    state.terminal = pushTerminalLine(state.terminal, "env: IDE_ROOT, IDE_ROOTS, IDE_OPEN, IDE_NEW_WINDOW_CMD, IDE_BUILD_CMD, IDE_RUN_CMD, IDE_TEST_CMD, IDE_PACKAGE_CMD, IDE_DIAG_CMD, IDE_DEBUG_CMD (uses {action}/{args}/{breakpoints}/{watches}), IDE_DIAG_AUTO, IDE_AUTOSAVE, IDE_FORMAT_ON_SAVE, IDE_RECOVERY, IDE_RECOVERY_BYTES, IDE_THEME, IDE_BRIDGE, IDE_BRIDGE_PATH, IDE_COMMAND, IDE_COMMAND_PATH, IDE_COMMAND_ACK_PATH, IDE_COMMAND_POLL_MS, CODEX_CLI, CODEX_TODO_LENS, CODEX_LANGUAGE, CODEX_START_FOCUS, CODEX_WSL, IDE_CLIPBOARD_SET, IDE_CLIPBOARD_GET, IDE_CLIPBOARD_TMP, IDE_WORKSPACE_CONFIG")
    return state

fn guiTaskHandleInput(state: GuiState, input: str): GuiState =
    let trimmed = trimLine(input)
    if len(trimmed) == 0:
        return state
    if trimmed[0] == '!':
        let cmd = if len(trimmed) > 1: sliceFrom(trimmed, 1) else: ""
        return guiTaskRun(state, cmd)
    var raw = trimmed
    if raw[0] == ':':
        raw = if len(raw) > 1: sliceFrom(raw, 1) else: ""
    let lowered = textutils.toLowerAscii(raw)
    if lowered == "help":
        return guiTaskShowHelp(state)
    if lowered == "codex" || lowered == "ai":
        var next: GuiState = guiCodexShow(state)
        next.statusMsg = "codex: open"
        return next
    if startsWithPrefix(lowered, "codex "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            var next: GuiState = guiCodexShow(state)
            next.statusMsg = "codex: open"
            return next
        let sub = textutils.toLowerAscii(seqGetString(tokens, 0))
        if sub == "open" || sub == "show":
            if seqLenString(tokens) > 1:
                let target = joinTokens(tokens, 1)
                return guiCodexOpenTarget(state, target)
            var next: GuiState = guiCodexShow(state)
            next.statusMsg = "codex: open"
            return next
        if sub == "clear" || sub == "reset":
            var next: GuiState = guiCodexShow(state)
            next = guiCodexClear(next)
            return next
        if sub == "status":
            let statusText = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            var next: GuiState = guiCodexShow(state)
            next.codex.status = if len(statusText) > 0: statusText else: "ready"
            next.statusMsg = "codex: status"
            return next
        if sub == "auth" || sub == "whoami":
            return guiCodexAppendAuthStatus(state)
        if sub == "login" || sub == "signin":
            let token = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            if len(token) == 0:
                return guiCodexStartLoginFlow(state)
            return guiCodexLogin(state, token)
        if sub == "logout" || sub == "signout":
            return guiCodexLogout(state)
        if sub == "approve" || sub == "accept":
            return guiCodexApprove(state)
        if sub == "decline" || sub == "deny":
            return guiCodexDecline(state)
        if sub == "new" || sub == "new-session" || sub == "newsession":
            let preview = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiCodexNewThread(state, preview)
        if sub == "connect" || sub == "start" || sub == "on":
            return guiCodexConnect(state)
        if sub == "stop" || sub == "disconnect" || sub == "off":
            return guiCodexStop(state, "")
        if sub == "interrupt" || sub == "cancel":
            return guiCodexInterrupt(state)
        if sub == "addsel" || sub == "add-selection":
            return guiCodexAddSelection(state)
        if sub == "asksel" || sub == "ask-selection":
            return guiCodexAskSelection(state)
        if sub == "addfile" || sub == "add-file":
            return guiCodexAddFile(state)
        if sub == "askfile" || sub == "ask-file":
            return guiCodexAskFile(state)
        if sub == "todo":
            return guiCodexTodo(state)
        if sub == "preview":
            let path = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            if len(path) == 0:
                state.statusMsg = "codex: preview <path>"
                return state
            return guiCodexPreviewPatch(state, path)
        if sub == "previewdiff" || sub == "preview-last" || sub == "previewlast":
            return guiCodexPreviewLastDiff(state)
        if sub == "use" || sub == "thread":
            let threadId = if seqLenString(tokens) > 1: seqGetString(tokens, 1) else: ""
            if len(threadId) == 0:
                state.statusMsg = "codex: use <id>"
                return state
            return guiCodexSelectThread(state, threadId)
        if sub == "resume":
            let threadId = if seqLenString(tokens) > 1: seqGetString(tokens, 1) else: ""
            if len(threadId) == 0:
                state.statusMsg = "codex: resume <id>"
                return state
            return guiCodexResumeThread(state, threadId)
        if sub == "threads" || sub == "list":
            return guiCodexListThreads(state)
        if sub == "sessions" || sub == "session":
            return guiCodexListThreads(state)
        if sub == "ask" || sub == "chat":
            let text = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            if len(text) == 0:
                state.statusMsg = "codex: ask <text>"
                return state
            return guiCodexAsk(state, text)
        if sub == "review":
            let text = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            if len(text) == 0:
                state.statusMsg = "codex: review <text>"
                return state
            return guiCodexReview(state, text)
        if sub == "reviewsel" || sub == "review-selection":
            return guiCodexReviewSelection(state)
        if sub == "reviewfile" || sub == "review-file":
            return guiCodexReviewFile(state)
        if sub == "apply":
            let path = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            if len(path) == 0:
                state.statusMsg = "codex: apply <path>"
                return state
            return guiCodexApply(state, path)
        if sub == "applydiff" || sub == "apply-last" || sub == "applylast":
            return guiCodexApplyLastDiff(state)
        if sub == "file" || sub == "goto":
            let target = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            if len(target) == 0:
                state.statusMsg = "codex: open <path[:line[:col]]>"
                return state
            return guiCodexOpenTarget(state, target)
        if sub == "add" || sub == "say":
            let text = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            if len(text) == 0:
                state.statusMsg = "codex: add <text>"
                return state
            return guiCodexAddText(state, text)
        if sub == "exec" || sub == "run":
            let text = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            if len(text) == 0:
                state.statusMsg = "codex: exec <text>"
                return state
            return guiCodexExec(state, text)
        if sub == "help":
            var next: GuiState = guiCodexShow(state)
            next.terminal = pushTerminalLine(next.terminal, "codex: login <token>|logout|auth|approve|decline|open [path]|new [preview]|connect|interrupt|ask <text>|asksel|askfile|review <text>|reviewsel|reviewfile|todo|add <text>|addsel|addfile|exec <text>|preview <path>|previewdiff|apply <path>|applydiff|status <text>|threads|sessions|use <id>|resume <id>|stop|clear")
            next.statusMsg = "codex: help"
            return next
        state.statusMsg = "codex: unknown"
        return state
    if startsWithPrefix(lowered, "exec "):
        let cmd = if len(raw) > 5: sliceFrom(raw, 5) else: ""
        return guiTaskRun(state, cmd)
    if lowered == "build":
        return guiTaskRun(state, guiTaskCommand("build"))
    if lowered == "run":
        return guiTaskRun(state, guiTaskCommand("run"))
    if lowered == "test":
        return guiTaskRun(state, guiTaskCommand("test"))
    if startsWithPrefix(lowered, "cheng "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            state.terminal = pushTerminalLine(state.terminal, "cheng: build|run [file] [--name:<exe>] [--jobs:<N>] [-- <args>]")
            return state
        let sub = textutils.toLowerAscii(seqGetString(tokens, 0))
        let input: TaskInput = guiParseTaskInput(state, tokens, 1)
        if ! input.hasFile:
            state.statusMsg = "cheng: no file"
            return state
        if ! fileExists(input.filePath):
            state.statusMsg = "cheng: file not found"
            return state
        if state.editor.dirty && state.editor.filePath == input.filePath:
            state.terminal = pushTerminalLine(state.terminal, "cheng: warning, unsaved changes")
        let root = guiWorkspaceRootForResolved(state, input.filePath)
        let workDir = if len(root) > 0: root else: guiWorkspaceActiveRoot(state)
        var args: str[] = default[str[]]
        addPtr_string(&args, input.filePath)
        for idx in 0..<seqLenString(input.optionArgs):
            addPtr_string(&args, seqGetString(input.optionArgs, idx))
        if sub == "build" || sub == "compile":
            let cmd = "./cheng/tooling/chengc.sh " + guiJoinShellArgs(args)
            return guiTaskRunWithDir(state, cmd, workDir)
        if sub == "run":
            let nameFlag = guiExtractFlagValue(input.optionArgs, "--name:")
            let exeName = if len(nameFlag) > 0: nameFlag else: guiDefaultChengName(input.filePath)
            var runCmd: str = guiShellQuote("./" + exeName)
            if seqLenString(input.runArgs) > 0:
                runCmd = runCmd + " " + guiJoinShellArgs(input.runArgs)
            let cmd = "./cheng/tooling/chengc.sh " + guiJoinShellArgs(args) + " && " + runCmd
            return guiTaskRunWithDir(state, cmd, workDir)
        state.terminal = pushTerminalLine(state.terminal, "cheng: build|run [file] [--name:<exe>] [--jobs:<N>] [-- <args>]")
        return state
    if startsWithPrefix(lowered, "mobile "):
        let arg = if len(raw) > 7: sliceFrom(raw, 7) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            state.terminal = pushTerminalLine(state.terminal, "mobile: export|android|ios [file] [--name:<app>] [--out:<dir>] [--assets:<dir>] [--with-bridge] [--with-android-project] [--with-ios-project] [--with-projects]")
            return state
        let sub = textutils.toLowerAscii(seqGetString(tokens, 0))
        let input: TaskInput = guiParseTaskInput(state, tokens, 1)
        if ! input.hasFile:
            state.statusMsg = "mobile: no file"
            return state
        if ! fileExists(input.filePath):
            state.statusMsg = "mobile: file not found"
            return state
        if state.editor.dirty && state.editor.filePath == input.filePath:
            state.terminal = pushTerminalLine(state.terminal, "mobile: warning, unsaved changes")
        let root = guiWorkspaceRootForResolved(state, input.filePath)
        let workDir = if len(root) > 0: root else: guiWorkspaceActiveRoot(state)
        var args: str[] = default[str[]]
        addPtr_string(&args, input.filePath)
        for idx in 0..<seqLenString(input.optionArgs):
            addPtr_string(&args, seqGetString(input.optionArgs, idx))
        if sub == "export":
            let cmd = "./cheng/tooling/build_mobile_export.sh " + guiJoinShellArgs(args)
            return guiTaskRunWithDir(state, cmd, workDir)
        if sub == "android":
            let cmd = "./cheng/tooling/mobile_ci_android.sh " + guiJoinShellArgs(args)
            return guiTaskRunWithDir(state, cmd, workDir)
        if sub == "ios":
            let cmd = "./cheng/tooling/mobile_ci_ios.sh " + guiJoinShellArgs(args)
            return guiTaskRunWithDir(state, cmd, workDir)
        state.terminal = pushTerminalLine(state.terminal, "mobile: export|android|ios [file] [--name:<app>] [--out:<dir>] [--assets:<dir>] [--with-bridge] [--with-android-project] [--with-ios-project] [--with-projects]")
        return state
    if lowered == "diag" || lowered == "diagnose" || lowered == "lint":
        return guiRunLanguageDiagnostics(state)
    if lowered == "action" || lowered == "fix" || lowered == "quickfix":
        return guiApplyQuickFixAtCursor(state)
    if startsWithPrefix(lowered, "action ") || startsWithPrefix(lowered, "fix ") || startsWithPrefix(lowered, "quickfix "):
        var arg = ""
        if startsWithPrefix(lowered, "action "):
            arg = sliceFrom(raw, 7)
        elif startsWithPrefix(lowered, "fix "):
            arg = sliceFrom(raw, 4)
        else:
            arg = sliceFrom(raw, 9)
        let trimmedArg: str = trimLine(arg)
        let tokens: str[] = splitCommandArgs(trimmedArg)
        if seqLenString(tokens) == 0:
            return guiApplyQuickFixAtCursor(state)
        let sub = textutils.toLowerAscii(seqGetString(tokens, 0))
        if sub == "list":
            return guiListQuickFixesAtCursor(state)
        if isAllDigits(sub):
            let idxVal: int32 = parseInt32(sub, 1) - 1
            return guiApplyQuickFixAtCursorIndex(state, idxVal)
        return guiApplyQuickFixAtCursor(state)
    if lowered == "theme":
        return guiToggleTheme(state)
    if startsWithPrefix(lowered, "theme "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        return guiSetTheme(state, arg)
    if lowered == "autosave":
        return guiToggleAutoSave(state)
    if startsWithPrefix(lowered, "autosave "):
        let arg = if len(raw) > 9: sliceFrom(raw, 9) else: ""
        return guiSetAutoSaveFromInput(state, arg)
    if lowered == "format-on-save" || lowered == "fmt-on-save":
        return guiToggleFormatOnSave(state)
    if startsWithPrefix(lowered, "format-on-save "):
        let arg = if len(raw) > 15: sliceFrom(raw, 15) else: ""
        return guiSetFormatOnSaveFromInput(state, arg)
    if startsWithPrefix(lowered, "fmt-on-save "):
        let arg = if len(raw) > 11: sliceFrom(raw, 11) else: ""
        return guiSetFormatOnSaveFromInput(state, arg)
    if lowered == "split":
        return guiToggleSplit(state)
    if startsWithPrefix(lowered, "split "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        return guiSetSplitFromInput(state, arg)
    if lowered == "window" || lowered == "new-window":
        return guiOpenNewWindow(state, "")
    if startsWithPrefix(lowered, "window "):
        let arg = if len(raw) > 7: sliceFrom(raw, 7) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            return guiOpenNewWindow(state, "")
        let sub = textutils.toLowerAscii(seqGetString(tokens, 0))
        if sub == "new":
            return guiOpenNewWindow(state, "")
        if sub == "open" || sub == "file":
            let pathArg = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiOpenNewWindow(state, pathArg)
        return guiOpenNewWindow(state, arg)
    if lowered == "shell" || lowered == "pty":
        return guiPtyStart(state, "")
    if startsWithPrefix(lowered, "shell "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        let trimmedArg = trimLine(arg)
        let sub = textutils.toLowerAscii(trimmedArg)
        if sub == "stop" || sub == "exit" || sub == "close":
            return guiPtyStop(state, "stopped")
        return guiPtyStart(state, arg)
    if lowered == "term" || lowered == "terminal":
        return guiTerminalListSessions(state)
    if startsWithPrefix(lowered, "term "):
        let arg = if len(raw) > 5: sliceFrom(raw, 5) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            return guiTerminalListSessions(state)
        let sub = textutils.toLowerAscii(seqGetString(tokens, 0))
        if sub == "new" || sub == "add":
            return guiTerminalNewSession(state)
        if sub == "next":
            return guiTerminalNextSession(state)
        if sub == "prev" || sub == "previous":
            return guiTerminalPrevSession(state)
        if sub == "close" || sub == "del" || sub == "rm":
            return guiTerminalCloseSession(state)
        if sub == "list":
            return guiTerminalListSessions(state)
        if sub == "switch" || sub == "use":
            if seqLenString(tokens) > 1:
                let idxText = seqGetString(tokens, 1)
                if isAllDigits(idxText):
                    let idxVal: int32 = parseInt32(idxText, 1) - 1
                    return guiTerminalSwitchSession(state, idxVal)
            state.statusMsg = "terminal: switch <idx>"
            return state
        if isAllDigits(sub):
            let idxVal: int32 = parseInt32(sub, 1) - 1
            return guiTerminalSwitchSession(state, idxVal)
        state.statusMsg = "terminal: unknown"
        return state
    if startsWithPrefix(lowered, "terminal "):
        let arg = if len(raw) > 9: sliceFrom(raw, 9) else: ""
        return guiTaskHandleInput(state, "term " + arg)
    if lowered == "debug":
        return guiDebuggerHelp(state)
    if startsWithPrefix(lowered, "debug "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            return guiDebuggerHelp(state)
        let cmd = textutils.toLowerAscii(seqGetString(tokens, 0))
        if cmd == "status":
            let status = if seqLenString(tokens) > 1: seqGetString(tokens, 1) else: ""
            let reason = if seqLenString(tokens) > 2: joinTokens(tokens, 2) else: ""
            return guiDebuggerSetStatus(state, status, reason)
        if cmd == "load":
            let pathArg = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiDebuggerLoad(state, pathArg)
        if cmd == "refresh":
            return guiDebuggerRefresh(state)
        if cmd == "sync":
            return guiDebugBackendRun(state, "sync", "")
        if cmd == "clear":
            return guiDebuggerClear(state)
        if cmd == "run" || cmd == "start":
            let rest = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiDebugBackendRun(state, "run", rest)
        if cmd == "continue" || cmd == "cont" || cmd == "c":
            let rest = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiDebugBackendRun(state, "continue", rest)
        if cmd == "step" || cmd == "s":
            let rest = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiDebugBackendRun(state, "step", rest)
        if cmd == "next" || cmd == "n":
            let rest = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiDebugBackendRun(state, "next", rest)
        if cmd == "pause":
            let rest = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiDebugBackendRun(state, "pause", rest)
        if cmd == "stop":
            let rest = if seqLenString(tokens) > 1: joinTokens(tokens, 1) else: ""
            return guiDebugBackendRun(state, "stop", rest)
        if cmd == "frames":
            let sub = if seqLenString(tokens) > 1: textutils.toLowerAscii(seqGetString(tokens, 1)) else: ""
            if sub == "clear":
                state.debugger.frames = default[str[]]
                state.statusMsg = "frames: cleared"
                return state
            state.debugger.frames = default[str[]]
            let startIdx: int32 = if sub == "set": 2 else: 1
            for idx in startIdx..<seqLenString(tokens):
                addPtr_string(&state.debugger.frames, seqGetString(tokens, idx))
            state.statusMsg = "frames: " + intToStr(seqLenString(state.debugger.frames))
            return state
        if cmd == "vars" || cmd == "variables":
            let sub = if seqLenString(tokens) > 1: textutils.toLowerAscii(seqGetString(tokens, 1)) else: ""
            if sub == "clear":
                state.debugger.variables = default[str[]]
                state.statusMsg = "vars: cleared"
                return state
            state.debugger.variables = default[str[]]
            let startIdx: int32 = if sub == "set": 2 else: 1
            for idx in startIdx..<seqLenString(tokens):
                addPtr_string(&state.debugger.variables, seqGetString(tokens, idx))
            state.statusMsg = "vars: " + intToStr(seqLenString(state.debugger.variables))
            return state
        return guiDebuggerHelp(state)
    if lowered == "bp" || lowered == "break" || lowered == "breakpoint":
        return guiDebuggerAddBreakpoint(state, "")
    if startsWithPrefix(lowered, "bp ") || startsWithPrefix(lowered, "break ") || startsWithPrefix(lowered, "breakpoint "):
        var arg = ""
        if startsWithPrefix(lowered, "bp "):
            arg = sliceFrom(raw, 3)
        elif startsWithPrefix(lowered, "break "):
            arg = sliceFrom(raw, 6)
        else:
            arg = sliceFrom(raw, 11)
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            return guiDebuggerAddBreakpoint(state, "")
        let sub = textutils.toLowerAscii(seqGetString(tokens, 0))
        if sub == "add":
            return guiDebuggerAddBreakpoint(state, joinTokens(tokens, 1))
        if sub == "del" || sub == "rm" || sub == "remove":
            return guiDebuggerRemoveBreakpoint(state, joinTokens(tokens, 1))
        if sub == "clear":
            state.debugger.breakpoints = default[str[]]
            state.statusMsg = "bp: cleared"
            return state
        if sub == "list":
            let count: int32 = seqLenString(state.debugger.breakpoints)
            state.terminal = pushTerminalLine(state.terminal, "breakpoints: " + intToStr(count))
            for idx in 0..<count:
                let line = intToStr(idx + 1) + ". " + seqGetString(state.debugger.breakpoints, idx)
                state.terminal = pushTerminalLine(state.terminal, line)
            return state
        return guiDebuggerAddBreakpoint(state, arg)
    if lowered == "watch" || lowered == "watches":
        return guiDebuggerListWatches(state)
    if startsWithPrefix(lowered, "watch "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            return guiDebuggerListWatches(state)
        let sub = textutils.toLowerAscii(seqGetString(tokens, 0))
        if sub == "add":
            return guiDebuggerAddWatch(state, joinTokens(tokens, 1))
        if sub == "del" || sub == "rm" || sub == "remove":
            return guiDebuggerRemoveWatch(state, joinTokens(tokens, 1))
        if sub == "clear":
            state.debugger.watches = default[str[]]
            state.statusMsg = "watch: cleared"
            return state
        if sub == "list":
            return guiDebuggerListWatches(state)
        return guiDebuggerAddWatch(state, arg)
    if lowered == "vcs" || lowered == "git" || lowered == "git status":
        return guiVcsRefresh(state)
    if lowered == "diff":
        let res: VcsCommand = guiVcsDiffCommand(state, "")
        return guiTaskRunWithDir(state, res.cmd, res.workDir)
    if startsWithPrefix(lowered, "diff "):
        let arg = if len(raw) > 5: sliceFrom(raw, 5) else: ""
        let res: VcsCommand = guiVcsDiffCommand(state, arg)
        return guiTaskRunWithDir(state, res.cmd, res.workDir)
    if lowered == "blame":
        return guiVcsBlame(state, "")
    if startsWithPrefix(lowered, "blame "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        return guiVcsBlame(state, arg)
    if lowered == "history" || lowered == "log":
        return guiVcsHistory(state, "")
    if startsWithPrefix(lowered, "history "):
        let arg = if len(raw) > 8: sliceFrom(raw, 8) else: ""
        return guiVcsHistory(state, arg)
    if startsWithPrefix(lowered, "log "):
        let arg = if len(raw) > 4: sliceFrom(raw, 4) else: ""
        return guiVcsHistory(state, arg)
    if lowered == "stage" || lowered == "add":
        return guiVcsStage(state, "")
    if startsWithPrefix(lowered, "stage "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        return guiVcsStage(state, parseSingleArg(arg))
    if startsWithPrefix(lowered, "add "):
        let arg = if len(raw) > 4: sliceFrom(raw, 4) else: ""
        return guiVcsStage(state, parseSingleArg(arg))
    if lowered == "unstage" || lowered == "reset":
        return guiVcsUnstage(state, "")
    if startsWithPrefix(lowered, "unstage "):
        let arg = if len(raw) > 8: sliceFrom(raw, 8) else: ""
        return guiVcsUnstage(state, parseSingleArg(arg))
    if startsWithPrefix(lowered, "reset "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        return guiVcsUnstage(state, parseSingleArg(arg))
    if lowered == "commit":
        return guiVcsCommit(state, "")
    if startsWithPrefix(lowered, "commit "):
        let message = if len(raw) > 7: sliceFrom(raw, 7) else: ""
        return guiVcsCommit(state, message)
    if lowered == "branch":
        return guiVcsListBranches(state)
    if startsWithPrefix(lowered, "branch "):
        let arg = if len(raw) > 7: sliceFrom(raw, 7) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        if seqLenString(tokens) == 0:
            return guiVcsListBranches(state)
        let first = textutils.toLowerAscii(seqGetString(tokens, 0))
        if first == "new" || first == "create":
            let name = if seqLenString(tokens) > 1: seqGetString(tokens, 1) else: ""
            return guiVcsCreateBranch(state, name)
        if first == "delete" || first == "del" || first == "remove":
            let name = if seqLenString(tokens) > 1: seqGetString(tokens, 1) else: ""
            return guiVcsDeleteBranch(state, name, false)
        if first == "-d" || first == "-D":
            let name = if seqLenString(tokens) > 1: seqGetString(tokens, 1) else: ""
            return guiVcsDeleteBranch(state, name, first == "-D")
        if seqLenString(tokens) == 1:
            return guiVcsCreateBranch(state, seqGetString(tokens, 0))
        return guiVcsListBranches(state)
    if lowered == "checkout":
        return guiVcsCheckout(state, "")
    if startsWithPrefix(lowered, "checkout "):
        let name = if len(raw) > 9: sliceFrom(raw, 9) else: ""
        return guiVcsCheckout(state, name)
    if lowered == "switch":
        return guiVcsSwitch(state, "")
    if startsWithPrefix(lowered, "switch "):
        let name = if len(raw) > 7: sliceFrom(raw, 7) else: ""
        return guiVcsSwitch(state, name)
    if lowered == "conflicts":
        return guiVcsListConflicts(state)
    if lowered == "search" || lowered == "find":
        return applySearchProject(state, wordAtCursor(state.editor))
    if startsWithPrefix(lowered, "search "):
        let arg = if len(raw) > 7: sliceFrom(raw, 7) else: ""
        return applySearchProject(state, arg)
    if startsWithPrefix(lowered, "find "):
        let arg = if len(raw) > 5: sliceFrom(raw, 5) else: ""
        return applySearchProject(state, arg)
    if lowered == "replace":
        state.statusMsg = "replace: missing"
        return state
    if startsWithPrefix(lowered, "replace "):
        let arg = if len(raw) > 8: sliceFrom(raw, 8) else: ""
        let tokens: str[] = splitCommandArgs(arg)
        var projectReplace = false
        var cleaned: str[] = default[str[]]
        for idx in 0..<seqLenString(tokens):
            let token = seqGetString(tokens, idx)
            let loweredToken = textutils.toLowerAscii(token)
            if loweredToken == "--project" || loweredToken == "-p":
                projectReplace = true
            else:
                addPtr_string(&cleaned, token)
        let normalized = joinTokens(cleaned, 0)
        let parsed: ReplaceResult = parseReplaceInput(normalized)
        if parsed.count < 0:
            state.statusMsg = "replace: invalid"
            return state
        let sepIdx: int32 = indexOfSubstr(parsed.text, "\n", 0)
        if sepIdx < 0:
            state.statusMsg = "replace: invalid"
            return state
        let needle = if sepIdx > 0: sliceRange(parsed.text, 0, sepIdx - 1) else: ""
        let repl = if sepIdx + 1 <= len(parsed.text) - 1: sliceRange(parsed.text, sepIdx + 1, len(parsed.text) - 1) else: ""
        if projectReplace:
            return replaceAllProject(state, needle, repl)
        return replaceAll(state, needle, repl)
    if lowered == "fmt" || lowered == "format":
        return guiFormatSelectionOrFile(state)
    if lowered == "refs" || lowered == "references":
        return guiShowReferences(state, "")
    if startsWithPrefix(lowered, "refs "):
        let arg = if len(raw) > 5: sliceFrom(raw, 5) else: ""
        return guiShowReferences(state, arg)
    if lowered == "rename":
        return guiRenameFromInput(state, "")
    if startsWithPrefix(lowered, "rename "):
        let arg = if len(raw) > 7: sliceFrom(raw, 7) else: ""
        return guiRenameFromInput(state, arg)
    if lowered == "saveall" || lowered == "save-all":
        return saveAllBuffers(state)
    if lowered == "new" || lowered == "touch":
        return guiCreateFile(state, "")
    if startsWithPrefix(lowered, "new "):
        let arg = if len(raw) > 4: sliceFrom(raw, 4) else: ""
        return guiCreateFile(state, parseSingleArg(arg))
    if startsWithPrefix(lowered, "touch "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        return guiCreateFile(state, parseSingleArg(arg))
    if lowered == "mkdir" || lowered == "md":
        return guiMakeDir(state, "")
    if startsWithPrefix(lowered, "mkdir "):
        let arg = if len(raw) > 6: sliceFrom(raw, 6) else: ""
        return guiMakeDir(state, parseSingleArg(arg))
    if startsWithPrefix(lowered, "md "):
        let arg = if len(raw) > 3: sliceFrom(raw, 3) else: ""
        return guiMakeDir(state, parseSingleArg(arg))
    if lowered == "rm" || lowered == "del":
        return guiDeleteFile(state, "")
    if startsWithPrefix(lowered, "rm "):
        let arg = if len(raw) > 3: sliceFrom(raw, 3) else: ""
        return guiDeleteFile(state, parseSingleArg(arg))
    if startsWithPrefix(lowered, "del "):
        let arg = if len(raw) > 4: sliceFrom(raw, 4) else: ""
        return guiDeleteFile(state, parseSingleArg(arg))
    if lowered == "mv" || lowered == "move":
        return guiMoveFile(state, "", "")
    if startsWithPrefix(lowered, "mv "):
        let arg = if len(raw) > 3: sliceFrom(raw, 3) else: ""
        let parsed: MoveArgs = parseMoveArgs(arg)
        return guiMoveFile(state, parsed.src, parsed.dst)
    if startsWithPrefix(lowered, "move "):
        let arg = if len(raw) > 5: sliceFrom(raw, 5) else: ""
        let parsed: MoveArgs = parseMoveArgs(arg)
        return guiMoveFile(state, parsed.src, parsed.dst)
    return state

fn commitTerminalInputWithTasks(state: GuiState): GuiState =
    if state.terminal.mode == tmPty:
        return guiPtySendInput(state, state.terminal.input)
    let input: str = state.terminal.input
    if len(input) > 0:
        state.terminal = pushTerminalLine(state.terminal, input)
    state.terminal.input = ""
    return guiTaskHandleInput(state, input)

fn insertTerminalText(state: TerminalState, text: str): TerminalState =
    if len(text) == 0:
        return state
    for idx in 0..<len(text):
        let ch: char = text[idx]
        if ch == '\r' || ch == '\n':
            0
        elif ch == '\x08':
            if len(state.input) > 0:
                state.input = slicePrefix(state.input, len(state.input) - 1)
        else:
            state.input = state.input + charToStr(ch)
    return state

fn terminalBackspace(state: TerminalState): TerminalState =
    if len(state.input) == 0:
        return state
    if len(state.input) == 1:
        state.input = ""
        return state
    state.input = slicePrefix(state.input, len(state.input) - 1)
    return state

fn codexInputBackspace(state: CodexState): CodexState =
    if len(state.input) == 0:
        return state
    if len(state.input) == 1:
        state.input = ""
        state.inputHistoryIndex = -1
        return state
    state.input = slicePrefix(state.input, len(state.input) - 1)
    state.inputHistoryIndex = -1
    return state

fn overlayBackspace(state: OverlayState): OverlayState =
    if len(state.input) == 0:
        return state
    if len(state.input) == 1:
        state.input = ""
        return state
    state.input = slicePrefix(state.input, len(state.input) - 1)
    return state

fn codexInputInsertText(state: CodexState, text: str): CodexState =
    if len(text) == 0:
        return state
    for idx in 0..<len(text):
        let ch: char = text[idx]
        if ch == '\r' || ch == '\n':
            0
        elif ch == '\x08' || ch == '\x7f':
            state = codexInputBackspace(state)
        else:
            state.input = state.input + charToStr(ch)
            state.inputHistoryIndex = -1
    return state

fn overlayInsertText(state: OverlayState, text: str): OverlayState =
    if len(text) == 0:
        return state
    for idx in 0..<len(text):
        let ch: char = text[idx]
        if ch == '\r' || ch == '\n':
            0
        elif ch == '\x08' || ch == '\x7f':
            state = overlayBackspace(state)
        else:
            state.input = state.input + charToStr(ch)
    return state

fn overlayPrompt(kind: OverlayKind): str =
    case kind:
        of okOpen:
            return "Open: "
        of okSave:
            return "Save As: "
        of okNewFile:
            return "New File: "
        of okNewFolder:
            return "New Folder: "
        of okSearch:
            return "Find: "
        of okGoto:
            return "Go to line: "
        of okReplace:
            return "Replace: find=>replace "
        of okSymbol:
            return "Go to symbol: "
        of okWorkspaceSymbol:
            return "Go to workspace symbol: "
        of okCommand:
            return "Command: "
        of okCloseDirty:
            return "Close dirty buffer (y=close s=save): "
        else:
            return ""

fn startOverlay(state: GuiState, kind: OverlayKind): GuiState =
    state.overlay.kind = kind
    state.overlay.prevFocus = state.focus
    if kind == okSearch:
        state.overlay.input = state.search.query
    elif kind == okSymbol || kind == okWorkspaceSymbol:
        state.overlay.input = wordAtCursor(state.editor)
    else:
        state.overlay.input = ""
    state.completion.active = false
    return state

fn cancelOverlay(state: GuiState): GuiState =
    let prev: FocusKind = state.overlay.prevFocus
    let wasClose: bool = state.overlay.kind == okCloseDirty
    state.overlay.kind = okNone
    state.overlay.input = ""
    state.focus = prev
    if wasClose:
        state.pendingQuit = false
    return state

fn saveEditor(state: GuiState): GuiState =
    if len(state.editor.filePath) == 0:
        state.statusMsg = "save failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    if state.formatOnSave && shouldFormatOnSave(state.editor.filePath):
        state = guiFormatEditor(state)
    let content = joinLines(state.editor.lines)
    writeFile(state.editor.filePath, content)
    state.editor.dirty = false
    state = guiCodexSyncDraftFromEditor(state)
    state = guiRecoveryClearForPath(state, state.editor.filePath)
    state = guiInvalidateProjectIndex(state)
    state = guiRevealExplorerPath(state, state.editor.filePath)
    state = guiVcsRefreshSilent(state)
    state.statusMsg = "saved: " + state.editor.filePath
    state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
    state = guiWorkspaceStateSave(state)
    return state

fn saveEditorAuto(state: GuiState): GuiState =
    if len(state.editor.filePath) == 0:
        return state
    if ! state.editor.dirty:
        return state
    if state.formatOnSave && shouldFormatOnSave(state.editor.filePath):
        state = guiFormatEditor(state)
    let content = joinLines(state.editor.lines)
    writeFile(state.editor.filePath, content)
    state.editor.dirty = false
    state = guiCodexSyncDraftFromEditor(state)
    state = guiRecoveryClearForPath(state, state.editor.filePath)
    state = guiInvalidateProjectIndex(state)
    state = guiRevealExplorerPath(state, state.editor.filePath)
    state = guiVcsRefreshSilent(state)
    state.statusMsg = "autosave: " + state.editor.filePath
    return state

fn saveAllBuffers(state: GuiState): GuiState =
    var next: GuiState = syncActiveBuffer(state)
    var saved: int32 = 0
    var skipped: int32 = 0
    for idx in 0..<bufferLen(next.buffers):
        var buffer: EditorState = bufferGet(next.buffers, idx)
        if buffer.dirty:
            if len(buffer.filePath) == 0:
                skipped = skipped + 1
            else:
                if next.formatOnSave && shouldFormatOnSave(buffer.filePath):
                    let res: FormatResult = guiFormatLines(buffer.lines)
                    if res.changed:
                        buffer.lines = res.lines
                        if idx == next.activeBuffer:
                            next.editor = buffer
                            next = guiSetDiagnosticsDirty(next)
                            buffer = next.editor
                        else:
                            buffer.bufferVersion = buffer.bufferVersion + 1
                            buffer = invalidateSemanticState(buffer, true)
                            buffer.outlineReady = false
                            buffer.outlineEntries = default[str[]]
                writeFile(buffer.filePath, joinLines(buffer.lines))
                buffer.dirty = false
                bufferSet(&next.buffers, idx, buffer)
                if idx == next.activeBuffer:
                    next.editor = buffer
                next = guiRecoveryClearForPath(next, buffer.filePath)
                saved = saved + 1
    if saved > 0:
        next = guiInvalidateProjectIndex(next)
        next = guiVcsRefreshSilent(next)
        next.statusMsg = "save all: " + intToStr(saved)
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        if skipped > 0:
            next.terminal = pushTerminalLine(next.terminal, "save all: skipped " + intToStr(skipped))
        next = guiWorkspaceStateSave(next)
        return next
    if skipped > 0:
        next.statusMsg = "save all: skipped " + intToStr(skipped)
        return next
    next.statusMsg = "save all: none"
    return next

fn saveEditorAs(state: GuiState, path: str): GuiState =
    let resolved = resolveWorkspacePath(state, trimLine(path))
    if len(resolved) == 0:
        state.statusMsg = "save failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    let oldPath: str = state.editor.filePath
    state.editor.filePath = resolved
    var next: GuiState = saveEditor(state)
    if len(oldPath) > 0 && oldPath != resolved:
        next = guiRecoveryClearForPath(next, oldPath)
    return next

fn openEditorPath(state: GuiState, path: str): GuiState =
    let resolved = resolveWorkspacePath(state, trimLine(path))
    if len(resolved) == 0:
        state.statusMsg = "open failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    if ! fileExists(resolved):
        state.statusMsg = "open failed: " + resolved
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    var next: GuiState = syncActiveBuffer(state)
    let existing: int32 = bufferIndexForPath(next.buffers, resolved)
    var recovered: bool = false
    if existing >= 0:
        next = loadBufferAt(next, existing)
    else:
        let editor: EditorState = loadEditorState(resolved, "")
        let recovery: RecoveryLoad = guiRecoveryMaybeLoad(next, editor)
        next.editor = recovery.editor
        next = insertBuffer(next, recovery.editor, bufferLen(next.buffers))
        next.activeBuffer = bufferLen(next.buffers) - 1
        recovered = recovery.recovered
    next.search = defaultSearchState()
    next.completion.active = false
    next.completion.items = default[str[]]
    next.completion.prefix = ""
    next.completion.selected = -1
    next = guiInvalidateProjectIndex(next)
    next = guiSetDiagnosticsDirty(next)
    if recovered:
        next.statusMsg = "recovered: " + resolved
    else:
        next.statusMsg = "open: " + resolved
    next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
    next = guiRevealExplorerPath(next, resolved)
    next.focus = fkEditor
    next = guiWorkspaceStateSave(next)
    return next

fn openEditorInput(state: GuiState, input: str): GuiState =
    let parsed: PathLineCol = parsePathLineCol(input)
    var path = if len(parsed.path) > 0: parsed.path else: trimLine(input)
    if len(path) == 0:
        return openEditorPath(state, path)
    let resolved = resolveWorkspacePath(state, path)
    if ! fileExists(resolved):
        let match = bestExplorerPathMatch(explorerAllItems(state.explorer), path)
        if len(match) > 0:
            path = match
    var next: GuiState = openEditorPath(state, path)
    if parsed.hasLine && len(next.editor.filePath) > 0:
        let colVal: int32 = if parsed.hasCol: parsed.col else: 0
        next = gotoLine(next, parsed.line, colVal)
    return next

fn guiWorkspaceStateApply(state: GuiState, workspace: WorkspaceState): GuiState =
    var next: GuiState = state
    if seqLenString(workspace.collapsed) > 0:
        next.explorer.collapsed = workspace.collapsed
        next.explorer.items = explorerVisibleItems(next.explorer.allItems, next.explorer.collapsed)
    if seqLenString(workspace.terminalLabels) > 0:
        next.terminalSessions = newTerminalSessionList()
        var maxCounter: int32 = 0
        for tIdx in 0..<seqLenString(workspace.terminalLabels):
            if tIdx >= MaxWorkspaceTerminals:
                break
            var label = trimLine(seqGetString(workspace.terminalLabels, tIdx))
            if len(label) == 0:
                label = "term-" + intToStr(tIdx + 1)
            if startsWithPrefix(label, "term-"):
                let suffix = sliceFrom(label, 5)
                if isAllDigits(suffix):
                    let val: int32 = parseInt32(suffix, 0)
                    if val > maxCounter:
                        maxCounter = val
            let session: TerminalState = initTerminalState(label)
            terminalSessionInsert(&next.terminalSessions, tIdx, session)
        let count: int32 = terminalSessionLen(next.terminalSessions)
        if count > 0:
            let activeIdx: int32 = clampInt(workspace.terminalActive, 0, count - 1)
            next.terminalSessionActive = activeIdx
            next.terminal = terminalSessionGet(next.terminalSessions, activeIdx)
            if maxCounter < count:
                maxCounter = count
            next.terminalSessionCounter = maxCounter
    if len(workspace.themeName) > 0:
        let themeEnv = getEnv("IDE_THEME")
        if len(themeEnv) == 0:
            next = guiSetThemeSilent(next, workspace.themeName)
    if workspace.autoSave >= 0:
        let autosaveEnv = getEnv("IDE_AUTOSAVE")
        if len(autosaveEnv) == 0:
            next.autoSave = workspace.autoSave > 0
            next.autoSavePending = false
            next.autoSaveCooldown = 0
    if workspace.formatOnSave >= 0:
        let formatEnv = getEnv("IDE_FORMAT_ON_SAVE")
        if len(formatEnv) == 0:
            next.formatOnSave = workspace.formatOnSave > 0
    if workspace.splitActive >= 0:
        next.editor.splitActive = workspace.splitActive > 0
        if ! next.editor.splitActive:
            next.editor.splitPane = 0
    if workspace.splitPane >= 0:
        if next.editor.splitActive:
            next.editor.splitPane = clampInt(workspace.splitPane, 0, 1)
    if workspace.leftPaneWidth >= 0:
        next.leftPaneWidth = workspace.leftPaneWidth
    if workspace.leftPaneVisible >= 0:
        next.leftPaneVisible = workspace.leftPaneVisible > 0
    if workspace.leftPaneTab >= 0:
        next.leftPaneTab = leftPaneTabFromIndex(workspace.leftPaneTab)
    if workspace.rightPaneWidth >= 0:
        next.rightPaneWidth = workspace.rightPaneWidth
    if workspace.rightPaneVisible >= 0:
        next.rightPaneVisible = workspace.rightPaneVisible > 0
    elif workspace.rightPaneWidth > 0:
        next.rightPaneVisible = true
    if workspace.rightPaneTab >= 0:
        next.rightPaneTab = rightPaneTabFromIndex(workspace.rightPaneTab)
    if workspace.bottomPaneVisible >= 0:
        next.bottomPaneVisible = workspace.bottomPaneVisible > 0
    if workspace.bottomPaneTab >= 0:
        next.bottomPaneTab = bottomPaneTabFromIndex(workspace.bottomPaneTab)
    if workspace.bottomPaneHeight >= 0:
        next.bottomPaneHeight = workspace.bottomPaneHeight
    var files: str[] = default[str[]]
    for idx in 0..<seqLenString(workspace.openFiles):
        let resolved = guiWorkspaceStateNormalizePath(next.workspaceRoots, next.projectRoot, seqGetString(workspace.openFiles, idx))
        if len(resolved) > 0 && fileExists(resolved):
            addUniqueString(&files, resolved)
    var active: str = ""
    if len(workspace.activePath) > 0:
        let resolved = guiWorkspaceStateNormalizePath(next.workspaceRoots, next.projectRoot, workspace.activePath)
        if len(resolved) > 0 && fileExists(resolved):
            active = resolved
    if len(active) == 0 && seqLenString(files) > 0:
        active = seqGetString(files, 0)
    for idx in 0..<seqLenString(files):
        let path = seqGetString(files, idx)
        if len(path) > 0 && path != next.editor.filePath:
            next = openEditorPath(next, path)
    if len(active) > 0:
        let activeIdx: int32 = bufferIndexForPath(next.buffers, active)
        if activeIdx >= 0:
            next = loadBufferAt(next, activeIdx)
    return next

fn guiCreateFile(state: GuiState, path: str): GuiState =
    let trimmed = trimLine(path)
    if len(trimmed) == 0:
        state.statusMsg = "new failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    let resolved = resolveWorkspacePath(state, trimmed)
    if len(resolved) == 0:
        state.statusMsg = "new failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    if dirExists(resolved):
        state.statusMsg = "new failed: is dir"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    var created: bool = false
    if ! fileExists(resolved):
        let dir = parentDir(resolved)
        if len(dir) > 0:
            guiEnsureDirExists(dir)
        writeFile(resolved, "")
        created = true
    var next: GuiState = openEditorPath(state, resolved)
    if created:
        next.statusMsg = "new: " + resolved
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
    next = guiInvalidateProjectIndex(next)
    next = guiReloadExplorer(next)
    next = guiVcsRefreshSilent(next)
    return next

fn guiMakeDir(state: GuiState, path: str): GuiState =
    let trimmed = trimLine(path)
    if len(trimmed) == 0:
        state.statusMsg = "mkdir failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    let resolved = resolveWorkspacePath(state, trimmed)
    if len(resolved) == 0:
        state.statusMsg = "mkdir failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    if fileExists(resolved):
        state.statusMsg = "mkdir failed: file exists"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    if dirExists(resolved):
        state.statusMsg = "mkdir: exists"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    guiEnsureDirExists(resolved)
    if ! dirExists(resolved):
        state.statusMsg = "mkdir failed: " + resolved
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    state = guiInvalidateProjectIndex(state)
    state = guiReloadExplorer(state)
    state = guiVcsRefreshSilent(state)
    state.statusMsg = "mkdir: " + resolved
    state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
    return state

fn guiRemoveDirRec(path: str, workDir: str): bool =
    if len(path) == 0:
        return false
    if guiIsWindows():
        let cmd = "powershell -NoProfile -Command \"Remove-Item -LiteralPath " + guiPsQuote(path) + " -Recurse -Force\""
        let result: ExecCmdResult = execCmdEx(cmd, {poStdErrToStdOut}, workDir)
        return result.exitCode == 0
    let cmd = "rm -rf " + guiShellQuote(path)
    let result: ExecCmdResult = execCmdEx(cmd, {poStdErrToStdOut}, workDir)
    return result.exitCode == 0

fn guiMoveDirRec(source: str, target: str, workDir: str): bool =
    if len(source) == 0 || len(target) == 0:
        return false
    if guiIsWindows():
        let cmd = "powershell -NoProfile -Command \"Move-Item -LiteralPath " + guiPsQuote(source) + " -Destination " + guiPsQuote(target) + "\""
        let result: ExecCmdResult = execCmdEx(cmd, {poStdErrToStdOut}, workDir)
        return result.exitCode == 0
    let cmd = "mv " + guiShellQuote(source) + " " + guiShellQuote(target)
    let result: ExecCmdResult = execCmdEx(cmd, {poStdErrToStdOut}, workDir)
    return result.exitCode == 0

fn guiDeleteFile(state: GuiState, path: str): GuiState =
    let trimmed = trimLine(path)
    if len(trimmed) == 0:
        state.statusMsg = "rm failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    var next: GuiState = syncActiveBuffer(state)
    let resolved = resolveWorkspacePath(next, trimmed)
    if len(resolved) == 0:
        next.statusMsg = "rm failed: empty path"
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        return next
    if dirExists(resolved):
        if guiHasDirtyBuffersUnder(next, resolved):
            next.statusMsg = "rm failed: unsaved buffer"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
        let workDir = if len(next.projectRoot) > 0: next.projectRoot else: getCurrentDir()
        if ! guiRemoveDirRec(resolved, workDir):
            next.statusMsg = "rm failed: remove dir"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
        next = guiDropBuffersForDir(next, resolved)
        next = guiInvalidateProjectIndex(next)
        next = guiReloadExplorer(next)
        next = guiVcsRefreshSilent(next)
        next.statusMsg = "rm: " + resolved
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        next = guiWorkspaceStateSave(next)
        return next
    if ! fileExists(resolved):
        next.statusMsg = "rm failed: not found"
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        return next
    for idx in 0..<bufferLen(next.buffers):
        let buffer: EditorState = bufferGet(next.buffers, idx)
        if buffer.filePath == resolved && buffer.dirty:
            next.statusMsg = "rm failed: unsaved buffer"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
    if ! removeFile(resolved):
        next.statusMsg = "rm failed: remove"
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        return next
    next = guiDropBuffersForPath(next, resolved)
    next = guiInvalidateProjectIndex(next)
    next = guiReloadExplorer(next)
    next = guiVcsRefreshSilent(next)
    next.statusMsg = "rm: " + resolved
    next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
    next = guiWorkspaceStateSave(next)
    return next

fn guiMoveFile(state: GuiState, source: str, target: str): GuiState =
    let src = trimLine(source)
    let dst = trimLine(target)
    if len(src) == 0 || len(dst) == 0:
        state.statusMsg = "mv failed: empty path"
        state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
        return state
    var next: GuiState = syncActiveBuffer(state)
    let srcPath = resolveWorkspacePath(next, src)
    let dstPath = resolveWorkspacePath(next, dst)
    if len(srcPath) == 0 || len(dstPath) == 0:
        next.statusMsg = "mv failed: empty path"
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        return next
    if srcPath == dstPath:
        next.statusMsg = "mv failed: same path"
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        return next
    if dirExists(srcPath):
        if pathIsUnderDir(srcPath, dstPath):
            next.statusMsg = "mv failed: target inside source"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
        if guiHasDirtyBuffersUnder(next, srcPath):
            next.statusMsg = "mv failed: unsaved buffer"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
        if fileExists(dstPath) || dirExists(dstPath):
            next.statusMsg = "mv failed: target exists"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
        let dir = parentDir(dstPath)
        if len(dir) > 0:
            guiEnsureDirExists(dir)
        let workDir = if len(next.projectRoot) > 0: next.projectRoot else: getCurrentDir()
        if ! guiMoveDirRec(srcPath, dstPath, workDir):
            next.statusMsg = "mv failed: move dir"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
        next = guiUpdateBuffersForDir(next, srcPath, dstPath)
        next = guiInvalidateProjectIndex(next)
        next = guiSetDiagnosticsDirty(next)
        next = guiReloadExplorer(next)
        next = guiVcsRefreshSilent(next)
        next.statusMsg = "mv: " + srcPath + " -> " + dstPath
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        if len(next.editor.filePath) > 0:
            next = guiRevealExplorerPath(next, next.editor.filePath)
        next = guiWorkspaceStateSave(next)
        return next
    if ! fileExists(srcPath):
        next.statusMsg = "mv failed: not found"
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        return next
    for idx in 0..<bufferLen(next.buffers):
        let buffer: EditorState = bufferGet(next.buffers, idx)
        if buffer.filePath == srcPath && buffer.dirty:
            next.statusMsg = "mv failed: unsaved buffer"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
        if buffer.filePath == dstPath:
            next.statusMsg = "mv failed: target open"
            next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
            return next
    if fileExists(dstPath) || dirExists(dstPath):
        next.statusMsg = "mv failed: target exists"
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        return next
    let dir = parentDir(dstPath)
    if len(dir) > 0:
        guiEnsureDirExists(dir)
    let content = readFile(srcPath)
    writeFile(dstPath, content)
    if ! removeFile(srcPath):
        next.statusMsg = "mv failed: remove"
        next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
        return next
    next = guiUpdateBufferPath(next, srcPath, dstPath)
    next = guiInvalidateProjectIndex(next)
    next = guiSetDiagnosticsDirty(next)
    next = guiReloadExplorer(next)
    next = guiVcsRefreshSilent(next)
    next.statusMsg = "mv: " + srcPath + " -> " + dstPath
    next.terminal = pushTerminalLine(next.terminal, next.statusMsg)
    if len(next.editor.filePath) > 0:
        next = guiRevealExplorerPath(next, next.editor.filePath)
    next = guiWorkspaceStateSave(next)
    return next

fn commitOverlay(state: GuiState): GuiState =
    let kind: OverlayKind = state.overlay.kind
    let input: str = state.overlay.input
    let prev: FocusKind = state.overlay.prevFocus
    state.overlay.kind = okNone
    state.overlay.input = ""
    state.focus = prev
    case kind
    of okOpen:
        return openEditorInput(state, input)
    of okSave:
        return saveEditorAs(state, input)
    of okNewFile:
        return guiCreateFile(state, input)
    of okNewFolder:
        return guiMakeDir(state, input)
    of okSearch:
        if state.searchProject:
            var next: GuiState = applySearchProject(state, input)
            next.searchProject = false
            return next
        return applySearch(state, input)
    of okGoto:
        let parsed: LineCol = parseLineCol(input)
        if parsed.ok:
            return gotoLine(state, parsed.line, parsed.col)
        state.statusMsg = "goto: invalid"
        return state
    of okReplace:
        let parsed: ReplaceResult = parseReplaceInput(input)
        if parsed.count < 0:
            state.statusMsg = "replace: invalid"
            return state
        let sepIdx: int32 = indexOfSubstr(parsed.text, "\n", 0)
        if sepIdx < 0:
            state.statusMsg = "replace: invalid"
            return state
        let needle = if sepIdx > 0: sliceRange(parsed.text, 0, sepIdx - 1) else: ""
        let repl = if sepIdx + 1 <= len(parsed.text) - 1: sliceRange(parsed.text, sepIdx + 1, len(parsed.text) - 1) else: ""
        if state.searchProject:
            var next: GuiState = replaceAllProject(state, needle, repl)
            next.searchProject = false
            return next
        return replaceAll(state, needle, repl)
    of okSymbol:
        return gotoSymbolInFile(state, input)
    of okWorkspaceSymbol:
        return gotoSymbolInWorkspace(state, input)
    of okCommand:
        return guiTaskHandleInput(state, input)
    of okCloseDirty:
        let answer = textutils.toLowerAscii(trimLine(input))
        if state.pendingQuit:
            if answer == "y" || answer == "yes":
                state.pendingQuit = false
                state.quitRequested = true
                return state
            if answer == "s" || answer == "save":
                var next: GuiState = saveEditor(state)
                if next.editor.dirty:
                    next.statusMsg = "close: save failed"
                    next.pendingQuit = false
                    return next
                next.pendingQuit = false
                next.quitRequested = true
                return next
            state.pendingQuit = false
            state.statusMsg = "close: canceled"
            return state
        if answer == "y" || answer == "yes":
            return closeActiveBuffer(state)
        if answer == "s" || answer == "save":
            var next: GuiState = saveEditor(state)
            if next.editor.dirty:
                next.statusMsg = "close: save failed"
                return next
            return closeActiveBuffer(next)
        state.statusMsg = "close: canceled"
        return state
    else:
        return state

fn insertTab(state: EditorState): EditorState =
    return insertText(state, "    ")

fn editorOutdent(state: EditorState): EditorState =
    let selRange: LineRange = selectionLineRange(state)
    if selRange.active:
        return outdentSelectionLines(state, selRange)
    let lineIdx: int32 = clampIndex(state.cursorLine, seqLenString(state.lines))
    if lineIdx < 0:
        return state
    let lineText = seqGetString(state.lines, lineIdx)
    let removeCount: int32 = lineOutdentCount(lineText)
    if removeCount <= 0:
        return state
    var next: EditorState = pushUndo(state)
    seqSetString(&next.lines, lineIdx, sliceFrom(lineText, removeCount))
    if next.cursorCol > 0:
        next.cursorCol = maxInt(0, next.cursorCol - minInt(next.cursorCol, removeCount))
        next.desiredCol = desiredColForLine(next, lineIdx, next.cursorCol)
    next.dirty = true
    return next

fn handleEditorKey(state: EditorState, layout: EventLayout, keyCode: uint32, layoutInfo: GuiLayout): EditorState =
    var next = state
    if layout == elMac:
        case keyCode
        of 51:
            next = editorBackspace(next)
        of 117:
            next = editorDeleteForward(next)
        of 36:
            next = editorInsertNewline(next)
        of 123:
            next = moveCursorLeftAll(next)
        of 124:
            next = moveCursorRightAll(next)
        of 125:
            next = moveCursorDownAll(next)
        of 126:
            next = moveCursorUpAll(next)
        of 116:
            next = pageScroll(next, -1, layoutInfo)
        of 121:
            next = pageScroll(next, 1, layoutInfo)
        of 115:
            next = moveCursorHomeAll(next)
        of 119:
            next = moveCursorEndAll(next)
        of 48:
            next = editorInsertTab(next)
        else:
            0
            return next
    if layout == elWin:
        case keyCode
        of 8:
            next = editorBackspace(next)
        of 46:
            next = editorDeleteForward(next)
        of 13:
            next = editorInsertNewline(next)
        of 37:
            next = moveCursorLeftAll(next)
        of 39:
            next = moveCursorRightAll(next)
        of 40:
            next = moveCursorDownAll(next)
        of 38:
            next = moveCursorUpAll(next)
        of 33:
            next = pageScroll(next, -1, layoutInfo)
        of 34:
            next = pageScroll(next, 1, layoutInfo)
        of 36:
            next = moveCursorHomeAll(next)
        of 35:
            next = moveCursorEndAll(next)
        of 9:
            next = editorInsertTab(next)
        else:
            0
            return next
    case keyCode
    of 65288:
        next = editorBackspace(next)
    of 65535:
        next = editorDeleteForward(next)
    of 65293:
        next = editorInsertNewline(next)
    of 65361:
        next = moveCursorLeftAll(next)
    of 65363:
        next = moveCursorRightAll(next)
    of 65364:
        next = moveCursorDownAll(next)
    of 65362:
        next = moveCursorUpAll(next)
    of 65365:
        next = pageScroll(next, -1, layoutInfo)
    of 65366:
        next = pageScroll(next, 1, layoutInfo)
    of 65360:
        next = moveCursorHomeAll(next)
    of 65367:
        next = moveCursorEndAll(next)
    of 65289:
        next = editorInsertTab(next)
    else:
        0
        return next

fn handleTerminalKey(state: TerminalState, layout: EventLayout, keyCode: uint32): TerminalState =
    var next = state
    if layout == elMac:
        case keyCode
        of 51:
            next = terminalBackspace(next)
        of 36:
            next = commitTerminalInput(next)
        else:
            0
            return next
    if layout == elWin:
        case keyCode
        of 8:
            next = terminalBackspace(next)
        of 13:
            next = commitTerminalInput(next)
        else:
            0
            return next
    case keyCode
    of 65288:
        next = terminalBackspace(next)
    of 65293:
        next = commitTerminalInput(next)
    else:
        0
        return next

fn editorLineNumberX(lineIdx: int32, editorX: int32, layout: GuiLayout): float64 =
    let scale = layout.scale
    let lineNoText = intToStr(int32(lineIdx + 1))
    var lineNoX: float64 = float64(editorX + layout.gutterW - 8.0 * scale - float64(len(lineNoText) * layout.advance))
    let minLineNoX: float64 = float64(editorX + 4.0 * scale)
    if lineNoX < minLineNoX:
        lineNoX = minLineNoX
    return lineNoX

fn guiCodexTodoLensBounds(layout: GuiLayout, editorX: int32, lineIdx: int32, lineTop: float64, outX: var float64, outY: var float64, outW: var float64, outH: var float64) =
    let scale = layout.scale
    let lensText = "Codex"
    let lensW = textWidthForFont(lensText, layout.smallFont, layout)
    let lineNoX = editorLineNumberX(lineIdx, editorX, layout)
    var lensX: float64 = lineNoX - lensW - 6.0 * scale
    let minLensX: float64 = float64(editorX + 18.0 * scale)
    if lensX < minLensX:
        lensX = minLensX
    outX = lensX
    outY = lineTop
    outW = lensW
    outH = layout.lineHeight

fn drawEditorViewport(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState, layout: GuiLayout, viewY: int32, viewH: int32, startLine: int32) =
    let editorX: int32 = layout.editorX
    let editorW: int32 = layout.editorW
    let scale: float64 = layout.scale
    let codeY: float64 = float64(viewY + editorTopPadding(layout))
    let lineCount: int32 = seqLenString(state.editor.lines)
    let visibleLines: int32 = maxInt(1, int32(float64(viewH / layout.lineHeight)))
    let selRange: SelectionRange = selectionRange(state.editor)
    let renderLite: bool = state.renderLite
    let maxTextW: float64 = float64(editorW - (layout.codeX - float64(editorX)) - 8.0 * scale)
    let maxChars: int32 = if maxTextW > 0.0: maxInt(1, int32(maxTextW / layout.advance)) else: 0
    var row: int32 = 0
    var lineIdx: int32 = startLine
    var imeCursorActive: bool = false
    var imeCursorX: float64 = 0.0
    var imeCursorTop: float64 = 0.0
    while row < visibleLines && lineIdx < lineCount:
        if isLineHidden(state.editor, lineIdx):
            lineIdx = lineIdx + 1
            continue
        let lineText = seqGetString(state.editor.lines, lineIdx)
        var renderText: str = lineText
        if maxChars > 0 && len(renderText) > maxChars:
            renderText = slicePrefix(renderText, maxChars)
        let renderLen: int32 = len(renderText)
        let lineTop: float64 = codeY + float64(row * layout.lineHeight)
        if lineIdx == state.editor.cursorLine:
            fillRect(pixels, width, height, strideBytes, editorX + 1, int32(lineTop), editorW - 2, int32(layout.lineHeight), theme.lineHighlight)
        if selRange.active && lineIdx >= selRange.startLine && lineIdx <= selRange.endLine:
            let lineLen: int32 = renderLen
            var selStart: int32 = if lineIdx == selRange.startLine: selRange.startCol else: 0
            var selEnd: int32 = if lineIdx == selRange.endLine: selRange.endCol else: lineLen
            selStart = clampInt(selStart, 0, lineLen)
            selEnd = clampInt(selEnd, 0, lineLen)
            if selEnd > selStart:
                let selX0: float64 = textXForCol(renderText, selStart, layout)
                let selX1: float64 = textXForCol(renderText, selEnd, layout)
                if selX1 > selX0:
                    let selX = layout.codeX + selX0
                    let selW: int32 = maxInt(1, int32(selX1 - selX0))
                    fillRect(pixels, width, height, strideBytes, int32(selX), int32(lineTop), selW, int32(layout.lineHeight), theme.selection)
        if ! renderLite && len(trimLine(lineText)) > 0:
            let indentLen: int32 = leadingWhitespaceLen(lineText)
            let levelCount: int32 = indentLen / TabSize
            for level in 1..levelCount:
                let guideX: float64 = layout.codeX + float64(level * int32(TabSize) * layout.advance)
                if int32(guideX) < editorX + editorW - 2:
                    fillRect(pixels, width, height, strideBytes, int32(guideX), int32(lineTop), 1, int32(layout.lineHeight), theme.indentGuide)
        if len(state.search.query) > 0 && lineIdx == state.search.matchLine && state.search.matchCol >= 0:
            let matchStart: int32 = clampInt(state.search.matchCol, 0, len(lineText))
            let matchEnd: int32 = clampInt(matchStart + len(state.search.query), 0, len(lineText))
            let matchX0: float64 = textXForCol(lineText, matchStart, layout)
            let matchX1: float64 = textXForCol(lineText, matchEnd, layout)
            if matchX1 > matchX0:
                let matchX = layout.codeX + matchX0
                let matchW: int32 = maxInt(1, int32(matchX1 - matchX0))
                fillRect(pixels, width, height, strideBytes, int32(matchX), int32(lineTop), matchW, int32(layout.lineHeight), theme.find)
        if ! renderLite:
            let diagSeverity: diag.GuiDiagSeverity = if len(state.diagLineSev) == lineCount: state.diagLineSev[lineIdx] else: guiDiagLineSeverity(state.diagnostics, lineIdx)
            if diagSeverity != diag.gdsNone:
                let markerColor: uint32 = guiDiagColor(theme, diagSeverity)
                let markerW: int32 = maxInt(2, int32(4.0 * layout.scale))
                fillRect(pixels, width, height, strideBytes, editorX + 4, int32(lineTop), markerW, int32(layout.lineHeight), markerColor)
        if ! state.editor.largeFile && ! renderLite:
            let foldable: LineRange = foldableRangeAtLine(state.editor.lines, lineIdx)
            let folded: LineRange = foldRangeForLine(state.editor, lineIdx)
            var foldMarker: str = " "
            if folded.active:
                foldMarker = ">"
            elif foldable.active:
                foldMarker = "v"
            let foldX: float64 = float64(editorX + 10.0 * scale)
            drawTextLine(pixels, width, height, strideBytes, foldX, lineTop, theme.subText, layout.smallFont, foldMarker)
        if ! renderLite:
            let lineNoText = intToStr(int32(lineIdx + 1))
            let lineNoColor: uint32 = if lineIdx == state.editor.cursorLine: theme.text else: theme.subText
            let lineNoX: float64 = editorLineNumberX(lineIdx, editorX, layout)
            drawCodeLine(pixels, width, height, strideBytes, lineNoX, lineTop, lineNoColor, layout.smallFont, lineNoText)
        if ! renderLite && ! state.editor.largeFile && guiCodexTodoLine(lineText):
            var lensX: float64 = 0.0
            var lensY: float64 = 0.0
            var lensW: float64 = 0.0
            var lensH: float64 = 0.0
            guiCodexTodoLensBounds(layout, editorX, lineIdx, lineTop, lensX, lensY, lensW, lensH)
            if lensW > 0.0:
                drawTextLine(pixels, width, height, strideBytes, lensX, lineTop, theme.accent, layout.smallFont, "Codex")
        if renderLite:
            drawCodeLine(pixels, width, height, strideBytes, layout.codeX, lineTop, theme.text, layout.fontSize, renderText)
        else:
            drawCodeLineColored(pixels, width, height, strideBytes, layout.codeX, lineTop, layout, theme, state.editor.bufferId, lineIdx, renderText)
        if state.imeActive && state.focus == fkEditor && state.overlay.kind == okNone && lineIdx == state.imeAnchorLine && len(state.imeText) > 0:
            let imeCol: int32 = clampInt(state.imeAnchorCol, 0, renderLen)
            let imeX: float64 = layout.codeX + textXForCol(renderText, imeCol, layout)
            drawCodeLine(pixels, width, height, strideBytes, imeX, lineTop, theme.accent, layout.fontSize, state.imeText)
            let imeW: float64 = textWidthForCodeFont(state.imeText, layout.fontSize, layout)
            if imeW > 0.0:
                let underlineY: int32 = int32(lineTop + layout.lineHeight - 2.0 * layout.scale)
                fillRect(pixels, width, height, strideBytes, int32(imeX), underlineY, maxInt(1, int32(imeW)), maxInt(1, int32(1.0 * layout.scale)), theme.accent)
            imeCursorActive = true
            imeCursorX = imeX + textWidthForCodeFont(state.imeText, layout.fontSize, layout)
            imeCursorTop = lineTop
        if ! renderLite && ! state.editor.largeFile:
            let folded: LineRange = foldRangeForLine(state.editor, lineIdx)
            if folded.active:
                let hiddenCount: int32 = folded.endLine - folded.startLine
                let noteText = "  ... (" + intToStr(hiddenCount) + " lines)"
                let noteX: float64 = layout.codeX + textXForCol(lineText, len(lineText), layout)
                drawCodeLine(pixels, width, height, strideBytes, noteX, lineTop, theme.subText, layout.fontSize, noteText)
        row = row + 1
        lineIdx = lineIdx + 1

    let extraCount: int32 = seqLenCursor(state.editor.multiCursors)
    if extraCount > 0:
        let primary: CursorPos = makeCursorPos(state.editor.cursorLine, state.editor.cursorCol)
        for cIdx in 0..<extraCount:
            let pos: CursorPos = seqGetCursor(state.editor.multiCursors, cIdx)
            if ! cursorEqual(pos, primary):
                let row: int32 = visibleRowForLine(state.editor, startLine, pos.line, visibleLines)
                if row >= 0 && row < visibleLines:
                    let cursorTop = codeY + float64(row * layout.lineHeight)
                    let lineText = seqGetString(state.editor.lines, pos.line)
                    let cursorX: float64 = layout.codeX + textXForCol(lineText, pos.col, layout)
                    let cursorW: int32 = maxInt(1, int32(scale))
                    fillRect(pixels, width, height, strideBytes, int32(cursorX), int32(cursorTop), cursorW, int32(layout.lineHeight), theme.accent)

    let cursorRow: int32 = visibleRowForLine(state.editor, startLine, state.editor.cursorLine, visibleLines)
    if cursorRow >= 0 && cursorRow < visibleLines:
        let cursorW: int32 = maxInt(1, int32(scale))
        if imeCursorActive:
            fillRect(pixels, width, height, strideBytes, int32(imeCursorX), int32(imeCursorTop), cursorW, int32(layout.lineHeight), theme.text)
        else:
            let cursorTop = codeY + float64(cursorRow * layout.lineHeight)
            let lineText = seqGetString(state.editor.lines, state.editor.cursorLine)
            var cursorText: str = lineText
            if maxChars > 0 && len(cursorText) > maxChars:
                cursorText = slicePrefix(cursorText, maxChars)
            let cursorCol: int32 = clampInt(state.editor.cursorCol, 0, len(cursorText))
            let cursorX: float64 = layout.codeX + textXForCol(cursorText, cursorCol, layout)
            fillRect(pixels, width, height, strideBytes, int32(cursorX), int32(cursorTop), cursorW, int32(layout.lineHeight), theme.text)

fn windowTitle(state: GuiState): str =
    let workspace = if len(state.projectRoot) > 0: extractFilename(state.projectRoot) else: "workspace"
    var fileLabel = "<untitled>"
    let count: int32 = bufferLen(state.buffers)
    if count > 0:
        let activeIdx: int32 = clampInt(state.activeBuffer, 0, count - 1)
        let buffer: EditorState = bufferGet(state.buffers, activeIdx)
        fileLabel = tabLabel(state, buffer)
    if len(fileLabel) > 0:
        return fileLabel + " - " + workspace + " - Cheng IDE"
    return workspace + " - Cheng IDE"

fn drawTitleBar(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState) =
    let layout = state.layout
    let scale = layout.scale
    let titleH: int32 = titleBarHeight(layout)
    if titleH <= 0:
        return

    var menuX: float64 = 12.0 * scale
    let menuY: float64 = tabTextY(0.0, titleH, layout)
    let menuGap: float64 = 14.0 * scale

    drawTextLine(pixels, width, height, strideBytes, menuX, menuY, theme.text, layout.smallFont, "File")
    menuX = menuX + textWidthForFont("File", layout.smallFont, layout) + menuGap

    drawTextLine(pixels, width, height, strideBytes, menuX, menuY, theme.text, layout.smallFont, "Edit")
    menuX = menuX + textWidthForFont("Edit", layout.smallFont, layout) + menuGap

    drawTextLine(pixels, width, height, strideBytes, menuX, menuY, theme.text, layout.smallFont, "Selection")
    menuX = menuX + textWidthForFont("Selection", layout.smallFont, layout) + menuGap

    drawTextLine(pixels, width, height, strideBytes, menuX, menuY, theme.text, layout.smallFont, "View")
    menuX = menuX + textWidthForFont("View", layout.smallFont, layout) + menuGap

    drawTextLine(pixels, width, height, strideBytes, menuX, menuY, theme.text, layout.smallFont, "Go")
    menuX = menuX + textWidthForFont("Go", layout.smallFont, layout) + menuGap

    drawTextLine(pixels, width, height, strideBytes, menuX, menuY, theme.text, layout.smallFont, "Run")
    menuX = menuX + textWidthForFont("Run", layout.smallFont, layout) + menuGap

    drawTextLine(pixels, width, height, strideBytes, menuX, menuY, theme.text, layout.smallFont, "Terminal")
    menuX = menuX + textWidthForFont("Terminal", layout.smallFont, layout) + menuGap

    drawTextLine(pixels, width, height, strideBytes, menuX, menuY, theme.text, layout.smallFont, "Help")
    menuX = menuX + textWidthForFont("Help", layout.smallFont, layout) + menuGap

    let debugText = iconDebugLabel(layout)
    if len(debugText) > 0:
        let debugW = textWidthForFont(debugText, layout.smallFont, layout)
        var debugX = float64(width - debugW - 12.0 * scale)
        if debugX < menuX + 8.0 * scale:
            debugX = menuX + 8.0 * scale
        drawTextLine(pixels, width, height, strideBytes, debugX, menuY, theme.subText, layout.smallFont, debugText)

    let title = windowTitle(state)
    let titleW = textWidthForFont(title, layout.smallFont, layout)
    var titleX = (float64(width - titleW)) * 0.5
    let minTitleX: float64 = menuX + 16.0 * scale
    let maxTitleX: float64 = float64(width - titleW - 80.0 * scale)
    if titleX < minTitleX:
        titleX = minTitleX
    if titleX > maxTitleX:
        titleX = maxTitleX
    if titleX >= 0.0 && titleX + titleW <= float64(width):
        drawTextLine(pixels, width, height, strideBytes, titleX, menuY, theme.subText, layout.smallFont, title)

fn drawStatusBar(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState) =
    let layout = state.layout
    let scale = layout.scale
    let statusH = layout.statusH
    let textBox: float64 = layout.smallFont * 1.2
    let y = float64(height - statusH + (float64(statusH - textBox)) * 0.5)

    var diagErrors: int32 = 0
    var diagWarnings: int32 = 0
    var diagInfos: int32 = 0
    for dIdx in 0..<state.diagnostics.len:
        let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(state.diagnostics, dIdx)
        if entry.severity == diag.gdsError:
            diagErrors = diagErrors + 1
        elif entry.severity == diag.gdsWarning:
            diagWarnings = diagWarnings + 1
        elif entry.severity == diag.gdsInfo:
            diagInfos = diagInfos + 1

    let lang = "Cheng"
    let encoding = "UTF-8"
    let cursor = "Ln " + intToStr(state.editor.cursorLine + 1) + ", Col " + intToStr(state.editor.cursorCol + 1)
    let langW = textWidthForFont(lang, layout.smallFont, layout)
    let encW = textWidthForFont(encoding, layout.smallFont, layout)
    let curW = textWidthForFont(cursor, layout.smallFont, layout)
    let bellIcon = codiconGlyph(CodiconBell)
    let bellW = textWidthForFont(bellIcon, layout.smallFont, layout)
    let rightStartX: float64 = float64(width - 20.0 * scale - bellW - 20.0 * scale - langW - 20.0 * scale - encW - 20.0 * scale - curW)

    var x: float64 = 10.0 * scale
    let branchLabel = guiVcsBranchFromSummary(state.vcsSummary)
    let vcsCount: int32 = seqLenString(state.vcsLines)
    let vcsLabel = statusVcsLabel(branchLabel, vcsCount)
    if len(vcsLabel) > 0:
        drawTextLine(pixels, width, height, strideBytes, x, y, theme.statusBarFg, layout.smallFont, vcsLabel)
        x = x + textWidthForFont(vcsLabel, layout.smallFont, layout) + 16.0 * scale
    let diagLabel = statusDiagLabel(diagErrors, diagWarnings, diagInfos)
    if len(diagLabel) > 0:
        drawTextLine(pixels, width, height, strideBytes, x, y, theme.statusBarFg, layout.smallFont, diagLabel)
        drawTextLine(pixels, width, height, strideBytes, x, y, theme.statusBarFg, layout.smallFont, diagLabel)
        x = x + textWidthForFont(diagLabel, layout.smallFont, layout) + 20.0 * scale
    if state.perf.enabled:
        let perfLabel = "perf " + intToStr(state.perf.frameMs) + "ms r" + intToStr(state.perf.renderMs) + " p" + intToStr(state.perf.presentMs)
        drawTextLine(pixels, width, height, strideBytes, x, y, theme.statusBarFg, layout.smallFont, perfLabel)
        x = x + textWidthForFont(perfLabel, layout.smallFont, layout) + 20.0 * scale

    let statusMsg = trimLine(state.statusMsg)
    if len(statusMsg) > 0 && rightStartX > x + 8.0 * scale:
        let maxStatusW: float64 = rightStartX - x - 8.0 * scale
        if maxStatusW > layout.smallFont:
            let shown = truncateTextToWidth(statusMsg, maxStatusW, layout.smallFont)
            if len(shown) > 0:
                drawTextLine(pixels, width, height, strideBytes, x, y, theme.statusBarFg, layout.smallFont, shown)
                x = x + textWidthForFont(shown, layout.smallFont, layout) + 16.0 * scale

    # Right: Cursor, Encoding, Language
    var rightX = float64(width - 20.0 * scale)
    
    # Notification Bell
    drawTextLine(pixels, width, height, strideBytes, rightX - bellW, y, theme.statusBarFg, layout.smallFont, bellIcon)
    rightX = rightX - bellW - 20.0 * scale
    
    drawTextLine(pixels, width, height, strideBytes, rightX - langW, y, theme.statusBarFg, layout.smallFont, lang)
    rightX = rightX - langW - 20.0 * scale
    
    drawTextLine(pixels, width, height, strideBytes, rightX - encW, y, theme.statusBarFg, layout.smallFont, encoding)
    rightX = rightX - encW - 20.0 * scale
    
    drawTextLine(pixels, width, height, strideBytes, rightX - curW, y, theme.statusBarFg, layout.smallFont, cursor)

fn renderGui(pixels: void*, width, height, strideBytes: int32, scale: float64, textBackend: str, state: GuiState) =
    let theme: GuiTheme = state.theme
    ensureFileIconsLoaded(theme.name)
    fillRect(pixels, width, height, strideBytes, 0, 0, width, height, theme.background)

    let layout: GuiLayout = state.layout
    let renderLite: bool = state.renderLite
    let topH: int32 = layout.topH
    let statusH: int32 = layout.statusH
    let leftW: int32 = layout.leftW
    let rightW: int32 = layout.rightW
    let bottomH: int32 = layout.bottomH
    let contentY: int32 = layout.contentY
    let contentH: int32 = layout.contentH
    let editorX: int32 = layout.editorX
    let editorW: int32 = layout.editorW
    let editorH: int32 = layout.editorH
    let bottomY: int32 = layout.bottomY
    let rightX: int32 = leftW + editorW
    let minimapW: int32 = minimapWidth(layout)
    let minimapX: int32 = editorX + editorW - minimapW
    let rightPaneX: int32 = rightX
    let rightPaneW: int32 = rightW
    let showRightPane: bool = rightPaneW > 0

    let titleH: int32 = titleBarHeight(layout)
    let tabH: int32 = tabStripHeight(layout)
    if titleH > 0:
        fillRect(pixels, width, height, strideBytes, 0, 0, width, titleH, theme.header)
    if tabH > 0:
        fillRect(pixels, width, height, strideBytes, 0, titleH, width, tabH, theme.panel)
    fillRect(pixels, width, height, strideBytes, 0, contentY, leftW, contentH, theme.panel)
    fillRect(pixels, width, height, strideBytes, editorX, contentY, editorW, editorH, theme.editor)
    if showRightPane:
        fillRect(pixels, width, height, strideBytes, rightX, contentY, rightW, contentH, theme.panel)
    fillRect(pixels, width, height, strideBytes, editorX, bottomY, editorW, bottomH, theme.editor)
    drawTitleBar(pixels, width, height, strideBytes, theme, state)
    if topH > 0:
        fillRect(pixels, width, height, strideBytes, 0, topH - 1, width, 1, theme.border)

    fillRect(pixels, width, height, strideBytes, leftW - 1, contentY, 1, contentH, theme.border)
    if showRightPane:
        fillRect(pixels, width, height, strideBytes, rightX, contentY, 1, contentH, theme.border)
    fillRect(pixels, width, height, strideBytes, editorX, bottomY, editorW, 1, theme.border)
    if minimapW > 0:
        fillRect(pixels, width, height, strideBytes, minimapX, contentY, 1, editorH, theme.border)

    let outlineItems: str[] = state.editor.outlineEntries
    let activeOutline: int32 = activeOutlineIndex(outlineItems, state.editor.cursorLine)
    var diagErrors: int32 = 0
    var diagWarnings: int32 = 0
    var diagInfos: int32 = 0
    var dIdx: int32 = 0
    for dScan in 0..<state.diagnostics.len:
        let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(state.diagnostics, dScan)
        if entry.severity == diag.gdsError:
            diagErrors = diagErrors + 1
        elif entry.severity == diag.gdsWarning:
            diagWarnings = diagWarnings + 1
        elif entry.severity == diag.gdsInfo:
            diagInfos = diagInfos + 1
    let vcsCount: int32 = seqLenString(state.vcsLines)

    drawTabs(pixels, width, height, strideBytes, theme, state)
    if state.overlay.kind != okNone:
        let overlayX: int32 = int32(320.0 * scale)
        let overlayY: int32 = titleBarHeight(layout) + int32(6.0 * scale)
        let overlayW: int32 = maxInt(0, width - overlayX - int32(16.0 * scale))
        let overlayH: int32 = maxInt(0, topH - overlayY - int32(6.0 * scale))
        fillRect(pixels, width, height, strideBytes, overlayX, overlayY, overlayW, overlayH, theme.panelAlt)
        let overlayText = overlayPrompt(state.overlay.kind) + state.overlay.input
        let overlayTextY: float64 = float64(overlayY + (float64(overlayH - layout.headerFont * 1.2)) * 0.5)
        drawTextLine(pixels, width, height, strideBytes, float64(overlayX + 12.0 * scale), overlayTextY, theme.text, layout.headerFont, overlayText)

    let breadcrumbY: float64 = float64(layout.contentY + 10.0 * scale)
    let breadcrumbAvail: float64 = float64(editorW - minimapW - 24.0 * scale)
    let breadcrumbMaxChars: int32 = maxInt(8, int32(breadcrumbAvail / layout.advance))
    let breadcrumbText = makeBreadcrumbText(state, outlineItems, activeOutline, breadcrumbMaxChars)
    if len(breadcrumbText) > 0:
        drawTextLine(pixels, width, height, strideBytes, layout.codeX, breadcrumbY, theme.subText, layout.smallFont, breadcrumbText)

    let leftTitleY: float64 = explorerTitleY(layout)
    let activityW: int32 = activityBarWidth(layout)
    let leftContentX: float64 = float64(activityW)
    let leftContentW: int32 = maxInt(0, leftW - activityW)
    if activityW > 0:
        fillRect(pixels, width, height, strideBytes, 0, contentY, activityW, contentH, theme.activityBar)
        fillRect(pixels, width, height, strideBytes, activityW - 1, contentY, 1, contentH, theme.border)
        let slotH: float64 = 48.0 * scale
        let iconX: float64 = 0.5 * float64(activityW)
        # Large icons for Activity Bar (approx 24px)
        let iconFont: float64 = 24.0 * scale
        for tabIdx in 0..<leftPaneTabCount():
            let tab: LeftPaneTab = leftPaneTabFromIndex(tabIdx)
            let tabY: float64 = float64(contentY + float64(tabIdx * slotH))
            let isActive: bool = tab == state.leftPaneTab
            let isHover: bool = tabIdx == state.hoverLeftPaneTab
            if isHover && ! isActive:
                fillRect(pixels, width, height, strideBytes, 0, int32(tabY), activityW, int32(slotH), theme.panelAlt)
            if isActive:
                fillRect(pixels, width, height, strideBytes, 0, int32(tabY), maxInt(2, int32(2.0 * scale)), int32(slotH), theme.accent)

            let glyphColor: uint32 = if isActive || isHover: theme.text else: theme.subText
            if tab == lpCodex && ensureCodexIconMask():
                let mask = codexIconMask
                var maskScale: float64 = 1.0
                if mask.w > 0:
                    maskScale = iconFont / float64(mask.w)
                let maskW: int32 = maxInt(1, int32(float64(mask.w * maskScale)))
                let maskH: int32 = maxInt(1, int32(float64(mask.h * maskScale)))
                let maskX: int32 = int32(iconX - float64(maskW * 0.5))
                let maskY: int32 = int32(tabY + (slotH - float64(maskH)) * 0.5)
                drawIconMaskScaled(pixels, width, height, strideBytes, mask, maskX, maskY, maskScale, glyphColor)
            else:
                let glyph: str = leftPaneTabGlyph(tab)
                let glyphW: float64 = textWidthForFont(glyph, iconFont, layout)
                let glyphX: float64 = iconX - glyphW * 0.5
                # Center vertically: tabY + (slotH - iconFont)/2 might be better?
                # Existing was: tabY + (slotH - iconFont * 1.2) * 0.5. 1.2 factor is for line height?
                # Let's try pure centering for icons.
                let glyphY: float64 = tabY + (slotH - iconFont) * 0.5 + 1.0 * scale
                drawTextLine(pixels, width, height, strideBytes, glyphX, glyphY, glyphColor, iconFont, glyph)
        let bottomCount: int32 = activityBottomCount()
        if bottomCount > 0:
            let bottomStartY: float64 = float64(contentY + contentH - slotH * float64(bottomCount))
            for bIdx in 0..<bottomCount:
                let glyph = activityBottomGlyph(bIdx)
                let tabY: float64 = bottomStartY + float64(bIdx * slotH)
                let isHover: bool = bIdx == state.hoverActivityBottom
                if isHover:
                    fillRect(pixels, width, height, strideBytes, 0, int32(tabY), activityW, int32(slotH), theme.panelAlt)
                let glyphW: float64 = textWidthForFont(glyph, iconFont, layout)
                let glyphX: float64 = iconX - glyphW * 0.5
                let glyphY: float64 = tabY + (slotH - iconFont) * 0.5 + 1.0 * scale
                let glyphColor: uint32 = if isHover: theme.text else: theme.subText
                drawTextLine(pixels, width, height, strideBytes, glyphX, glyphY, glyphColor, iconFont, glyph)

    if leftContentW > 0:
        let headerH: int32 = minInt(panelHeaderHeight(layout), contentH)
        let headerTop: int32 = contentY
        if headerH > 0:
            fillRect(pixels, width, height, strideBytes, activityW, contentY, leftContentW, headerH, theme.panel)
            fillRect(pixels, width, height, strideBytes, activityW, contentY + headerH - 1, leftContentW, 1, theme.border)
        let headerX: float64 = leftContentX + panelPaddingX(layout)
        if state.leftPaneTab == lpExplorer:
            let explorerCount: int32 = seqLenString(state.explorer.items)
            let explorerHeader = "EXPLORER (" + intToStr(explorerCount) + ")"
            drawTextLine(pixels, width, height, strideBytes, headerX, leftTitleY, theme.subText, layout.headerFont, explorerHeader)
            let actionFont: float64 = explorerHeaderActionFont(layout)
            let actionGap: float64 = explorerHeaderActionGap(layout)
            let actionPad: float64 = explorerHeaderActionPad(layout)
            var actionX: float64 = float64(leftContentX + leftContentW - panelPaddingX(layout))
            let actionIdxBase = explorerHeaderActionCount() - 1
            if actionIdxBase >= 0:
                for actionIdxRev in 0..actionIdxBase:
                    let actionIdx = actionIdxBase - actionIdxRev
                    let kind = explorerHeaderActionFromIndex(actionIdx)
                    let glyph = explorerHeaderActionGlyph(kind)
                    if len(glyph) > 0:
                        let glyphW: float64 = textWidthForFont(glyph, actionFont, layout)
                        actionX = actionX - glyphW
                        let hovered: bool = state.hoverExplorerAction == kind
                        if hovered:
                            let rectX: int32 = int32(actionX - actionPad)
                            let rectW: int32 = int32(glyphW + actionPad * 2.0)
                            let rectY: int32 = headerTop + maxInt(1, int32(2.0 * scale))
                            let rectH: int32 = maxInt(1, headerH - maxInt(2, int32(4.0 * scale)))
                            fillRect(pixels, width, height, strideBytes, rectX, rectY, rectW, rectH, theme.selection)
                        let glyphColor: uint32 = if hovered: theme.text else: theme.subText
                        drawTextLine(pixels, width, height, strideBytes, actionX, leftTitleY, glyphColor, actionFont, glyph)
                        actionX = actionX - actionGap
            var explorerStartY: float64 = explorerListStartY(layout)
            let debugText = iconDebugLabel(layout)
            if len(debugText) > 0:
                drawTextLine(pixels, width, height, strideBytes, headerX, explorerStartY, theme.subText, layout.smallFont, debugText)
                explorerStartY = explorerStartY + layout.lineHeight
            let explorerLines: int32 = explorerVisibleLines(layout)
            for expIdx in 0..<explorerLines:
                let itemIdx: int32 = state.explorer.scroll + expIdx
                if itemIdx >= seqLenString(state.explorer.items):
                    break
                let lineText = seqGetString(state.explorer.items, itemIdx)
                let depth: int32 = explorerItemDepth(lineText)
                let rawName = explorerItemDisplayName(lineText)
                var displayName = rawName
                if explorerItemIsDir(lineText) && len(displayName) > 0 && textutils.endsWith(displayName, "/"):
                    displayName = sliceRange(displayName, 0, len(displayName) - 2)
                let lineY = explorerStartY + float64(expIdx * layout.lineHeight)
                let hovered: bool = state.leftPaneTab == lpExplorer && expIdx == state.hoverLeftPaneRow && itemIdx != state.explorer.selected
                if hovered:
                    fillRect(pixels, width, height, strideBytes, activityW + 1, int32(lineY), leftContentW - 2, int32(layout.lineHeight), theme.lineHighlight)
                if itemIdx == state.explorer.selected:
                    fillRect(pixels, width, height, strideBytes, activityW + 1, int32(lineY), leftContentW - 2, int32(layout.lineHeight), theme.selection)
                let indentX: float64 = leftContentX + float64(depth * 14.0 * scale)
                let arrowX: float64 = indentX + 12.0 * scale
                let isDir: bool = explorerItemIsDir(lineText)
                let collapsed: bool = isDir && containsString(state.explorer.collapsed, explorerItemKey(lineText))
                let arrow = explorerChevronGlyph(isDir, collapsed)
                drawTextLine(pixels, width, height, strideBytes, arrowX, lineY, theme.subText, layout.smallFont, arrow)
                let iconX: float64 = arrowX + 12.0 * scale
                var labelX: float64 = iconX
                var iconGlyph: str = ""
                var iconColor: uint32 = theme.subText
                if ! renderLite:
                    if isDir:
                        if useCodicons():
                            iconGlyph = explorerItemGlyph(isDir, collapsed)
                    else:
                        let iconEntry: FileIconEntry = fileIconEntryForName(displayName)
                        if len(iconEntry.glyph) > 0:
                            iconGlyph = iconEntry.glyph
                            if iconEntry.hasColor:
                                iconColor = iconEntry.color
                        elif useCodicons():
                            iconGlyph = explorerItemGlyph(isDir, collapsed)
                if len(iconGlyph) > 0:
                    let iconW: float64 = textWidthForFont(iconGlyph, layout.smallFont, layout)
                    drawTextLine(pixels, width, height, strideBytes, iconX, lineY, iconColor, layout.smallFont, iconGlyph)
                    labelX = iconX + iconW + 6.0 * scale
                let labelMaxW: float64 = float64(leftContentX + leftContentW - labelX - panelPaddingX(layout))
                var labelText = truncateFileLabelToWidth(displayName, labelMaxW, layout.smallFont)
                labelText = ensureChengSuffix(labelText, explorerItemPathPart(lineText))
                drawTextLine(pixels, width, height, strideBytes, labelX, lineY, theme.text, layout.smallFont, labelText)
        elif state.leftPaneTab == lpSearch:
            let searchHeader = "SEARCH (" + intToStr(state.searchTotal) + ")"
            drawTextLine(pixels, width, height, strideBytes, headerX, leftTitleY, theme.subText, layout.headerFont, searchHeader)
            let actionFont: float64 = explorerHeaderActionFont(layout)
            let actionGap: float64 = explorerHeaderActionGap(layout)
            let actionPad: float64 = explorerHeaderActionPad(layout)
            var actionX: float64 = float64(leftContentX + leftContentW - panelPaddingX(layout))
            let actionIdxBase = searchHeaderActionCount() - 1
            if actionIdxBase >= 0:
                for actionIdxRev in 0..actionIdxBase:
                    let actionIdx = actionIdxBase - actionIdxRev
                    let kind = searchHeaderActionFromIndex(actionIdx)
                    let glyph = searchHeaderActionGlyph(kind)
                    if len(glyph) > 0:
                        let glyphW: float64 = textWidthForFont(glyph, actionFont, layout)
                        actionX = actionX - glyphW
                        let hovered: bool = state.hoverSearchAction == kind
                        if hovered:
                            let rectX: int32 = int32(actionX - actionPad)
                            let rectW: int32 = int32(glyphW + actionPad * 2.0)
                            let rectY: int32 = headerTop + maxInt(1, int32(2.0 * scale))
                            let rectH: int32 = maxInt(1, headerH - maxInt(2, int32(4.0 * scale)))
                            fillRect(pixels, width, height, strideBytes, rectX, rectY, rectW, rectH, theme.selection)
                        let glyphColor: uint32 = if hovered: theme.text else: theme.subText
                        drawTextLine(pixels, width, height, strideBytes, actionX, leftTitleY, glyphColor, actionFont, glyph)
                        actionX = actionX - actionGap
            var listY: float64 = explorerListStartY(layout)
            let debugText = iconDebugLabel(layout)
            if len(debugText) > 0:
                drawTextLine(pixels, width, height, strideBytes, headerX, listY, theme.subText, layout.smallFont, debugText)
                listY = listY + layout.lineHeight
            var resultStartY: float64 = listY
            var resultOffset: int32 = 0
            if len(state.search.query) > 0:
                let queryMaxW: float64 = float64(leftContentW - 2.0 * panelPaddingX(layout))
                let queryText = truncateTextToWidth(state.search.query, queryMaxW, layout.smallFont)
                drawTextLine(pixels, width, height, strideBytes, headerX, listY, theme.subText, layout.smallFont, queryText)
                resultStartY = listY + layout.lineHeight
                resultOffset = 1
            let resultLines: int32 = maxInt(1, explorerVisibleLines(layout) - resultOffset)
            if seqLenString(state.searchResults) == 0:
                let emptyText = if len(state.search.query) > 0: "no results" else: "type to search"
                drawTextLine(pixels, width, height, strideBytes, headerX, resultStartY, theme.subText, layout.smallFont, emptyText)
            else:
                let totalResults: int32 = seqLenString(state.searchResults)
                let maxScroll: int32 = maxInt(0, totalResults - resultLines)
                let startIdx: int32 = clampInt(state.searchScroll, 0, maxScroll)
                let resultMaxW: float64 = float64(leftContentW - 2.0 * panelPaddingX(layout))
                for rIdx in 0..<resultLines:
                    if startIdx + rIdx >= totalResults:
                        break
                    let entry = seqGetString(state.searchResults, startIdx + rIdx)
                    let lineY = resultStartY + float64(rIdx * layout.lineHeight)
                    let resultText = truncateTextToWidth(searchResultLabel(entry), resultMaxW, layout.smallFont)
                    if state.leftPaneTab == lpSearch && rIdx == state.hoverLeftPaneRow:
                        fillRect(pixels, width, height, strideBytes, activityW + 1, int32(lineY), leftContentW - 2, int32(layout.lineHeight), theme.lineHighlight)
                    drawTextLine(pixels, width, height, strideBytes, headerX, lineY, theme.text, layout.smallFont, resultText)
                if state.searchTruncated:
                    let noteY = resultStartY + float64(minInt(resultLines, seqLenString(state.searchResults)) * layout.lineHeight)
                    drawTextLine(pixels, width, height, strideBytes, headerX, noteY, theme.subText, layout.smallFont, "search: truncated")
        elif state.leftPaneTab == lpVcs:
            let header = "SCM (" + intToStr(vcsCount) + ")"
            drawTextLine(pixels, width, height, strideBytes, headerX, leftTitleY, theme.subText, layout.headerFont, header)
            let actionFont: float64 = explorerHeaderActionFont(layout)
            let actionGap: float64 = explorerHeaderActionGap(layout)
            let actionPad: float64 = explorerHeaderActionPad(layout)
            var actionX: float64 = float64(leftContentX + leftContentW - panelPaddingX(layout))
            let actionIdxBase = vcsHeaderActionCount() - 1
            if actionIdxBase >= 0:
                for actionIdxRev in 0..actionIdxBase:
                    let actionIdx = actionIdxBase - actionIdxRev
                    let kind = vcsHeaderActionFromIndex(actionIdx)
                    let glyph = vcsHeaderActionGlyph(kind)
                    if len(glyph) > 0:
                        let glyphW: float64 = textWidthForFont(glyph, actionFont, layout)
                        actionX = actionX - glyphW
                        let hovered: bool = state.hoverVcsAction == kind
                        if hovered:
                            let rectX: int32 = int32(actionX - actionPad)
                            let rectW: int32 = int32(glyphW + actionPad * 2.0)
                            let rectY: int32 = headerTop + maxInt(1, int32(2.0 * scale))
                            let rectH: int32 = maxInt(1, headerH - maxInt(2, int32(4.0 * scale)))
                            fillRect(pixels, width, height, strideBytes, rectX, rectY, rectW, rectH, theme.selection)
                        let glyphColor: uint32 = if hovered: theme.text else: theme.subText
                        drawTextLine(pixels, width, height, strideBytes, actionX, leftTitleY, glyphColor, actionFont, glyph)
                        actionX = actionX - actionGap
            var listY: float64 = explorerListStartY(layout)
            let debugText = iconDebugLabel(layout)
            if len(debugText) > 0:
                drawTextLine(pixels, width, height, strideBytes, headerX, listY, theme.subText, layout.smallFont, debugText)
                listY = listY + layout.lineHeight
            let summary: str = state.vcsSummary
            let summaryLower = textutils.toLowerAscii(summary)
            let summaryIsError: bool = summaryLower == "not a git repo" || summaryLower == "git error"
            let vcsCounts: VcsCounts = guiVcsCounts(state.vcsLines)
            let countsLabel = guiVcsCountsLabel(vcsCounts)
            var lineOffset: int32 = 0
            if len(summary) > 0:
                let summaryMaxW: float64 = float64(leftContentW - 2.0 * panelPaddingX(layout))
                let summaryText = truncateTextToWidth(summary, summaryMaxW, layout.smallFont)
                drawTextLine(pixels, width, height, strideBytes, headerX, listY, theme.subText, layout.smallFont, summaryText)
                lineOffset = lineOffset + 1
            let showCounts: bool = (len(summary) > 0 || vcsCount > 0) && ! summaryIsError && len(countsLabel) > 0
            if showCounts:
                let countsY = listY + float64(lineOffset * layout.lineHeight)
                let countsMaxW: float64 = float64(leftContentW - 2.0 * panelPaddingX(layout))
                let countsText = truncateTextToWidth(countsLabel, countsMaxW, layout.smallFont)
                drawTextLine(pixels, width, height, strideBytes, headerX, countsY, theme.subText, layout.smallFont, countsText)
                lineOffset = lineOffset + 1
            if vcsCount == 0:
                if len(summary) == 0:
                    let emptyY = listY + float64(lineOffset * layout.lineHeight)
                    drawTextLine(pixels, width, height, strideBytes, headerX, emptyY, theme.subText, layout.smallFont, "not loaded")
                elif summaryIsError:
                    let hintY = listY + float64(lineOffset * layout.lineHeight)
                    drawTextLine(pixels, width, height, strideBytes, headerX, hintY, theme.subText, layout.smallFont, "use Cmd/Ctrl+Shift+G to refresh")
            else:
                let visibleLines: int32 = maxInt(1, explorerVisibleLines(layout) - lineOffset)
                let listMaxW: float64 = float64(leftContentW - 2.0 * panelPaddingX(layout))
                for vcsIdx in 0..<visibleLines:
                    if vcsIdx >= vcsCount:
                        break
                    let lineText = seqGetString(state.vcsLines, vcsIdx)
                    let lineY = listY + float64(lineOffset + vcsIdx * layout.lineHeight)
                    if state.leftPaneTab == lpVcs && vcsIdx == state.hoverLeftPaneRow:
                        fillRect(pixels, width, height, strideBytes, activityW + 1, int32(lineY), leftContentW - 2, int32(layout.lineHeight), theme.lineHighlight)
                    let iconGlyph = guiVcsIconGlyph(lineText)
                    let iconColor: uint32 = guiVcsIconColor(lineText, theme)
                    var textX: float64 = headerX
                    if len(iconGlyph) > 0:
                        let iconW: float64 = textWidthForFont(iconGlyph, layout.smallFont, layout)
                        drawTextLine(pixels, width, height, strideBytes, headerX, lineY, iconColor, layout.smallFont, iconGlyph)
                        textX = headerX + iconW + 6.0 * scale
                    var textColor: uint32 = theme.text
                    if guiVcsLineHasConflict(lineText):
                        textColor = theme.diagError
                    var labelMaxW: float64 = listMaxW - (textX - headerX)
                    if labelMaxW < 0.0:
                        labelMaxW = 0.0
                    let shown = truncateTextToWidth(guiVcsDisplayLine(lineText), labelMaxW, layout.smallFont)
                    drawTextLine(pixels, width, height, strideBytes, textX, lineY, textColor, layout.smallFont, shown)
        elif state.leftPaneTab == lpRun:
            let header = "RUN"
            drawTextLine(pixels, width, height, strideBytes, headerX, leftTitleY, theme.subText, layout.headerFont, header)
            var listY: float64 = explorerListStartY(layout)
            let debugText = iconDebugLabel(layout)
            if len(debugText) > 0:
                drawTextLine(pixels, width, height, strideBytes, headerX, listY, theme.subText, layout.smallFont, debugText)
                listY = listY + layout.lineHeight
            let actionCount: int32 = runActionCount()
            let actionMaxW: float64 = float64(leftContentW - 2.0 * panelPaddingX(layout))
            for aIdx in 0..<actionCount:
                let label = runActionLabel(aIdx)
                let lineY = listY + float64(aIdx * layout.lineHeight)
                if state.leftPaneTab == lpRun && aIdx == state.hoverLeftPaneRow:
                    fillRect(pixels, width, height, strideBytes, activityW + 1, int32(lineY), leftContentW - 2, int32(layout.lineHeight), theme.lineHighlight)
                let iconGlyph = runActionGlyph(aIdx)
                var textX: float64 = headerX
                if len(iconGlyph) > 0:
                    let iconW: float64 = textWidthForFont(iconGlyph, layout.smallFont, layout)
                    drawTextLine(pixels, width, height, strideBytes, headerX, lineY, theme.subText, layout.smallFont, iconGlyph)
                    textX = headerX + iconW + 6.0 * scale
                var labelMaxW: float64 = actionMaxW - (textX - headerX)
                if labelMaxW < 0.0:
                    labelMaxW = 0.0
                let shown = truncateTextToWidth(label, labelMaxW, layout.smallFont)
                drawTextLine(pixels, width, height, strideBytes, textX, lineY, theme.text, layout.smallFont, shown)
        elif state.leftPaneTab == lpExtensions:
            let header = "EXTENSIONS"
            drawTextLine(pixels, width, height, strideBytes, headerX, leftTitleY, theme.subText, layout.headerFont, header)
            var listY: float64 = explorerListStartY(layout)
            let debugText = iconDebugLabel(layout)
            if len(debugText) > 0:
                drawTextLine(pixels, width, height, strideBytes, headerX, listY, theme.subText, layout.smallFont, debugText)
                listY = listY + layout.lineHeight
            let hintMaxW: float64 = float64(leftContentW - 2.0 * panelPaddingX(layout))
            let hintText = truncateTextToWidth("Search Extensions in Marketplace", hintMaxW, layout.smallFont)
            drawTextLine(pixels, width, height, strideBytes, headerX, listY, theme.subText, layout.smallFont, hintText)
        elif state.leftPaneTab == lpCodex:
            let panelX: int32 = activityW
            let panelW: int32 = leftContentW
            drawCodexPanel(pixels, width, height, strideBytes, theme, state, layout, panelX, contentY, panelW, contentH, contentY, state.hoverLeftPaneRow)

    if showRightPane:
        let tabTop: int32 = rightPaneTabBarTop(layout)
        let tabH: int32 = rightPaneTabBarHeight(layout)
        let paneTabTextY: float64 = rightPaneTabTextY(layout)
        var tabX: float64 = float64(rightPaneX + panelPaddingX(layout))
        let tabMaxX: float64 = float64(rightPaneX + rightPaneW - panelPaddingX(layout))
        let tabCount: int32 = rightPaneTabCount()
        for tabIdx in 0..<tabCount:
            if ! (tabX < tabMaxX):
                break
            let tab: RightPaneTab = rightPaneTabFromIndex(tabIdx)
            let label = rightPaneTabDisplay(tab)
            let textW: float64 = textWidthForFont(label, layout.smallFont, layout)
            let tabW: float64 = textW + 12.0 * scale
            if tab == state.rightPaneTab:
                fillRect(pixels, width, height, strideBytes, int32(tabX), tabTop, int32(tabW), tabH, theme.panel)
            elif tabIdx == state.hoverRightPaneTab:
                fillRect(pixels, width, height, strideBytes, int32(tabX), tabTop, int32(tabW), tabH, theme.panelAlt)
            let textX: float64 = tabX + 6.0 * scale
            let textColor: uint32 = if tab == state.rightPaneTab || tabIdx == state.hoverRightPaneTab: theme.text else: theme.subText
            drawTextLine(pixels, width, height, strideBytes, textX, paneTabTextY, textColor, layout.smallFont, label)
            tabX = tabX + tabW + 8.0 * scale
        fillRect(pixels, width, height, strideBytes, rightPaneX, tabTop + tabH - 1, rightPaneW, 1, theme.border)

        let contentTitleY: float64 = rightPaneContentTitleY(layout)
        let contentListY: float64 = rightPaneContentListStartY(layout)
        let contentLines: int32 = rightPaneContentVisibleLines(layout)
        let contentX: float64 = float64(rightPaneX + panelPaddingX(layout))
        let contentMaxW: float64 = float64(rightPaneW - 2.0 * panelPaddingX(layout))

        if state.rightPaneTab == rpOutline:
            let outlineHeader = "OUTLINE (" + intToStr(seqLenString(outlineItems)) + ")"
            drawTextLine(pixels, width, height, strideBytes, contentX, contentTitleY, theme.subText, layout.headerFont, outlineHeader)
            for oIdx in 0..<contentLines:
                if oIdx >= seqLenString(outlineItems):
                    break
                let entry = seqGetString(outlineItems, oIdx)
                let label = symbolKind(entry) + " " + symbolName(entry)
                let lineY = contentListY + float64(oIdx * layout.lineHeight)
                if oIdx == activeOutline:
                    fillRect(pixels, width, height, strideBytes, rightPaneX + 1, int32(lineY), rightPaneW - 2, int32(layout.lineHeight), theme.selection)
                elif oIdx == state.hoverRightPaneRow:
                    fillRect(pixels, width, height, strideBytes, rightPaneX + 1, int32(lineY), rightPaneW - 2, int32(layout.lineHeight), theme.lineHighlight)
                let shown = truncateTextToWidth(label, contentMaxW, layout.smallFont)
                drawTextLine(pixels, width, height, strideBytes, contentX, lineY, theme.text, layout.smallFont, shown)
        elif state.rightPaneTab == rpDiagnostics:
            let diagHeader = "PROBLEMS (E:" + intToStr(diagErrors) + " W:" + intToStr(diagWarnings) + " I:" + intToStr(diagInfos) + ")"
            drawTextLine(pixels, width, height, strideBytes, contentX, contentTitleY, theme.subText, layout.headerFont, diagHeader)
            if state.diagnostics.len == 0:
                drawTextLine(pixels, width, height, strideBytes, contentX, contentListY, theme.subText, layout.smallFont, "no issues")
            else:
                var showIdx: int32 = 0
                dIdx = 0
                for dIdx in 0..<state.diagnostics.len:
                    if showIdx >= contentLines:
                        break
                    let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(state.diagnostics, dIdx)
                    let lineY = contentListY + float64(showIdx * layout.lineHeight)
                    if showIdx == state.hoverRightPaneRow:
                        fillRect(pixels, width, height, strideBytes, rightPaneX + 1, int32(lineY), rightPaneW - 2, int32(layout.lineHeight), theme.lineHighlight)
                    let markerColor: uint32 = guiDiagColor(theme, entry.severity)
                    let iconGlyph = guiDiagIconGlyph(entry.severity)
                    var textX: float64 = contentX
                    var labelMaxW: float64 = contentMaxW
                    if len(iconGlyph) > 0:
                        let iconW: float64 = textWidthForFont(iconGlyph, layout.smallFont, layout)
                        drawTextLine(pixels, width, height, strideBytes, contentX, lineY, markerColor, layout.smallFont, iconGlyph)
                        textX = contentX + iconW + 6.0 * scale
                        labelMaxW = contentMaxW - (textX - contentX)
                    else:
                        let markerW: int32 = maxInt(2, int32(4.0 * scale))
                        fillRect(pixels, width, height, strideBytes, rightPaneX + 8, int32(lineY), markerW, int32(layout.lineHeight), markerColor)
                    if labelMaxW < 0.0:
                        labelMaxW = 0.0
                    let shown = truncateTextToWidth(guiDiagLabel(entry), labelMaxW, layout.smallFont)
                    drawTextLine(pixels, width, height, strideBytes, textX, lineY, theme.text, layout.smallFont, shown)
                    showIdx = showIdx + 1
        elif state.rightPaneTab == rpDebugger:
            let debugHeader = guiDebuggerHeader(state.debugger)
            drawTextLine(pixels, width, height, strideBytes, contentX, contentTitleY, theme.subText, layout.headerFont, debugHeader)
            let debugLines: str[] = guiDebuggerLines(state.debugger)
            if seqLenString(debugLines) == 0:
                drawTextLine(pixels, width, height, strideBytes, contentX, contentListY, theme.subText, layout.smallFont, "no debugger")
            else:
                let maxList: int32 = minInt(seqLenString(debugLines), contentLines)
                for dbgIdx in 0..<maxList:
                    let lineText = seqGetString(debugLines, dbgIdx)
                    let lineY = contentListY + float64(dbgIdx * layout.lineHeight)
                    if dbgIdx == state.hoverRightPaneRow:
                        fillRect(pixels, width, height, strideBytes, rightPaneX + 1, int32(lineY), rightPaneW - 2, int32(layout.lineHeight), theme.lineHighlight)
                    let shown = truncateTextToWidth(lineText, contentMaxW, layout.smallFont)
                    drawTextLine(pixels, width, height, strideBytes, contentX, lineY, theme.text, layout.smallFont, shown)
        elif state.rightPaneTab == rpVcs:
            let vcsHeader: str = "VCS (" + intToStr(vcsCount) + ")"
            drawTextLine(pixels, width, height, strideBytes, contentX, contentTitleY, theme.subText, layout.headerFont, vcsHeader)
            let vcsStartY: float64 = contentListY
            let vcsVisible: int32 = contentLines
            var lineOffset: int32 = 0
            let vcsCounts: VcsCounts = guiVcsCounts(state.vcsLines)
            let countsLabel = guiVcsCountsLabel(vcsCounts)
            if len(state.vcsSummary) > 0:
                let summaryText = truncateTextToWidth(state.vcsSummary, contentMaxW, layout.smallFont)
                drawTextLine(pixels, width, height, strideBytes, contentX, vcsStartY, theme.subText, layout.smallFont, summaryText)
                lineOffset = 1
            if (len(state.vcsSummary) > 0 || vcsCount > 0) && len(countsLabel) > 0:
                let countsY = vcsStartY + float64(lineOffset * layout.lineHeight)
                let countsText = truncateTextToWidth(countsLabel, contentMaxW, layout.smallFont)
                drawTextLine(pixels, width, height, strideBytes, contentX, countsY, theme.subText, layout.smallFont, countsText)
                lineOffset = lineOffset + 1
            if vcsCount == 0:
                if len(state.vcsSummary) == 0:
                    drawTextLine(pixels, width, height, strideBytes, contentX, vcsStartY, theme.subText, layout.smallFont, "not loaded")
            else:
                let maxList: int32 = maxInt(0, vcsVisible - lineOffset)
                for vcsIdx in 0..<maxList:
                    if vcsIdx >= vcsCount:
                        break
                    let lineText = seqGetString(state.vcsLines, vcsIdx)
                    let lineY = vcsStartY + float64(lineOffset + vcsIdx * layout.lineHeight)
                    if state.hoverRightPaneRow == lineOffset + vcsIdx:
                        fillRect(pixels, width, height, strideBytes, rightPaneX + 1, int32(lineY), rightPaneW - 2, int32(layout.lineHeight), theme.lineHighlight)
                    let iconGlyph = guiVcsIconGlyph(lineText)
                    let iconColor: uint32 = guiVcsIconColor(lineText, theme)
                    var textX: float64 = contentX
                    if len(iconGlyph) > 0:
                        let iconW: float64 = textWidthForFont(iconGlyph, layout.smallFont, layout)
                        drawTextLine(pixels, width, height, strideBytes, contentX, lineY, iconColor, layout.smallFont, iconGlyph)
                        textX = contentX + iconW + 6.0 * scale
                    var textColor: uint32 = theme.text
                    if guiVcsLineHasConflict(lineText):
                        textColor = theme.diagError
                    var labelMaxW: float64 = contentMaxW - (textX - contentX)
                    if labelMaxW < 0.0:
                        labelMaxW = 0.0
                    let shown = truncateTextToWidth(guiVcsDisplayLine(lineText), labelMaxW, layout.smallFont)
                    drawTextLine(pixels, width, height, strideBytes, textX, lineY, textColor, layout.smallFont, shown)
        elif state.rightPaneTab == rpCodex:
            let headerTop: int32 = rightPaneTabBarTop(layout) + rightPaneTabBarHeight(layout)
            drawCodexPanel(pixels, width, height, strideBytes, theme, state, layout, rightPaneX, contentY, rightPaneW, contentH, headerTop, state.hoverRightPaneRow)
        elif state.rightPaneTab == rpTasks:
            let taskCount: int32 = seqLenString(state.taskLog)
            let taskHeader: str = "TASKS (" + intToStr(taskCount) + ")"
            drawTextLine(pixels, width, height, strideBytes, contentX, contentTitleY, theme.subText, layout.headerFont, taskHeader)
            let tasksStartY: float64 = contentListY
            let tasksLines: int32 = contentLines
            if taskCount == 0:
                drawTextLine(pixels, width, height, strideBytes, contentX, tasksStartY, theme.subText, layout.smallFont, "no tasks")
            else:
                let taskStart: int32 = maxInt(0, taskCount - tasksLines)
                for taskIdx in 0..<tasksLines:
                    if taskStart + taskIdx >= taskCount:
                        break
                    let lineText = seqGetString(state.taskLog, taskStart + taskIdx)
                    let lineY = tasksStartY + float64(taskIdx * layout.lineHeight)
                    if taskIdx == state.hoverRightPaneRow:
                        fillRect(pixels, width, height, strideBytes, rightPaneX + 1, int32(lineY), rightPaneW - 2, int32(layout.lineHeight), theme.lineHighlight)
                    let shown = truncateTextToWidth(lineText, contentMaxW, layout.smallFont)
                    drawTextLine(pixels, width, height, strideBytes, contentX, lineY, theme.text, layout.smallFont, shown)

    fillRect(pixels, width, height, strideBytes, editorX, contentY, layout.gutterW, editorH, theme.editor)
    fillRect(pixels, width, height, strideBytes, editorX + layout.gutterW, contentY, 1, editorH, theme.border)

    if state.editor.splitActive:
        let topMetrics: EditorPaneMetrics = editorPaneMetrics(layout, 0, true)
        let bottomMetrics: EditorPaneMetrics = editorPaneMetrics(layout, 1, true)
        let topStart: int32 = normalizeVisibleLine(state.editor, scrollLineForPane(state.editor, 0))
        let bottomStart: int32 = normalizeVisibleLine(state.editor, scrollLineForPane(state.editor, 1))
        drawEditorViewport(pixels, width, height, strideBytes, theme, state, layout, topMetrics.y, topMetrics.h, topStart)
        drawEditorViewport(pixels, width, height, strideBytes, theme, state, layout, bottomMetrics.y, bottomMetrics.h, bottomStart)
        let gap: int32 = splitGap(layout)
        let dividerY: int32 = bottomMetrics.y - gap
        if gap > 0 && dividerY >= contentY && dividerY < contentY + editorH:
            fillRect(pixels, width, height, strideBytes, editorX, dividerY, editorW, gap, theme.border)
    else:
        let startLine: int32 = normalizeVisibleLine(state.editor, state.editor.scrollLine)
        drawEditorViewport(pixels, width, height, strideBytes, theme, state, layout, contentY, editorH, startLine)

    if minimapW > 0 && ! renderLite:
        drawMinimap(pixels, width, height, strideBytes, theme, state, minimapX, contentY, minimapW, editorH)

    drawCompletionPanel(pixels, width, height, strideBytes, theme, state)
    drawSignaturePanel(pixels, width, height, strideBytes, theme, state)
    drawHoverPanel(pixels, width, height, strideBytes, theme, state)

    if bottomH > 0:
        let tabH: int32 = minInt(bottomPaneTabBarHeight(layout), bottomH)
        fillRect(pixels, width, height, strideBytes, editorX, bottomY, editorW, tabH, theme.panel)
        fillRect(pixels, width, height, strideBytes, editorX, bottomY + tabH - 1, editorW, 1, theme.border)
        var tabX: float64 = float64(editorX + panelPaddingX(layout))
        let tabMaxX: float64 = float64(editorX + editorW - panelPaddingX(layout))
        let tabTextY: float64 = bottomPaneTabTextY(layout)
        for tabIdx in 0..<bottomPaneTabCount():
            if ! (tabX < tabMaxX):
                break
            let tab: BottomPaneTab = bottomPaneTabFromIndex(tabIdx)
            let label: str = bottomPaneTabDisplay(tab)
            let textW: float64 = textWidthForFont(label, layout.smallFont, layout)
            let tabW: float64 = textW + 16.0 * scale
            if tab == state.bottomPaneTab:
                fillRect(pixels, width, height, strideBytes, int32(tabX), bottomY, int32(tabW), tabH, theme.panelAlt)
            elif tabIdx == state.hoverBottomPaneTab:
                fillRect(pixels, width, height, strideBytes, int32(tabX), bottomY, int32(tabW), tabH, theme.panel)
            let textColor: uint32 = if tab == state.bottomPaneTab || tabIdx == state.hoverBottomPaneTab: theme.text else: theme.subText
            drawTextLine(pixels, width, height, strideBytes, tabX + 8.0 * scale, tabTextY, textColor, layout.smallFont, label)
            tabX = tabX + tabW + 8.0 * scale

        let panelTop: int32 = bottomPaneContentTop(layout)
        let panelH: int32 = bottomPaneContentHeight(layout)
        let panelMaxW: float64 = float64(editorW - 2.0 * panelPaddingX(layout))
        if panelH > 0:
            fillRect(pixels, width, height, strideBytes, editorX, panelTop, editorW, panelH, theme.editor)
        if state.bottomPaneTab == bpTerminal:
            let termTitleY: float64 = panelHeaderTextY(layout, panelTop)
            let termTitle: str = terminalHeaderTitle(state)
            drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), termTitleY, theme.subText, layout.headerFont, termTitle)
            drawTerminalTabs(pixels, width, height, strideBytes, theme, state)

            let termTextX: float64 = float64(editorX + panelPaddingX(layout))
            var termMaxW: float64 = float64(editorW - 2.0 * panelPaddingX(layout))
            if termMaxW < 0.0:
                termMaxW = 0.0
            let termBodyY: float64 = panelListStartY(layout, panelTop)
            let termAvail: int32 = maxInt(1, panelListVisibleLines(layout, panelH) - 1)
            let termCount: int32 = terminalVisibleLineCount(state.terminal)
            let termStart: int32 = maxInt(0, termCount - termAvail)
            for tIdx in 0..<termAvail:
                if termStart + tIdx >= termCount:
                    break
                let lineText = terminalLineAt(state.terminal, termStart + tIdx)
                let lineY = termBodyY + float64(tIdx * layout.lineHeight)
                let lineDisplay = truncateTextToWidth(lineText, termMaxW, layout.smallFont)
                drawCodeLine(pixels, width, height, strideBytes, termTextX, lineY, theme.text, layout.smallFont, lineDisplay)
            let inputY = float64(bottomY + bottomH - layout.lineHeight - 6.0 * scale)
            let inputLabel = if state.focus == fkTerminal: "> " else: "  "
            let inputDisplay = truncateTextToWidth(inputLabel + state.terminal.input, termMaxW, layout.smallFont)
            drawCodeLine(pixels, width, height, strideBytes, termTextX, inputY, theme.text, layout.smallFont, inputDisplay)
        elif state.bottomPaneTab == bpProblems:
            let headerY: float64 = panelHeaderTextY(layout, panelTop)
            let diagHeader = "PROBLEMS (E:" + intToStr(diagErrors) + " W:" + intToStr(diagWarnings) + " I:" + intToStr(diagInfos) + ")"
            drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), headerY, theme.subText, layout.headerFont, diagHeader)
            let refreshLabel = "REFRESH"
            let refreshW: float64 = textWidthForFont(refreshLabel, layout.smallFont, layout)
            let refreshX: float64 = float64(editorX + editorW - panelPaddingX(layout) - refreshW)
            drawTextLine(pixels, width, height, strideBytes, refreshX, headerY, theme.subText, layout.smallFont, refreshLabel)
            let listY: float64 = panelListStartY(layout, panelTop)
            let listLines: int32 = panelListVisibleLines(layout, panelH)
            if state.diagnostics.len == 0:
                drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), listY, theme.subText, layout.smallFont, "no issues")
            else:
                let total: int32 = state.diagnostics.len
                let maxScroll: int32 = maxInt(0, total - listLines)
                let startIdx: int32 = clampInt(state.bottomProblemsScroll, 0, maxScroll)
                var showIdx: int32 = 0
                for dIdx in startIdx..<total:
                    if showIdx >= listLines:
                        break
                    let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(state.diagnostics, dIdx)
                    let lineY = listY + float64(showIdx * layout.lineHeight)
                    if showIdx == state.hoverBottomPaneRow && dIdx != state.bottomProblemsSelected:
                        fillRect(pixels, width, height, strideBytes, editorX + 1, int32(lineY), editorW - 2, int32(layout.lineHeight), theme.lineHighlight)
                    if dIdx == state.bottomProblemsSelected:
                        fillRect(pixels, width, height, strideBytes, editorX + 1, int32(lineY), editorW - 2, int32(layout.lineHeight), theme.selection)
                    let markerColor: uint32 = guiDiagColor(theme, entry.severity)
                    let iconGlyph = guiDiagIconGlyph(entry.severity)
                    let baseX: float64 = float64(editorX + panelPaddingX(layout))
                    var textX: float64 = baseX
                    var labelMaxW: float64 = panelMaxW
                    if len(iconGlyph) > 0:
                        let iconW: float64 = textWidthForFont(iconGlyph, layout.smallFont, layout)
                        drawTextLine(pixels, width, height, strideBytes, baseX, lineY, markerColor, layout.smallFont, iconGlyph)
                        textX = baseX + iconW + 6.0 * scale
                        labelMaxW = panelMaxW - (textX - baseX)
                    else:
                        let markerW: int32 = maxInt(2, int32(4.0 * scale))
                        fillRect(pixels, width, height, strideBytes, editorX + 8, int32(lineY), markerW, int32(layout.lineHeight), markerColor)
                    if labelMaxW < 0.0:
                        labelMaxW = 0.0
                    let shown = truncateTextToWidth(guiDiagLabel(entry), labelMaxW, layout.smallFont)
                    drawTextLine(pixels, width, height, strideBytes, textX, lineY, theme.text, layout.smallFont, shown)
                    showIdx = showIdx + 1
        elif state.bottomPaneTab == bpOutput:
            let headerY: float64 = panelHeaderTextY(layout, panelTop)
            let outputCount: int32 = seqLenString(state.taskLog)
            let outputHeader = "OUTPUT (" + intToStr(outputCount) + ")"
            drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), headerY, theme.subText, layout.headerFont, outputHeader)
            let clearLabel = "CLEAR"
            let clearW: float64 = textWidthForFont(clearLabel, layout.smallFont, layout)
            let clearX: float64 = float64(editorX + editorW - panelPaddingX(layout) - clearW)
            drawTextLine(pixels, width, height, strideBytes, clearX, headerY, theme.subText, layout.smallFont, clearLabel)
            let listY: float64 = panelListStartY(layout, panelTop)
            let listLines: int32 = panelListVisibleLines(layout, panelH)
            if outputCount == 0:
                drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), listY, theme.subText, layout.smallFont, "no output")
            else:
                let maxScroll: int32 = maxInt(0, outputCount - listLines)
                let startIdx: int32 = clampInt(state.bottomOutputScroll, 0, maxScroll)
                for outIdx in 0..<listLines:
                    if startIdx + outIdx >= outputCount:
                        break
                    let entryIdx: int32 = startIdx + outIdx
                    let lineText = seqGetString(state.taskLog, entryIdx)
                    let lineY = listY + float64(outIdx * layout.lineHeight)
                    if outIdx == state.hoverBottomPaneRow && entryIdx != state.bottomOutputSelected:
                        fillRect(pixels, width, height, strideBytes, editorX + 1, int32(lineY), editorW - 2, int32(layout.lineHeight), theme.lineHighlight)
                    if entryIdx == state.bottomOutputSelected:
                        fillRect(pixels, width, height, strideBytes, editorX + 1, int32(lineY), editorW - 2, int32(layout.lineHeight), theme.selection)
                    let shown = truncateTextToWidth(lineText, panelMaxW, layout.smallFont)
                    drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), lineY, theme.text, layout.smallFont, shown)
        else:
            let headerY: float64 = panelHeaderTextY(layout, panelTop)
            drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), headerY, theme.subText, layout.headerFont, "DEBUG CONSOLE")
            let listY: float64 = panelListStartY(layout, panelTop)
            let statusLine = "status: " + state.debugger.status
            let statusShown = truncateTextToWidth(statusLine, panelMaxW, layout.smallFont)
            drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), listY, theme.text, layout.smallFont, statusShown)
            if len(state.debugger.reason) > 0:
                let reasonShown = truncateTextToWidth("reason: " + state.debugger.reason, panelMaxW, layout.smallFont)
                drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), listY + layout.lineHeight, theme.subText, layout.smallFont, reasonShown)
            else:
                drawTextLine(pixels, width, height, strideBytes, float64(editorX + panelPaddingX(layout)), listY + layout.lineHeight, theme.subText, layout.smallFont, "no debug console output")

    if layout.statusH > 0:
        fillRect(pixels, width, height, strideBytes, 0, height - layout.statusH, width, layout.statusH, theme.status)
        drawStatusBar(pixels, width, height, strideBytes, theme, state)

fn runNativeGui(frames: int, resourceRoot: str, metricsPath: str, commandPath: str, bridgeScript: str[], bridgeReportPath: str, analysisView: str, forceNativeArg: bool): str =
    metricsPath
    commandPath
    bridgeScript
    bridgeReportPath
    analysisView
    forceNativeArg
    resourceRoot

    let debugStartup: bool = envFlagEnabled(getEnv("IDE_DEBUG_STARTUP"), false)
    let debugInput: bool = envFlagEnabled(getEnv("IDE_DEBUG_INPUT"), false)
    let debugPointer: bool = debugInput || envFlagEnabled(getEnv("IDE_DEBUG_POINTER"), false)
    let inputScaleOverride: float64 = envFloatValue("IDE_INPUT_SCALE", 0.0)
    if debugStartup:
        textutils.print "[startup] runNativeGui enter\n"
    if envFlagEnabled(getEnv("IDE_DEBUG_EXPLORER_ONLY"), false):
        if debugStartup:
            textutils.print "[startup] debug-only mode\n"
        var projectRoot = getEnv("IDE_ROOT")
        if len(projectRoot) == 0:
            projectRoot = getCurrentDir()
        if debugStartup:
            textutils.print "[startup] debug root set\n"
        var roots: str[] = workspaceRootsFromEnv(projectRoot)
        if debugStartup:
            textutils.print "[startup] debug roots loaded\n"
        if seqLenString(roots) == 0:
            let labelBase = workspaceRootLabelFromPath(projectRoot)
            let label = workspaceRootUniqueLabel(roots, labelBase)
            addPtr_string(&roots, workspaceRootEntry(label, projectRoot))
        else:
            let primary = workspaceRootPath(seqGetString(roots, 0))
            if len(primary) > 0:
                projectRoot = primary
        if debugStartup:
            textutils.print "[startup] debug roots ready\n"
        let workspaceConfig: WorkspaceConfig = guiWorkspaceConfigLoad(projectRoot)
        if debugStartup:
            textutils.print "[startup] debug config loaded\n"
        loadExplorerState(roots, demoFiles, workspaceConfig)
        if debugStartup:
            textutils.print "[startup] debug done\n"
        return "[gui-native] explorer debug only\n"

    if debugStartup:
        textutils.print "[startup] initializing gui\n"
    textutils.print "[gui-native] starting\n"
    chengGuiNativeInitialize()
    if debugStartup:
        textutils.print "[startup] native initialized\n"

    let window: void* = chengGuiNativeCreateDefaultWindow("Cheng IDE GUI")
    if window == nil:
        chengGuiNativeShutdown()
        textutils.print "[gui-native] window create failed\n"
        return "[gui-native] window create failed\n"
    if debugStartup:
        textutils.print "[startup] window created\n"

    let surface: void* = chengGuiNativeCreateSurface(window)
    if surface == nil:
        chengGuiNativeDestroyWindow(window)
        chengGuiNativeShutdown()
        textutils.print "[gui-native] surface create failed\n"
        return "[gui-native] surface create failed\n"
    if debugStartup:
        textutils.print "[startup] surface created\n"

    if debugStartup:
        textutils.print "[startup] get surface info\n"
    var info: NativeSurfaceInfo
    chengGuiNativeGetSurfaceInfo(surface, &info)
    if debugStartup:
        textutils.print "[startup] surface info ok\n"

    var width: int32 = int32(info.pixelWidth)
    var height: int32 = int32(info.pixelHeight)
    var scale: float64 = info.scale
    var logicalWidth: float64 = info.logicalWidth
    var logicalHeight: float64 = info.logicalHeight
    if scale <= 0.0:
        scale = 1.0
    if width <= 0:
        width = defaultGuiWidth
    if height <= 0:
        height = defaultGuiHeight

    var strideBytes: int32 = width * 4
    var bufSize: int32 = strideBytes * height
    var pixels: void* = alloc(bufSize)
    if debugStartup:
        textutils.print "[startup] buffers allocated\n"

    let textBackend: str = if chengGuiNativeTextAvailable() != 0: $chengGuiNativeTextBackend() else: "unavailable"
    if debugStartup:
        textutils.print "[startup] text backend ready\n"

    var running = true
    var frame: int32 = 0
    var state: GuiState
    state.lastEvent = ""
    state.statusMsg = "ready"
    state.focus = fkEditor
    state.textInputSeen = false
    state.imeActive = false
    state.imeText = ""
    state.imeAnchorLine = 0
    state.imeAnchorCol = 0
    state.resizeDrag = rdNone
    state.leftPaneVisible = true
    state.leftPaneWidth = 0
    state.rightPaneWidth = 0
    state.leftPaneTab = lpExplorer
    state.rightPaneVisible = false
    state.rightPaneTab = rpOutline
    state.bottomPaneVisible = true
    state.bottomPaneTab = bpTerminal
    state.bottomPaneHeight = 0
    state.bottomProblemsScroll = 0
    state.bottomOutputScroll = 0
    state.bottomProblemsSelected = -1
    state.bottomOutputSelected = -1
    state.overlay = defaultOverlayState()
    state.search = defaultSearchState()
    state.searchProject = false
    state.searchResults = default[str[]]
    state.searchTotal = 0
    state.searchTruncated = false
    state.completion.active = false
    state.completion.items = default[str[]]
    state.completion.selected = -1
    state.completion.prefix = ""
    state.hoverActive = false
    state.hoverText = ""
    state.hoverLine = -1
    state.hoverCol = -1
    state.hoverX = 0.0
    state.hoverY = 0.0
    state.hoverTab = -1
    state.hoverTabClose = false
    state.hoverTabControl = TabControlNone
    state.hoverExplorerAction = ExplorerActionNone
    state.hoverSearchAction = SearchActionNone
    state.hoverVcsAction = VcsActionNone
    state.hoverLeftPaneTab = -1
    state.hoverLeftPaneRow = -1
    state.hoverRightPaneRow = -1
    state.hoverBottomPaneRow = -1
    state.hoverRightPaneTab = -1
    state.hoverBottomPaneTab = -1
    state.hoverActivityBottom = ActivityBottomNone
    state.signatureActive = false
    state.signatureText = ""
    state.diagnostics = diag.guiDiagNewSeq_GuiDiagnostic(0, 0)
    state.langDiagnostics = diag.guiDiagNewSeq_GuiDiagnostic(0, 0)
    state.diagLineSev = default[diag.GuiDiagSeverity[]]
    state.diagScanActive = false
    state.diagScanLine = 0
    state.diagScanVersion = 0
    state.diagScanStack = diag.guiDiagNewSeq_GuiDiagStackEntry(0, 0)
    state.diagScanDiags = diag.guiDiagNewSeq_GuiDiagnostic(0, 0)
    state.diagChunkLines = envIntValue("IDE_DIAG_CHUNK_LINES", 200)
    if state.diagChunkLines < 0:
        state.diagChunkLines = 0
    state.outlineChunkLines = envIntValue("IDE_OUTLINE_CHUNK_LINES", 200)
    if state.outlineChunkLines < 0:
        state.outlineChunkLines = 0
    state.semanticChunkLines = envIntValue("IDE_SEMANTIC_CHUNK_LINES", 200)
    if state.semanticChunkLines < 0:
        state.semanticChunkLines = 0
    state.taskLog = default[str[]]
    state.taskRunner = defaultTaskRunner()
    state.perf.enabled = envFlagEnabled(getEnv("IDE_PERF"), false)
    state.perf.logEveryMs = envIntValue("IDE_PERF_LOG_MS", 1000)
    if state.perf.logEveryMs <= 0:
        state.perf.logEveryMs = 1000
    state.perf.slowFrameMs = envIntValue("IDE_PERF_SLOW_MS", 120)
    if state.perf.slowFrameMs <= 0:
        state.perf.slowFrameMs = 120
    state.perf.lastLogMs = 0
    state.perf.frameMs = 0
    state.perf.pollMs = 0
    state.perf.eventsMs = 0
    state.perf.ptyMs = 0
    state.perf.taskMs = 0
    state.perf.codexMs = 0
    state.perf.diagMs = 0
    state.perf.renderMs = 0
    state.perf.presentMs = 0
    state.perf.slowFrames = 0
    if state.perf.enabled:
        state.perf.lastLogMs = guiNowMs()
    state.renderLiteForced = envFlagEnabled(getEnv("IDE_RENDER_LITE"), false)
    state.renderLiteThresholdMs = envIntValue("IDE_RENDER_LITE_MS", 28)
    if state.renderLiteThresholdMs <= 0:
        state.renderLiteThresholdMs = 28
    state.renderLiteHoldMax = envIntValue("IDE_RENDER_LITE_HOLD", 30)
    if state.renderLiteHoldMax < 0:
        state.renderLiteHoldMax = 0
    state.renderLiteHoldFrames = 0
    state.renderLite = state.renderLiteForced
    state.renderLastMs = 0
    state.renderDirty = true
    state.renderNextMs = 0
    state.renderMinIntervalMs = envIntValue("IDE_FRAME_MS", 16)
    if state.renderMinIntervalMs < 0:
        state.renderMinIntervalMs = 0
    state.renderIdlePollMs = envIntValue("IDE_IDLE_POLL_MS", 16)
    if state.renderIdlePollMs < 0:
        state.renderIdlePollMs = 16
    state.backgroundTickIntervalMs = envIntValue("IDE_BG_MS", 16)
    if state.backgroundTickIntervalMs < 0:
        state.backgroundTickIntervalMs = 16
    state.backgroundInteractiveDelayMs = envIntValue("IDE_BG_INTERACTIVE_MS", 120)
    if state.backgroundInteractiveDelayMs < 0:
        state.backgroundInteractiveDelayMs = 0
    state.backgroundBudgetMs = envIntValue("IDE_BG_BUDGET_MS", 6)
    if state.backgroundBudgetMs < 0:
        state.backgroundBudgetMs = 0
    state.desktopCommandPollMs = envIntValue("IDE_COMMAND_POLL_MS", 200)
    if state.desktopCommandPollMs < 0:
        state.desktopCommandPollMs = 0
    state.desktopCommandNextMs = 0
    state.desktopCommandLastId = ""
    state.backgroundTickNextMs = 0
    state.lastInputMs = 0
    state.codex = defaultCodexState()
    state.debugger = defaultDebuggerState()
    state.vcsSummary = ""
    state.vcsLines = default[str[]]
    state.vcsRoot = ""
    state.clipboard = ""
    state.draggingEditor = false
    state.dragButton = -1
    state.dragMulti = false
    state.dragAnchorLine = 0
    state.dragAnchorCol = 0
    state.dragPane = 0
    state.blockSelectActive = false
    state.blockAnchorLine = 0
    state.blockAnchorCol = 0
    state.lineSelectActive = false
    state.lineSelectAnchorLine = 0
    state.tabScrollX = 0.0
    if debugStartup:
        textutils.print "[startup] state basics\n"
    state.pendingQuit = false
    state.quitRequested = false
    let diagEnv: str = getEnv("IDE_DIAG_AUTO")
    state.diagAuto = envFlagEnabled(diagEnv, true)
    state.diagPending = false
    state.diagCooldown = 0
    let autosaveEnv: str = getEnv("IDE_AUTOSAVE")
    state.autoSave = envFlagEnabled(autosaveEnv, false)
    state.autoSavePending = false
    state.autoSaveCooldown = 0
    let formatOnSaveEnv: str = getEnv("IDE_FORMAT_ON_SAVE")
    state.formatOnSave = envFlagEnabled(formatOnSaveEnv, false)
    let recoveryEnv: str = getEnv("IDE_RECOVERY")
    state.recoveryEnabled = envFlagEnabled(recoveryEnv, true)
    if len(getEnv("IDE_SKIP_IO")) > 0:
        state.recoveryEnabled = false
    state.recoveryPending = false
    state.recoveryCooldown = 0
    state = guiSetDiagnosticsDirty(state)
    if debugStartup:
        textutils.print "[startup] diagnostics set\n"
    state.projectRoot = getEnv("IDE_ROOT")
    if len(state.projectRoot) == 0:
        state.projectRoot = getCurrentDir()
    state.workspaceRoots = workspaceRootsFromEnv(state.projectRoot)
    if seqLenString(state.workspaceRoots) == 0:
        let labelBase = workspaceRootLabelFromPath(state.projectRoot)
        let label = workspaceRootUniqueLabel(state.workspaceRoots, labelBase)
        addPtr_string(&state.workspaceRoots, workspaceRootEntry(label, state.projectRoot))
    else:
        let primary = workspaceRootPath(seqGetString(state.workspaceRoots, 0))
        if len(primary) > 0:
            state.projectRoot = primary
    guiApplyEnvDefaults(state.projectRoot)
    if debugStartup:
        textutils.print "[startup] roots ready\n"
    state.projectSymbols = default[str[]]
    state.projectSymbolCache = default[ProjectSymbolCacheEntry[]]
    state.projectIndexReady = false
    state.projectScanActive = false
    state.projectScanIndex = 0
    state.projectScanFiles = default[str[]]
    state.projectScanSymbols = default[str[]]
    state.projectChunkFiles = envIntValue("IDE_PROJECT_CHUNK_FILES", 16)
    if state.projectChunkFiles < 0:
        state.projectChunkFiles = 0
    let workspaceConfig: WorkspaceConfig = guiWorkspaceConfigLoad(state.projectRoot)
    state.explorer = loadExplorerState(state.workspaceRoots, demoFiles, workspaceConfig)
    if debugStartup:
        textutils.print "[startup] explorer loaded\n"
    state.editor = loadEditorState("", "")
    state = guiVcsRefreshSilent(state)
    if debugStartup:
        textutils.print "[startup] vcs refreshed\n"
    state.terminalSessionCounter = 1
    state.terminal = initTerminalState("term-1")
    state.terminalSessions = newTerminalSessionList()
    terminalSessionInsert(&state.terminalSessions, 0, state.terminal)
    state.terminalSessionActive = 0
    if debugStartup:
        textutils.print "[startup] terminal ready\n"
    state = guiCodexApplyStartFocus(state)
    let skipIO: str = getEnv("IDE_SKIP_IO")
    let openEnv: str = getEnv("IDE_OPEN")
    var workspaceState: WorkspaceState = defaultWorkspaceState()
    let useWorkspace: bool = len(skipIO) == 0 && len(openEnv) == 0
    if useWorkspace:
        workspaceState = guiWorkspaceStateLoad(state.projectRoot)
    if debugStartup:
        textutils.print "[startup] workspace state loaded\n"
    var filePath: str = ""
    if len(openEnv) > 0:
        filePath = openEnv
    elif useWorkspace:
        filePath = guiWorkspacePickInitialFile(state.workspaceRoots, state.projectRoot, workspaceState)
    if len(filePath) == 0:
        filePath = "doc/cheng-dev-plan.md"
    if len(skipIO) > 0:
        filePath = ""
    if len(filePath) > 0:
        filePath = resolveWorkspacePath(state, filePath)
        if ! fileExists(filePath):
            state.statusMsg = "open failed: " + filePath
            state.terminal = pushTerminalLine(state.terminal, state.statusMsg)
            filePath = ""
    state.editor = loadEditorState(filePath, demoCode)
    var recovered: bool = false
    if len(filePath) > 0:
        let recovery: RecoveryLoad = guiRecoveryMaybeLoad(state, state.editor)
        state.editor = recovery.editor
        recovered = recovery.recovered
    if len(filePath) > 0:
        if recovered:
            state.statusMsg = "recovered: " + filePath
        else:
            state.statusMsg = "open: " + filePath
    if debugStartup:
        textutils.print "[startup] editor loaded\n"
    state.buffers = newBufferList()
    bufferInsert(&state.buffers, 0, state.editor)
    state.activeBuffer = 0
    state = clampPaneSizes(state, width, height, scale)
    state.layout = calcLayout(state, width, height, scale)
    state.layoutKey = calcLayoutKey(state, width, height, scale)
    if debugStartup:
        textutils.print "[startup] layout ready\n"
    if useWorkspace:
        state = guiWorkspaceStateApply(state, workspaceState)
        state.explorer = explorerCollapseAll(state.explorer)
        state = clampPaneSizes(state, width, height, scale)
        state.layout = calcLayout(state, width, height, scale)
        state.layoutKey = calcLayoutKey(state, width, height, scale)
    if len(state.editor.filePath) > 0:
        state = guiRevealExplorerPath(state, state.editor.filePath)
    let themeEnv: str = getEnv("IDE_THEME")
    if len(themeEnv) > 0:
        state = guiSetThemeSilent(state, themeEnv)
    elif len(state.themeName) == 0:
        state = guiSetThemeSilent(state, "dark")
    if debugStartup:
        textutils.print "[startup] theme ready\n"
    state = guiDesktopBridgeSave(state)
    let maxEvents: int32 = 64
    let evStride: int32 = int32(chengGuiNativeEventStructSize())
    let evBytes: int32 = evStride * maxEvents
    let events: void* = alloc(evBytes)
    if debugStartup:
        textutils.print "[startup] events allocated\n"
    let eventLayout: EventLayout = detectEventLayout(evStride)
    let textOffset: int32 = eventTextOffset(eventLayout)
    let modifiersOffset: int32 = eventModifiersOffset(eventLayout)
    let keyCodeOffset: int32 = eventKeyCodeOffset(eventLayout)
    let xOffset: int32 = eventXOffset(eventLayout)
    let yOffset: int32 = eventYOffset(eventLayout)
    let deltaYOffset: int32 = eventDeltaYOffset(eventLayout)
    let buttonOffset: int32 = eventButtonOffset(eventLayout)

    while running:
        var perfFrameStartMs: int64 = 0
        var perfPollStartMs: int64 = 0
        var perfEventsStartMs: int64 = 0
        var perfPtyStartMs: int64 = 0
        var perfTaskStartMs: int64 = 0
        var perfCodexStartMs: int64 = 0
        var perfDiagStartMs: int64 = 0
        var perfRenderStartMs: int64 = 0
        var perfPresentStartMs: int64 = 0
        if state.perf.enabled:
            perfFrameStartMs = guiNowMs()
        state = clampPaneSizes(state, width, height, scale)
        let layoutKeyNow: int64 = calcLayoutKey(state, width, height, scale)
        if layoutKeyNow != state.layoutKey:
            state.layout = calcLayout(state, width, height, scale)
            state.layoutKey = layoutKeyNow
        state = tabStripClamp(state, tabStripWidth(state.layout))
        if state.perf.enabled:
            perfPollStartMs = guiNowMs()
        var pollTimeoutMs: int32 = 8
        if state.renderIdlePollMs > 0 && ! state.renderDirty:
            pollTimeoutMs = maxInt(pollTimeoutMs, state.renderIdlePollMs)
        if state.renderMinIntervalMs > 0 && state.renderDirty:
            let nowMs: int64 = guiNowMs()
            if state.renderNextMs > nowMs:
                let waitMs: int32 = guiMsDiff(nowMs, state.renderNextMs)
                if waitMs > pollTimeoutMs:
                    pollTimeoutMs = waitMs
        let got: int32 = chengGuiNativePollEvents(events, int32(maxEvents), pollTimeoutMs)
        let baseScale: float64 = computeInputScale(scale, logicalWidth, logicalHeight, float64(width), float64(height))
        let inputScale: float64 = if inputScaleOverride > 0.0: inputScaleOverride else: baseScale
        if baseScale > 0.0:
            var scaleDiff: float64 = baseScale - scale
            if scaleDiff < 0.0:
                scaleDiff = -scaleDiff
            if scaleDiff > 0.001:
                scale = baseScale
                state = clampPaneSizes(state, width, height, scale)
                let updatedKey: int64 = calcLayoutKey(state, width, height, scale)
                if updatedKey != state.layoutKey:
                    state.layout = calcLayout(state, width, height, scale)
                    state.layoutKey = updatedKey
        if state.perf.enabled:
            let pollEndMs = guiNowMs()
            state.perf.pollMs = guiMsDiff(perfPollStartMs, pollEndMs)
            perfEventsStartMs = pollEndMs
        if got > 0:
            var cursorDirty = false
            var scrollDirty = false
            var backspaceKeyDown = false
            var undoKeyDown = false
            var redoKeyDown = false
            var skipNextText = false
            var skipTextChar: char = '\0'
            var pendingShiftBase: char = '\0'
            var pendingShiftMapped: char = '\0'
            var batchHasTextInput = false
            var batchHasIme = false
            for scan in 0..<got:
                let scanEv: void* = ptr_add(events, scan * evStride)
                let scanKind: int32 = loadI32(scanEv, 0)
                if scanKind == 6:
                    let scanText = loadText(scanEv, textOffset)
                    if len(scanText) > 0:
                        batchHasTextInput = true
                elif scanKind == 12 || scanKind == 13 || scanKind == 14:
                    batchHasIme = true
            for i in 0..<got:
                let ev: void* = ptr_add(events, i * evStride)
                let kind: int32 = loadI32(ev, 0)
                if kind == 1:
                    if state.editor.dirty:
                        state.pendingQuit = true
                        state = startOverlay(state, okCloseDirty)
                        state.statusMsg = "close: unsaved"
                        state.lastEvent = "close-prompt"
                    else:
                        state.lastEvent = "close"
                        running = false
                        break
                if kind == 6:
                    state = guiClearHover(state)
                    let rawText = loadText(ev, textOffset)
                    if state.imeActive && state.focus == fkEditor && state.overlay.kind == okNone && len(rawText) > 0:
                        state.imeActive = false
                        state.imeText = ""
                    if debugInput:
                        let mods: uint32 = loadU32(ev, modifiersOffset)
                        var focusLabel: str = "terminal"
                        if state.focus == fkEditor:
                            focusLabel = "editor"
                        elif state.focus == fkExplorer:
                            focusLabel = "explorer"
                        elif state.focus == fkCodex:
                            focusLabel = "codex"
                        var shown: str = "<empty>"
                        if len(rawText) > 0:
                            shown = rawText
                        textutils.print("[input] text focus=" + focusLabel + " mods=" + intToStr(int32(mods)) + " raw=" + shown + "\n")
                    if len(rawText) > 0:
                        state.textInputSeen = true
                        state.blockSelectActive = false
                        state.lineSelectActive = false
                        let mods: uint32 = loadU32(ev, modifiersOffset)
                        var text: str = applyShiftTextInput(rawText, eventLayout, mods)
                        text = normalizeFullWidthAscii(text)
                        if pendingShiftMapped != '\0':
                            if len(rawText) == 1 && rawText[0] == pendingShiftBase:
                                text = charToStr(pendingShiftMapped)
                            pendingShiftBase = '\0'
                            pendingShiftMapped = '\0'
                        if skipNextText:
                            if skipTextChar == '\0' || (len(text) == 1 && text[0] == skipTextChar):
                                if debugInput:
                                    let shown = if len(text) > 0: debugEscapeText(text, 8) else: "<empty>"
                                    let skipShown = if skipTextChar == '\0': "<any>" else: debugEscapeText(charToStr(skipTextChar), 1)
                                    textutils.print("[input] text skip-next text=" + shown + " skip=" + skipShown + "\n")
                                skipNextText = false
                                continue
                            if debugInput:
                                let shown = if len(text) > 0: debugEscapeText(text, 8) else: "<empty>"
                                let skipShown = if skipTextChar == '\0': "<any>" else: debugEscapeText(charToStr(skipTextChar), 1)
                                textutils.print("[input] text skip-next mismatch text=" + shown + " skip=" + skipShown + "\n")
                            skipNextText = false
                        if len(text) == 1 && (text[0] == '\x08' || text[0] == '\x7f'):
                            if ! backspaceKeyDown && (! state.imeActive || len(state.imeText) == 0):
                                if state.overlay.kind != okNone:
                                    state.overlay = overlayBackspace(state.overlay)
                                    state.lastEvent = "overlay-backspace"
                                elif state.focus == fkCodex:
                                    if ! state.codex.overlayActive:
                                        state.codex = codexInputBackspace(state.codex)
                                        state.lastEvent = "codex-backspace"
                                elif state.focus == fkTerminal:
                                    state.terminal = terminalBackspace(state.terminal)
                                    state.lastEvent = "terminal-backspace"
                                elif state.focus == fkEditor:
                                    state.editor = editorBackspace(state.editor)
                                    cursorDirty = true
                                    state = guiSetDiagnosticsDirty(state)
                                    state.lastEvent = "backspace"
                            continue
                        let undoModsOk: bool = hasPrimaryModifier(eventLayout, mods) || (eventLayout == elMac && hasCtrl(eventLayout, mods))
                        if undoModsOk && len(text) == 1:
                            if ! undoKeyDown && (text[0] == 'z' || text[0] == 'Z'):
                                if hasShift(eventLayout, mods):
                                    state = guiRedo(state)
                                    state.lastEvent = "redo"
                                else:
                                    state = guiUndo(state)
                                    state.lastEvent = "undo"
                                cursorDirty = true
                                continue
                            if ! redoKeyDown && (text[0] == 'y' || text[0] == 'Y'):
                                state = guiRedo(state)
                                state.lastEvent = "redo"
                                cursorDirty = true
                                continue
                        if state.overlay.kind != okNone:
                            state.overlay = overlayInsertText(state.overlay, text)
                            state.lastEvent = "overlay-text"
                        elif state.focus == fkCodex:
                            if ! state.codex.overlayActive && ! hasPrimaryModifier(eventLayout, mods) && ! hasCtrl(eventLayout, mods) && ! hasAlt(eventLayout, mods):
                                state.codex = codexInputInsertText(state.codex, text)
                                state.lastEvent = "codex-text"
                        elif state.focus == fkTerminal:
                            if state.terminal.mode == tmPty:
                                if len(text) == 1 && (text[0] == '\r' || text[0] == '\n' || text[0] == '\t' || text[0] == '\x08' || text[0] == '\x7f'):
                                    0
                                else:
                                    state = guiPtySendRawInput(state, text)
                                    state.lastEvent = "terminal-pty-text"
                            else:
                                state.terminal = insertTerminalText(state.terminal, text)
                                state.lastEvent = "terminal-text"
                        elif state.focus == fkEditor:
                            if ! hasPrimaryModifier(eventLayout, mods) && ! hasCtrl(eventLayout, mods) && ! hasAlt(eventLayout, mods):
                                state.editor = clearSelectionHistory(state.editor)
                                state.editor = editorInsertTextInput(state.editor, text)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "text"
                                if debugInput:
                                    let shown = if len(text) > 0: debugEscapeText(text, 8) else: "<empty>"
                                    textutils.print("[input] text insert=" + shown + "\n")
                                if state.completion.active:
                                    state = updateCompletion(state)
                                else:
                                    state = tryAutoCompletion(state, text)
                            elif debugInput:
                                let shown = if len(text) > 0: debugEscapeText(text, 8) else: "<empty>"
                                textutils.print("[input] text ignore=modifier text=" + shown + "\n")
                elif kind == 12:
                    let rawText = loadText(ev, textOffset)
                    if state.focus == fkEditor && state.overlay.kind == okNone:
                        state.imeActive = true
                        state.imeText = rawText
                        state.imeAnchorLine = state.editor.cursorLine
                        state.imeAnchorCol = state.editor.cursorCol
                        state.lastEvent = "ime-start"
                    else:
                        state.imeActive = false
                        state.imeText = ""
                elif kind == 13:
                    let rawText = loadText(ev, textOffset)
                    if state.focus == fkEditor && state.overlay.kind == okNone:
                        if len(rawText) == 0:
                            state.imeActive = false
                            state.imeText = ""
                        else:
                            if ! state.imeActive:
                                state.imeAnchorLine = state.editor.cursorLine
                                state.imeAnchorCol = state.editor.cursorCol
                            state.imeActive = true
                            state.imeText = rawText
                        state.lastEvent = "ime-update"
                    else:
                        state.imeActive = false
                        state.imeText = ""
                elif kind == 14:
                    state.imeActive = false
                    state.imeText = ""
                    state.lastEvent = "ime-end"
                elif kind == 4:
                    state = guiClearHover(state)
                    let keyCode: uint32 = loadU32(ev, keyCodeOffset)
                    let mods: uint32 = loadU32(ev, modifiersOffset)
                    let keyText: str = loadText(ev, textOffset)
                    if debugInput:
                        var focusLabel: str = "terminal"
                        if state.focus == fkEditor:
                            focusLabel = "editor"
                        elif state.focus == fkExplorer:
                            focusLabel = "explorer"
                        elif state.focus == fkCodex:
                            focusLabel = "codex"
                        var shown: str = "<empty>"
                        if len(keyText) > 0:
                            shown = keyText
                        textutils.print("[input] key focus=" + focusLabel + " code=" + intToStr(int32(keyCode)) + " mods=" + intToStr(int32(mods)) + " text=" + shown + "\n")
                    var handled = false
                    let blockSelectMod: bool = hasAlt(eventLayout, mods) && hasShift(eventLayout, mods) && ! hasPrimaryModifier(eventLayout, mods) && ! hasCtrl(eventLayout, mods)
                    let expandSelectKey: bool = blockSelectMod && (keyIsArrowLeft(eventLayout, keyCode) || keyIsArrowRight(eventLayout, keyCode))
                    let shiftOnly: bool = hasShift(eventLayout, mods) && ! hasPrimaryModifier(eventLayout, mods) && ! hasCtrl(eventLayout, mods) && ! hasAlt(eventLayout, mods)
                    if shiftOnly:
                        var baseChar: char = '\0'
                        if len(keyText) == 1:
                            baseChar = keyText[0]
                        else:
                            baseChar = keyCodeBaseCharForMods(eventLayout, mods, keyCode)
                        let mapped: char = shiftSymbolForKey(baseChar)
                        if mapped != '\0':
                            pendingShiftBase = baseChar
                            pendingShiftMapped = mapped
                        else:
                            pendingShiftBase = '\0'
                            pendingShiftMapped = '\0'
                    else:
                        pendingShiftBase = '\0'
                        pendingShiftMapped = '\0'
                    if ! blockSelectMod && state.blockSelectActive:
                        state.blockSelectActive = false
                    if state.lineSelectActive && ! blockSelectMod:
                        state.lineSelectActive = false
                    if state.focus == fkEditor && ! expandSelectKey:
                        state.editor = clearSelectionHistory(state.editor)
                    if keyIsBackspace(eventLayout, keyCode):
                        backspaceKeyDown = true
                    if state.overlay.kind != okNone:
                        if keyIsEscape(eventLayout, keyCode):
                            state = cancelOverlay(state)
                        elif keyIsEnter(eventLayout, keyCode):
                            state = commitOverlay(state)
                        elif keyIsBackspace(eventLayout, keyCode):
                            state.overlay = overlayBackspace(state.overlay)
                        state.lastEvent = "overlay-key"
                        handled = true
                    else:
                        if state.focus == fkCodex:
                            let ctrlHeld: bool = hasCtrl(eventLayout, mods)
                            let altHeld: bool = hasAlt(eventLayout, mods)
                            var baseChar: char = keyCodeBaseCharForMods(eventLayout, mods, keyCode)
                            if baseChar >= 'A' && baseChar <= 'Z':
                                baseChar = chr(ord(baseChar) + 32)
                            let isQuitKey: bool = ctrlHeld && (baseChar == 'c' || baseChar == 'd')
                            if state.codex.quitArmed && ! isQuitKey:
                                state.codex.quitArmed = false
                                state.codex.quitArmedKey = ""
                                state.codex.quitArmedUntilMs = 0
                            if state.codex.overlayActive:
                                if ctrlHeld && baseChar == 't':
                                    state.codex.overlayActive = false
                                    state.codex.overlayScroll = 0
                                    state.lastEvent = "codex-overlay-toggle"
                                    handled = true
                                elif keyIsEscape(eventLayout, keyCode):
                                    state.codex.overlayActive = false
                                    state.codex.overlayScroll = 0
                                    state.lastEvent = "codex-overlay-close"
                                    handled = true
                                elif keyIsArrowUp(eventLayout, keyCode):
                                    state.codex.overlayScroll = state.codex.overlayScroll + 1
                                    state.lastEvent = "codex-overlay-up"
                                    handled = true
                                elif keyIsArrowDown(eventLayout, keyCode):
                                    state.codex.overlayScroll = maxInt(0, state.codex.overlayScroll - 1)
                                    state.lastEvent = "codex-overlay-down"
                                    handled = true
                                elif keyIsPageUp(eventLayout, keyCode):
                                    state.codex.overlayScroll = state.codex.overlayScroll + 5
                                    state.lastEvent = "codex-overlay-page-up"
                                    handled = true
                                elif keyIsPageDown(eventLayout, keyCode):
                                    state.codex.overlayScroll = maxInt(0, state.codex.overlayScroll - 5)
                                    state.lastEvent = "codex-overlay-page-down"
                                    handled = true
                                else:
                                    handled = true
                            if ! handled:
                                if ctrlHeld && baseChar == 't':
                                    state.codex.overlayActive = ! state.codex.overlayActive
                                    state.codex.overlayScroll = 0
                                    state.lastEvent = "codex-overlay-toggle"
                                    handled = true
                                elif ctrlHeld && baseChar == 'g':
                                    if ! state.codex.overlayActive:
                                        state = guiCodexStartDraft(state)
                                    state.lastEvent = "codex-draft"
                                    handled = true
                                elif ctrlHeld && baseChar == 'c':
                                    if len(state.codex.input) > 0:
                                        state = guiCodexRecordHistory(state, state.codex.input)
                                        state.codex.input = ""
                                        state.codex.inputHistoryIndex = -1
                                        state.codex.inputHistoryStash = ""
                                        state.statusMsg = "codex: cleared"
                                        state.lastEvent = "codex-clear"
                                    else:
                                        let nowMs = guiNowMs()
                                        let key = "ctrl+c"
                                        if state.codex.quitArmed && state.codex.quitArmedKey == key && nowMs <= state.codex.quitArmedUntilMs:
                                            state.quitRequested = true
                                            state.codex.quitArmed = false
                                        else:
                                            state.codex.quitArmed = true
                                            state.codex.quitArmedKey = key
                                            state.codex.quitArmedUntilMs = nowMs + 1000
                                            state.statusMsg = "codex: press ctrl+c to quit"
                                        if guiCodexIsRunning(state):
                                            state = guiCodexInterrupt(state)
                                        state.lastEvent = "codex-ctrl-c"
                                    handled = true
                                elif ctrlHeld && baseChar == 'd':
                                    if len(trimLine(state.codex.input)) == 0:
                                        let nowMs = guiNowMs()
                                        let key = "ctrl+d"
                                        if state.codex.quitArmed && state.codex.quitArmedKey == key && nowMs <= state.codex.quitArmedUntilMs:
                                            state.quitRequested = true
                                            state.codex.quitArmed = false
                                        else:
                                            state.codex.quitArmed = true
                                            state.codex.quitArmedKey = key
                                            state.codex.quitArmedUntilMs = nowMs + 1000
                                            state.statusMsg = "codex: press ctrl+d to quit"
                                        state.lastEvent = "codex-ctrl-d"
                                        handled = true
                                elif altHeld && keyIsArrowUp(eventLayout, keyCode):
                                    state = guiCodexRecallQueued(state)
                                    state.lastEvent = "codex-queue-recall"
                                    handled = true
                                elif ctrlHeld && baseChar == 'p':
                                    state = guiCodexHistoryPrev(state)
                                    state.lastEvent = "codex-history-prev"
                                    handled = true
                                elif ctrlHeld && baseChar == 'n':
                                    state = guiCodexHistoryNext(state)
                                    state.lastEvent = "codex-history-next"
                                    handled = true
                                elif keyIsArrowUp(eventLayout, keyCode):
                                    if len(state.codex.input) == 0 || state.codex.inputHistoryIndex >= 0:
                                        state = guiCodexHistoryPrev(state)
                                        state.lastEvent = "codex-history-prev"
                                    else:
                                        state.codex.scroll = state.codex.scroll + 1
                                        state.lastEvent = "codex-scroll-up"
                                    handled = true
                                elif keyIsArrowDown(eventLayout, keyCode):
                                    if len(state.codex.input) == 0 || state.codex.inputHistoryIndex >= 0:
                                        state = guiCodexHistoryNext(state)
                                        state.lastEvent = "codex-history-next"
                                    else:
                                        state.codex.scroll = maxInt(0, state.codex.scroll - 1)
                                        state.lastEvent = "codex-scroll-down"
                                    handled = true
                                elif keyIsPageUp(eventLayout, keyCode):
                                    state.codex.scroll = state.codex.scroll + 5
                                    state.lastEvent = "codex-page-up"
                                    handled = true
                                elif keyIsPageDown(eventLayout, keyCode):
                                    state.codex.scroll = maxInt(0, state.codex.scroll - 5)
                                    state.lastEvent = "codex-page-down"
                                    handled = true
                                elif keyIsEnter(eventLayout, keyCode):
                                    if hasShift(eventLayout, mods):
                                        state.codex.input = state.codex.input + "\n"
                                        state.lastEvent = "codex-newline"
                                    else:
                                        let prompt = state.codex.input
                                        var feedbackHandled = false
                                        var feedbackClear = false
                                        state = guiCodexFeedbackHandleInput(state, prompt, feedbackHandled, feedbackClear)
                                        if feedbackHandled:
                                            if feedbackClear:
                                                state.codex.input = ""
                                            state.lastEvent = "codex-feedback"
                                        else:
                                            var cmdHandled = false
                                            var cmdClear = false
                                            state = guiCodexHandleSlashCommand(state, prompt, cmdHandled, cmdClear)
                                            if cmdHandled:
                                                if cmdClear:
                                                    state.codex.input = ""
                                                state.lastEvent = "codex-command"
                                            else:
                                                state = guiCodexAsk(state, prompt)
                                                state.codex.input = ""
                                                state.lastEvent = "codex-send"
                                    handled = true
                                elif keyIsTab(eventLayout, keyCode):
                                    let prompt = state.codex.input
                                    var feedbackHandled = false
                                    var feedbackClear = false
                                    state = guiCodexFeedbackHandleInput(state, prompt, feedbackHandled, feedbackClear)
                                    if feedbackHandled:
                                        if feedbackClear:
                                            state.codex.input = ""
                                        state.lastEvent = "codex-feedback"
                                    else:
                                        var cmdHandled = false
                                        var cmdClear = false
                                        state = guiCodexHandleSlashCommand(state, prompt, cmdHandled, cmdClear)
                                        if cmdHandled:
                                            if cmdClear:
                                                state.codex.input = ""
                                            state.lastEvent = "codex-command"
                                        else:
                                            if guiCodexIsBusy(state):
                                                state = guiCodexQueuePrompt(state, prompt)
                                                state.lastEvent = "codex-queue"
                                            else:
                                                state = guiCodexAsk(state, prompt)
                                                state.lastEvent = "codex-send"
                                            state.codex.input = ""
                                    handled = true
                                elif keyIsBackspace(eventLayout, keyCode):
                                    state.codex = codexInputBackspace(state.codex)
                                    state.lastEvent = "codex-backspace"
                                    handled = true
                                elif keyIsEscape(eventLayout, keyCode):
                                    if state.codex.feedbackStep != cfsNone:
                                        state = guiCodexFeedbackCancel(state)
                                        state.codex.input = ""
                                        state.lastEvent = "codex-feedback-cancel"
                                    elif guiCodexIsRunning(state) && len(trimLine(state.codex.input)) == 0:
                                        state = guiCodexInterrupt(state)
                                        state.lastEvent = "codex-interrupt"
                                    else:
                                        state.codex.input = ""
                                        state.focus = fkEditor
                                        state.lastEvent = "codex-escape"
                                    handled = true
                        let completionMod: bool = hasCtrl(eventLayout, mods) || hasPrimaryModifier(eventLayout, mods)
                        if state.focus == fkEditor && state.completion.active:
                            if keyIsArrowUp(eventLayout, keyCode):
                                state.completion = moveCompletionSelection(state.completion, -1)
                                state.lastEvent = "complete-up"
                                handled = true
                            elif keyIsArrowDown(eventLayout, keyCode):
                                state.completion = moveCompletionSelection(state.completion, 1)
                                state.lastEvent = "complete-down"
                                handled = true
                            elif keyIsPageUp(eventLayout, keyCode):
                                state.completion = moveCompletionSelection(state.completion, -5)
                                state.lastEvent = "complete-page-up"
                                handled = true
                            elif keyIsPageDown(eventLayout, keyCode):
                                state.completion = moveCompletionSelection(state.completion, 5)
                                state.lastEvent = "complete-page-down"
                                handled = true
                            elif keyIsEnter(eventLayout, keyCode) || keyIsTab(eventLayout, keyCode):
                                state = acceptCompletion(state)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "complete-accept"
                                handled = true
                            elif keyIsEscape(eventLayout, keyCode):
                                state = cancelCompletion(state)
                                state.lastEvent = "complete-cancel"
                                handled = true
                        if ! handled && state.focus == fkEditor:
                            let multiCursorMod: bool = hasAlt(eventLayout, mods) && hasPrimaryModifier(eventLayout, mods) && ! hasShift(eventLayout, mods)
                            if multiCursorMod && (keyIsArrowUp(eventLayout, keyCode) || keyIsArrowDown(eventLayout, keyCode)):
                                let delta: int32 = if keyIsArrowUp(eventLayout, keyCode): -1 else: 1
                                state.editor = addMultiCursorVertical(state.editor, delta)
                                cursorDirty = true
                                state.lastEvent = if delta < 0: "multi-up" else: "multi-down"
                                handled = true
                        if ! handled && state.focus == fkEditor:
                            if blockSelectMod && (keyIsArrowUp(eventLayout, keyCode) || keyIsArrowDown(eventLayout, keyCode)):
                                if ! state.blockSelectActive:
                                    state.blockSelectActive = true
                                    state.blockAnchorLine = state.editor.cursorLine
                                    state.blockAnchorCol = state.editor.cursorCol
                                let delta: int32 = if keyIsArrowUp(eventLayout, keyCode): -1 else: 1
                                let targetLine: int32 = clampIndex(state.editor.cursorLine + delta, seqLenString(state.editor.lines))
                                state.editor = setMultiCursorsFromRange(state.editor, state.blockAnchorLine, targetLine, state.blockAnchorCol)
                                cursorDirty = true
                                state.lastEvent = if delta < 0: "block-up" else: "block-down"
                                handled = true
                        if ! handled && state.focus == fkEditor && expandSelectKey:
                            state.blockSelectActive = false
                            state.lineSelectActive = false
                            if keyIsArrowRight(eventLayout, keyCode):
                                state.editor = expandSelection(state.editor)
                                state.lastEvent = "select-expand"
                            else:
                                state.editor = shrinkSelection(state.editor)
                                state.lastEvent = "select-shrink"
                            cursorDirty = true
                            handled = true
                        if ! handled && state.focus == fkEditor:
                            let lineMoveMod: bool = hasAlt(eventLayout, mods) && ! hasShift(eventLayout, mods) && ! hasPrimaryModifier(eventLayout, mods) && ! hasCtrl(eventLayout, mods)
                            if lineMoveMod && (keyIsArrowUp(eventLayout, keyCode) || keyIsArrowDown(eventLayout, keyCode)):
                                let delta: int32 = if keyIsArrowUp(eventLayout, keyCode): -1 else: 1
                                state.editor = moveSelectionLines(state.editor, delta)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = if delta < 0: "line-move-up" else: "line-move-down"
                                handled = true
                        if ! handled && state.focus == fkEditor:
                            let shiftOnlyTab: bool = hasShift(eventLayout, mods) && ! hasPrimaryModifier(eventLayout, mods) && ! hasCtrl(eventLayout, mods) && ! hasAlt(eventLayout, mods)
                            if shiftOnlyTab && keyIsTab(eventLayout, keyCode):
                                state.editor = editorOutdent(state.editor)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "outdent"
                                handled = true
                        if ! handled && state.focus == fkEditor:
                            let wordMoveMod: bool = wordMoveModifier(eventLayout, mods)
                            let wordMoveKey: bool = keyIsArrowLeft(eventLayout, keyCode) || keyIsArrowRight(eventLayout, keyCode)
                            if wordMoveMod && wordMoveKey:
                                let shiftHeld: bool = hasShift(eventLayout, mods)
                                let moveLeft: bool = keyIsArrowLeft(eventLayout, keyCode)
                                if shiftHeld && ! blockSelectMod:
                                    state.editor = clearMultiCursors(state.editor)
                                    state.editor = startSelection(state.editor)
                                    if moveLeft:
                                        state.editor = moveCursorWordLeftAll(state.editor)
                                    else:
                                        state.editor = moveCursorWordRightAll(state.editor)
                                    cursorDirty = true
                                    if state.completion.active:
                                        state = updateCompletion(state)
                                    state.lastEvent = "select-word"
                                else:
                                    if state.editor.selectionActive:
                                        state.editor = clearSelection(state.editor)
                                    if moveLeft:
                                        state.editor = moveCursorWordLeftAll(state.editor)
                                    else:
                                        state.editor = moveCursorWordRightAll(state.editor)
                                    cursorDirty = true
                                    if state.completion.active:
                                        state = updateCompletion(state)
                                    state.lastEvent = "word-move"
                                handled = true
                        if ! handled && state.focus == fkEditor:
                            let shiftHeld: bool = hasShift(eventLayout, mods)
                            let movementKey: bool = keyIsArrowUp(eventLayout, keyCode) || keyIsArrowDown(eventLayout, keyCode) || keyIsArrowLeft(eventLayout, keyCode) || keyIsArrowRight(eventLayout, keyCode) || keyIsHome(eventLayout, keyCode) || keyIsEnd(eventLayout, keyCode) || keyIsPageUp(eventLayout, keyCode) || keyIsPageDown(eventLayout, keyCode)
                            if shiftHeld && movementKey:
                                state.editor = clearMultiCursors(state.editor)
                                state.editor = startSelection(state.editor)
                                state.editor = handleEditorKey(state.editor, eventLayout, keyCode, state.layout)
                                cursorDirty = true
                                if state.completion.active:
                                    state = updateCompletion(state)
                                state.lastEvent = "select-move"
                                handled = true
                            elif ! shiftHeld && movementKey && state.editor.selectionActive:
                                state.editor = clearSelection(state.editor)
                        if ! handled && state.focus == fkEditor && keyIsEscape(eventLayout, keyCode) && hasMultiCursors(state.editor):
                            state.editor = clearMultiCursors(state.editor)
                            state.blockSelectActive = false
                            state.lastEvent = "multi-clear"
                            handled = true
                        if ! handled && state.focus == fkEditor && keyIsF12(eventLayout, keyCode):
                            state = gotoDefinition(state)
                            cursorDirty = true
                            state.lastEvent = "goto-def"
                            handled = true
                        if ! handled && state.focus == fkEditor && keyIsComplete(eventLayout, keyCode) && completionMod:
                            state = startCompletion(state)
                            state.lastEvent = "complete"
                            handled = true
                        if ! handled && hasPrimaryModifier(eventLayout, mods) && keyIsTab(eventLayout, keyCode):
                            let delta: int32 = if hasShift(eventLayout, mods): -1 else: 1
                            state = switchBuffer(state, delta)
                            cursorDirty = true
                            state.lastEvent = "tab-switch"
                            handled = true
                        if ! handled && hasPrimaryModifier(eventLayout, mods):
                            if state.focus == fkEditor && keyIsSelectAll(eventLayout, keyCode) && ! hasShift(eventLayout, mods):
                                state.editor = selectAll(state.editor)
                                state.blockSelectActive = false
                                state.lineSelectActive = false
                                cursorDirty = true
                                state.lastEvent = "select-all"
                                handled = true
                            elif state.focus == fkEditor && keyIsCopy(eventLayout, keyCode):
                                state = guiCopySelection(state)
                                state.lastEvent = "copy"
                                handled = true
                            elif state.focus == fkEditor && keyIsCut(eventLayout, keyCode):
                                state = guiCutSelection(state)
                                cursorDirty = true
                                state.lastEvent = "cut"
                                handled = true
                            elif state.focus == fkEditor && keyIsPaste(eventLayout, keyCode):
                                state = guiPasteClipboard(state)
                                cursorDirty = true
                                state.lastEvent = "paste"
                                handled = true
                            elif keyIsNewFile(eventLayout, keyCode) && ! hasShift(eventLayout, mods):
                                state = openUntitledBuffer(state)
                                cursorDirty = true
                                state.lastEvent = "new"
                                handled = true
                            elif keyIsSave(eventLayout, keyCode):
                                if hasShift(eventLayout, mods) || len(state.editor.filePath) == 0:
                                    state = startOverlay(state, okSave)
                                    state.lastEvent = "save-as"
                                else:
                                    state = saveEditor(state)
                                    state.lastEvent = "save"
                                handled = true
                            elif keyIsOpen(eventLayout, keyCode):
                                if hasShift(eventLayout, mods):
                                    state = startOverlay(state, okSymbol)
                                    state.statusMsg = "symbol: file"
                                    state.lastEvent = "symbol-file"
                                else:
                                    state = startOverlay(state, okOpen)
                                    state.lastEvent = "open"
                                handled = true
                            elif keyIsQuickOpen(eventLayout, keyCode):
                                if hasShift(eventLayout, mods):
                                    state = startOverlay(state, okCommand)
                                    state.statusMsg = "command"
                                    state.lastEvent = "command"
                                else:
                                    state = startOverlay(state, okOpen)
                                    state.statusMsg = "quick open"
                                    state.lastEvent = "quick-open"
                                handled = true
                            elif keyIsWorkspaceSymbol(eventLayout, keyCode):
                                state = startOverlay(state, okWorkspaceSymbol)
                                state.statusMsg = "symbol: workspace"
                                state.lastEvent = "symbol-workspace"
                                handled = true
                            elif keyIsFind(eventLayout, keyCode):
                                let isProjectSearch: bool = hasShift(eventLayout, mods)
                                state.searchProject = isProjectSearch
                                state = startOverlay(state, okSearch)
                                if isProjectSearch:
                                    state.statusMsg = "global search (project)"
                                    state.lastEvent = "global-search"
                                else:
                                    state.lastEvent = "find"
                                handled = true
                            elif keyIsReplace(eventLayout, keyCode):
                                let isProjectReplace: bool = hasShift(eventLayout, mods)
                                state.searchProject = isProjectReplace
                                state = startOverlay(state, okReplace)
                                if isProjectReplace:
                                    state.statusMsg = "replace: project"
                                    state.lastEvent = "replace-project"
                                else:
                                    state.lastEvent = "replace"
                                handled = true
                            elif keyIsToggleComment(eventLayout, keyCode):
                                if state.focus == fkEditor:
                                    state.editor = editorToggleComment(state.editor)
                                    cursorDirty = true
                                    state = guiSetDiagnosticsDirty(state)
                                    state.lastEvent = "toggle-comment"
                                    handled = true
                            elif state.focus == fkEditor && keyIsSelectLine(eventLayout, keyCode) && ! hasShift(eventLayout, mods):
                                state.editor = selectCurrentLine(state.editor)
                                cursorDirty = true
                                state.lastEvent = "line-select-key"
                                handled = true
                            elif state.focus == fkEditor && keyIsDuplicateLine(eventLayout, keyCode) && hasShift(eventLayout, mods):
                                state.editor = duplicateSelectionOrLine(state.editor)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "line-duplicate"
                                handled = true
                            elif state.focus == fkEditor && keyIsDeleteLine(eventLayout, keyCode) && hasShift(eventLayout, mods):
                                state.editor = deleteSelectionLines(state.editor)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "line-delete"
                                handled = true
                            elif keyIsGotoLine(eventLayout, keyCode):
                                if hasShift(eventLayout, mods):
                                    state = guiVcsRefresh(state)
                                    state.lastEvent = "vcs-refresh"
                                else:
                                    state = startOverlay(state, okGoto)
                                    state.lastEvent = "goto-line"
                                handled = true
                            elif keyIsCloseTab(eventLayout, keyCode):
                                state = requestCloseActiveBuffer(state)
                                cursorDirty = true
                                state.lastEvent = "tab-close"
                                handled = true
                            elif keyIsToggleTerminal(eventLayout, keyCode):
                                state.bottomPaneTab = bpTerminal
                                if state.bottomPaneVisible && state.focus == fkTerminal:
                                    state.bottomPaneVisible = false
                                    state.focus = fkEditor
                                else:
                                    state.bottomPaneVisible = true
                                    state.focus = fkTerminal
                                if state.focus != fkEditor:
                                    state = cancelCompletion(state)
                                state.lastEvent = "toggle-terminal"
                                handled = true
                            elif keyIsTogglePanel(eventLayout, keyCode):
                                if state.bottomPaneVisible:
                                    state.bottomPaneVisible = false
                                    if state.focus == fkTerminal:
                                        state.focus = fkEditor
                                else:
                                    state.bottomPaneVisible = true
                                    if state.bottomPaneTab == bpTerminal:
                                        state.focus = fkTerminal
                                    elif state.focus == fkTerminal:
                                        state.focus = fkEditor
                                if state.focus != fkEditor:
                                    state = cancelCompletion(state)
                                state.lastEvent = "toggle-panel"
                                handled = true
                            elif keyIsToggleSecondarySidebar(eventLayout, keyCode) && hasAlt(eventLayout, mods):
                                if state.rightPaneVisible:
                                    state.rightPaneVisible = false
                                    if state.focus == fkCodex:
                                        state.focus = fkEditor
                                else:
                                    state.rightPaneVisible = true
                                    if state.rightPaneWidth <= 0:
                                        state.rightPaneWidth = int32(260.0 * state.layout.scale)
                                state.lastEvent = "toggle-right"
                                handled = true
                            elif keyIsToggleExplorer(eventLayout, keyCode) && ! hasAlt(eventLayout, mods):
                                if state.leftPaneVisible:
                                    state.leftPaneVisible = false
                                    if state.focus == fkExplorer:
                                        state.focus = fkEditor
                                else:
                                    state.leftPaneVisible = true
                                    state.leftPaneTab = lpExplorer
                                    state.focus = fkExplorer
                                    state.explorer = ensureExplorerSelection(state.explorer)
                                    state.explorer = ensureExplorerVisible(state.explorer, state.layout)
                                if state.focus != fkEditor:
                                    state = cancelCompletion(state)
                                state.lastEvent = "toggle-explorer"
                                handled = true
                            elif keyIsToggleSplit(eventLayout, keyCode):
                                state.editor = toggleEditorSplit(state.editor)
                                state.statusMsg = if state.editor.splitActive: "split: on" else: "split: off"
                                cursorDirty = true
                                state.lastEvent = "split-toggle"
                                handled = true
                        if ! handled && state.focus == fkEditor:
                            let undoModsOk: bool = hasPrimaryModifier(eventLayout, mods) || (eventLayout == elMac && hasCtrl(eventLayout, mods))
                            let undoTextMatch: bool = len(keyText) == 1 && (keyText[0] == 'z' || keyText[0] == 'Z')
                            let redoTextMatch: bool = len(keyText) == 1 && (keyText[0] == 'y' || keyText[0] == 'Y')
                            if undoModsOk && (keyIsUndo(eventLayout, keyCode) || undoTextMatch):
                                undoKeyDown = true
                                if hasShift(eventLayout, mods):
                                    state = guiRedo(state)
                                    state.lastEvent = "redo"
                                else:
                                    state = guiUndo(state)
                                    state.lastEvent = "undo"
                                cursorDirty = true
                                handled = true
                            elif undoModsOk && (keyIsRedo(eventLayout, keyCode) || redoTextMatch):
                                redoKeyDown = true
                                state = guiRedo(state)
                                state.lastEvent = "redo"
                                cursorDirty = true
                                handled = true
                    if ! handled && state.focus == fkEditor:
                        let fallbackOk: bool = ! state.textInputSeen && ! batchHasTextInput && ! batchHasIme && ! state.imeActive
                        var forcedShiftHandled = false
                        if shiftOnly && fallbackOk:
                            let base: char = keyCodeBaseCharForMods(eventLayout, mods, keyCode)
                            let mapped: char = shiftSymbolForKey(base)
                            var directText: str = normalizeFullWidthAscii(keyText)
                            var directCharOk = false
                            if len(directText) == 1:
                                let ch: char = directText[0]
                                if ch >= '!' && ch <= '~' && ! isAsciiWordChar(ch):
                                    directCharOk = true
                            if directCharOk && (mapped == '\0' || directText[0] != base):
                                state.editor = editorInsertTextInput(state.editor, directText)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "text-keydown"
                                handled = true
                                forcedShiftHandled = true
                                skipNextText = true
                                skipTextChar = directText[0]
                                pendingShiftBase = '\0'
                                pendingShiftMapped = '\0'
                            elif mapped != '\0':
                                let insertText: str = charToStr(mapped)
                                state.editor = editorInsertTextInput(state.editor, insertText)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "text-keydown"
                                handled = true
                                forcedShiftHandled = true
                                skipNextText = true
                                skipTextChar = mapped
                                pendingShiftBase = '\0'
                                pendingShiftMapped = '\0'
                        if ! forcedShiftHandled && shiftOnly && fallbackOk:
                            var mapped: char = '\0'
                            if len(keyText) == 1:
                                mapped = shiftSymbolForKey(keyText[0])
                            if mapped == '\0':
                                let base: char = keyCodeBaseCharForMods(eventLayout, mods, keyCode)
                                mapped = shiftSymbolForKey(base)
                            if mapped != '\0':
                                let fallbackText: str = charToStr(mapped)
                                state.editor = editorInsertTextInput(state.editor, fallbackText)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "text-keydown"
                                handled = true
                                skipNextText = true
                                skipTextChar = mapped
                        elif fallbackOk && ! forcedShiftHandled:
                            let textModsOk: bool = ! hasPrimaryModifier(eventLayout, mods) && ! hasCtrl(eventLayout, mods) && ! hasAlt(eventLayout, mods)
                            if textModsOk && len(keyText) == 1:
                                let fallbackText: str = applyShiftTextInput(keyText, eventLayout, mods)
                                if len(fallbackText) == 1:
                                    let ch: char = fallbackText[0]
                                    if ch != '\r' && ch != '\n' && ch != '\t' && ch != '\x08' && ch != '\x7f' && ch >= ' ':
                                        state.editor = editorInsertTextInput(state.editor, fallbackText)
                                        cursorDirty = true
                                        state = guiSetDiagnosticsDirty(state)
                                        state.lastEvent = "text-keydown"
                                        handled = true
                                        skipNextText = true
                                        skipTextChar = ch
                        if ! handled && state.focus == fkEditor && keyIsBackspace(eventLayout, keyCode):
                            if state.imeActive && len(state.imeText) > 0:
                                handled = true
                            elif eventLayout == elMac && hasPrimaryModifier(eventLayout, mods):
                                state.editor = editorBackspaceLineStart(state.editor)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "backspace-line"
                                handled = true
                            elif eventLayout == elMac && hasAlt(eventLayout, mods):
                                state.editor = editorBackspaceWord(state.editor)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "backspace-word"
                                handled = true
                            elif eventLayout != elMac && hasCtrl(eventLayout, mods):
                                state.editor = editorBackspaceWord(state.editor)
                                cursorDirty = true
                                state = guiSetDiagnosticsDirty(state)
                                state.lastEvent = "backspace-word"
                                handled = true
                        if ! handled && state.focus == fkExplorer:
                            if keyIsArrowUp(eventLayout, keyCode):
                                state.explorer = moveExplorerSelection(state.explorer, -1, state.layout)
                                state.lastEvent = "explorer-up"
                                handled = true
                            elif keyIsArrowDown(eventLayout, keyCode):
                                state.explorer = moveExplorerSelection(state.explorer, 1, state.layout)
                                state.lastEvent = "explorer-down"
                                handled = true
                            elif keyIsArrowLeft(eventLayout, keyCode):
                                let itemIdx: int32 = state.explorer.selected
                                if itemIdx >= 0 && itemIdx < seqLenString(state.explorer.items):
                                    let item = seqGetString(state.explorer.items, itemIdx)
                                    if explorerItemIsDir(item):
                                        let key = explorerItemKey(item)
                                        if ! containsString(state.explorer.collapsed, key):
                                            state.explorer = explorerToggleDir(state.explorer, itemIdx, state.layout)
                                            state = guiWorkspaceStateSave(state)
                                        else:
                                            state.explorer = explorerSelectParent(state.explorer, itemIdx)
                                    else:
                                        state.explorer = explorerSelectParent(state.explorer, itemIdx)
                                    state.explorer = ensureExplorerVisible(state.explorer, state.layout)
                                state.lastEvent = "explorer-left"
                                handled = true
                            elif keyIsArrowRight(eventLayout, keyCode):
                                let itemIdx: int32 = state.explorer.selected
                                if itemIdx >= 0 && itemIdx < seqLenString(state.explorer.items):
                                    let item = seqGetString(state.explorer.items, itemIdx)
                                    if explorerItemIsDir(item):
                                        let key = explorerItemKey(item)
                                        if containsString(state.explorer.collapsed, key):
                                            state.explorer = explorerToggleDir(state.explorer, itemIdx, state.layout)
                                            state.explorer = ensureExplorerVisible(state.explorer, state.layout)
                                            state = guiWorkspaceStateSave(state)
                                state.lastEvent = "explorer-right"
                                handled = true
                            elif keyIsPageUp(eventLayout, keyCode):
                                state.explorer = pageExplorerSelection(state.explorer, -1, state.layout)
                                state.lastEvent = "explorer-page-up"
                                handled = true
                            elif keyIsPageDown(eventLayout, keyCode):
                                state.explorer = pageExplorerSelection(state.explorer, 1, state.layout)
                                state.lastEvent = "explorer-page-down"
                                handled = true
                            elif keyIsHome(eventLayout, keyCode):
                                state.explorer.selected = 0
                                state.explorer = ensureExplorerVisible(state.explorer, state.layout)
                                state.lastEvent = "explorer-home"
                                handled = true
                            elif keyIsEnd(eventLayout, keyCode):
                                let count: int32 = seqLenString(state.explorer.items)
                                if count > 0:
                                    state.explorer.selected = count - 1
                                else:
                                    state.explorer.selected = -1
                                state.explorer = ensureExplorerVisible(state.explorer, state.layout)
                                state.lastEvent = "explorer-end"
                                handled = true
                            elif keyIsEnter(eventLayout, keyCode):
                                let itemIdx: int32 = state.explorer.selected
                                if itemIdx >= 0 && itemIdx < seqLenString(state.explorer.items):
                                    let path = explorerItemPath(state.workspaceRoots, state.projectRoot, seqGetString(state.explorer.items, itemIdx))
                                    if len(path) > 0:
                                        state = openEditorPath(state, path)
                                state.lastEvent = "explorer-open"
                                handled = true
                            elif keyIsEscape(eventLayout, keyCode):
                                state.focus = fkEditor
                                state.lastEvent = "explorer-escape"
                                handled = true
                        if ! handled:
                            if state.focus == fkTerminal:
                                if state.terminal.mode == tmPty:
                                    if keyIsEnter(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\n")
                                        state.lastEvent = "terminal-pty-enter"
                                        handled = true
                                    elif keyIsBackspace(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x7f")
                                        state.lastEvent = "terminal-pty-backspace"
                                        handled = true
                                    elif keyIsTab(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\t")
                                        state.lastEvent = "terminal-pty-tab"
                                        handled = true
                                    elif keyIsEscape(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b")
                                        state.lastEvent = "terminal-pty-escape"
                                        handled = true
                                    elif keyIsArrowUp(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b[A")
                                        state.lastEvent = "terminal-pty-up"
                                        handled = true
                                    elif keyIsArrowDown(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b[B")
                                        state.lastEvent = "terminal-pty-down"
                                        handled = true
                                    elif keyIsArrowRight(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b[C")
                                        state.lastEvent = "terminal-pty-right"
                                        handled = true
                                    elif keyIsArrowLeft(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b[D")
                                        state.lastEvent = "terminal-pty-left"
                                        handled = true
                                    elif keyIsHome(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b[H")
                                        state.lastEvent = "terminal-pty-home"
                                        handled = true
                                    elif keyIsEnd(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b[F")
                                        state.lastEvent = "terminal-pty-end"
                                        handled = true
                                    elif keyIsPageUp(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b[5~")
                                        state.lastEvent = "terminal-pty-page-up"
                                        handled = true
                                    elif keyIsPageDown(eventLayout, keyCode):
                                        state = guiPtySendRawInput(state, "\x1b[6~")
                                        state.lastEvent = "terminal-pty-page-down"
                                        handled = true
                                else:
                                    if keyIsEnter(eventLayout, keyCode):
                                        state = commitTerminalInputWithTasks(state)
                                        state.lastEvent = "terminal-enter"
                                        handled = true
                                    else:
                                        state.terminal = handleTerminalKey(state.terminal, eventLayout, keyCode)

                            elif state.focus == fkEditor:
                                let editKey: bool = keyIsEditKey(eventLayout, keyCode)
                                state.editor = handleEditorKey(state.editor, eventLayout, keyCode, state.layout)
                                cursorDirty = true
                                if editKey:
                                    state = guiSetDiagnosticsDirty(state)
                                if state.completion.active:
                                    state = updateCompletion(state)
                        if ! handled:
                            state.lastEvent = "key=" + intToStr(int32(keyCode))
                elif kind == 7:
                    state = guiClearHover(state)
                    let rawX = loadF64(ev, xOffset)
                    let rawY = loadF64(ev, yOffset)
                    var px: float64 = 0.0
                    var py: float64 = 0.0
                    scalePointer(rawX, rawY, inputScale, width, height, px, py)
                    let mods: uint32 = loadU32(ev, modifiersOffset)
                    let button: int32 = loadI32(ev, buttonOffset)
                    if debugPointer:
                        textutils.print("[input] pointer-down raw=" + intToStr(int32(rawX)) + "," + intToStr(int32(rawY)) + " px=" + intToStr(int32(px)) + "," + intToStr(int32(py)) + " scale=" + intToStr(int32(inputScale * 100.0)) + " btn=" + intToStr(button) + " mods=" + intToStr(int32(mods)) + "\n")
                    state.lastEvent = "pointer-down"
                    state.draggingEditor = false
                    state.dragButton = -1
                    state.dragMulti = false
                    state.blockSelectActive = false
                    state.lineSelectActive = false
                    let resizeHit: ResizeDragKind = splitHitTest(state.layout, px, py)
                    if resizeHit != rdNone:
                        state.resizeDrag = resizeHit
                        state.lastEvent = "resize-start"
                        continue
                    let inLeftPanel: bool = px >= 0.0 && px <= float64(state.layout.leftW) && py >= float64(state.layout.contentY) && py <= float64(state.layout.contentY + state.layout.contentH)
                    let editorRight: float64 = float64(state.layout.editorX + state.layout.editorW)
                    let editorTop: float64 = float64(state.layout.contentY)
                    let editorBottom: float64 = float64(state.layout.bottomY)
                    let minimapW: int32 = minimapWidth(state.layout)
                    let minimapX: float64 = float64(state.layout.editorX + state.layout.editorW - minimapW)
                    let inMinimap: bool = minimapW > 0 && px >= minimapX && px <= editorRight && py >= editorTop && py <= editorBottom
                    let inEditor: bool = px >= float64(state.layout.editorX) && px <= editorRight && py >= editorTop && py <= editorBottom && ! inMinimap
                    let inBottomPane: bool = px >= float64(state.layout.editorX) && px <= editorRight && py >= float64(state.layout.bottomY) && py <= float64(state.layout.bottomY + state.layout.bottomH)
                    let showRightPane: bool = state.layout.rightW > 0
                    let inRightPanel: bool = showRightPane && px >= float64(state.layout.leftW + state.layout.editorW) && px <= float64(state.layout.leftW + state.layout.editorW + state.layout.rightW) && py >= float64(state.layout.contentY) && py <= float64(state.layout.contentY + state.layout.contentH)
                    let tabStripW: int32 = tabStripWidth(state.layout)
                    let tabControl: int32 = tabStripControlHit(state, tabStripW, px, py)
                    if tabControl != TabControlNone:
                        let maxScroll: float64 = tabStripMaxScroll(state, tabStripW)
                        if tabControl == TabControlNew:
                            state = openUntitledBuffer(state)
                            cursorDirty = true
                            state.lastEvent = "tab-new"
                        elif tabControl == TabControlLeft:
                            if state.tabScrollX > 0.0:
                                state = tabStripScroll(state, tabStripW, -tabMinWidth(state.layout))
                                state.lastEvent = "tab-scroll-left"
                            else:
                                state.lastEvent = "tab-scroll-left-disabled"
                        elif tabControl == TabControlRight:
                            if state.tabScrollX < maxScroll:
                                state = tabStripScroll(state, tabStripW, tabMinWidth(state.layout))
                                state.lastEvent = "tab-scroll-right"
                            else:
                                state.lastEvent = "tab-scroll-right-disabled"
                        continue
                    let closeIdx: int32 = tabCloseIndexAtPoint(state, px, py)
                    var tabHandled = false
                    if closeIdx >= 0:
                        state = closeBufferAt(state, closeIdx)
                        cursorDirty = true
                        state.lastEvent = "tab-close"
                        tabHandled = true
                    else:
                        let tabIdx: int32 = tabIndexAtPoint(state, px, py)
                        if tabIdx >= 0:
                            state = loadBufferAt(state, tabIdx)
                            cursorDirty = true
                            state.lastEvent = "tab"
                            tabHandled = true
                    if ! tabHandled && inLeftPanel:
                        state.focus = fkExplorer
                        state = cancelCompletion(state)
                        let barW: int32 = activityBarWidth(state.layout)
                        if px <= float64(barW):
                            let bottomIdx: int32 = activityBottomIndexAtPoint(state, px, py)
                            if bottomIdx >= 0:
                                state = guiHandleActivityBottomAction(state, bottomIdx)
                                state.lastEvent = "activity-bottom"
                                continue
                            let tabIdx: int32 = leftPaneTabIndexAtPoint(state, px, py)
                            if tabIdx >= 0:
                                state.leftPaneTab = leftPaneTabFromIndex(tabIdx)
                                if state.leftPaneTab == lpCodex:
                                    state = guiCodexShow(state)
                                    state.lastEvent = "codex-open"
                                else:
                                    state.lastEvent = "left-tab"
                        else:
                            if state.leftPaneTab == lpExplorer:
                                let action = explorerHeaderActionHit(state.layout, px, py)
                                if action != ExplorerActionNone:
                                    state = guiHandleExplorerHeaderAction(state, action)
                                    state.lastEvent = "explorer-action-" + explorerHeaderActionName(action)
                                    continue
                            elif state.leftPaneTab == lpSearch:
                                let action = searchHeaderActionHit(state.layout, px, py)
                                if action != SearchActionNone:
                                    state = guiHandleSearchHeaderAction(state, action)
                                    state.lastEvent = "search-action-" + searchHeaderActionName(action)
                                    continue
                            elif state.leftPaneTab == lpVcs:
                                let action = vcsHeaderActionHit(state.layout, px, py)
                                if action != VcsActionNone:
                                    state = guiHandleVcsHeaderAction(state, action)
                                    state.lastEvent = "vcs-action-" + vcsHeaderActionName(action)
                                    continue
                            let debugOffset: int32 = explorerDebugLineOffset(state.layout)
                            let listY: float64 = explorerListStartY(state.layout) + float64(debugOffset * state.layout.lineHeight)
                            if py >= listY:
                                let relY: float64 = py - listY
                                let lineIdx: int32 = int32(relY / state.layout.lineHeight)
                                if state.leftPaneTab == lpExplorer:
                                    let itemIdx: int32 = state.explorer.scroll + lineIdx
                                    if itemIdx >= 0 && itemIdx < seqLenString(state.explorer.items):
                                        state.explorer.selected = itemIdx
                                        let item = seqGetString(state.explorer.items, itemIdx)
                                        if explorerItemIsDir(item):
                                            state.explorer = explorerToggleDir(state.explorer, itemIdx, state.layout)
                                            state = guiWorkspaceStateSave(state)
                                        else:
                                            let path = explorerItemPath(state.workspaceRoots, state.projectRoot, item)
                                            if len(path) > 0:
                                                state = openEditorPath(state, path)
                                    state.lastEvent = "explorer"
                                elif state.leftPaneTab == lpSearch:
                                    var resultLine: int32 = lineIdx
                                    if len(state.search.query) > 0:
                                        resultLine = lineIdx - 1
                                    let totalResults: int32 = seqLenString(state.searchResults)
                                    var searchHeaderOffset: int32 = 0
                                    if len(state.search.query) > 0:
                                        searchHeaderOffset = 1
                                    let visibleLines: int32 = maxInt(1, explorerVisibleLines(state.layout) - searchHeaderOffset)
                                    let maxScroll: int32 = maxInt(0, totalResults - visibleLines)
                                    let startIdx: int32 = clampInt(state.searchScroll, 0, maxScroll)
                                    let entryIdx: int32 = startIdx + resultLine
                                    if resultLine >= 0 && entryIdx >= 0 && entryIdx < totalResults:
                                        let entry = seqGetString(state.searchResults, entryIdx)
                                        let parsed: PathLineCol = parsePathLineCol(searchResultPath(entry))
                                        if len(parsed.path) > 0:
                                            state = openEditorPath(state, parsed.path)
                                            if parsed.hasLine:
                                                var targetCol: int32 = 0
                                                if parsed.hasCol:
                                                    targetCol = parsed.col
                                                state = gotoLine(state, parsed.line, targetCol)
                                            cursorDirty = true
                                        state.lastEvent = "search-open"
                                    else:
                                        state.lastEvent = "search"
                                elif state.leftPaneTab == lpVcs:
                                    var entryIdx: int32 = lineIdx
                                    var lineOffset: int32 = 0
                                    let summary: str = state.vcsSummary
                                    let summaryLower = textutils.toLowerAscii(summary)
                                    let summaryIsError: bool = summaryLower == "not a git repo" || summaryLower == "git error"
                                    let vcsCounts: VcsCounts = guiVcsCounts(state.vcsLines)
                                    let countsLabel = guiVcsCountsLabel(vcsCounts)
                                    let showCounts: bool = (len(summary) > 0 || seqLenString(state.vcsLines) > 0) && ! summaryIsError && len(countsLabel) > 0
                                    if len(summary) > 0:
                                        if lineIdx == 0:
                                            state.lastEvent = "vcs-summary"
                                            entryIdx = -1
                                        lineOffset = lineOffset + 1
                                    if showCounts:
                                        if lineIdx == lineOffset:
                                            state.lastEvent = "vcs-counts"
                                            entryIdx = -1
                                        lineOffset = lineOffset + 1
                                    if entryIdx >= 0:
                                        entryIdx = lineIdx - lineOffset
                                    if entryIdx >= 0 && entryIdx < seqLenString(state.vcsLines):
                                        let entry = seqGetString(state.vcsLines, entryIdx)
                                        let path = guiVcsPathFromLine(entry)
                                        if len(path) > 0:
                                            var openPath = path
                                            let root = if len(state.vcsRoot) > 0: state.vcsRoot else: guiWorkspaceActiveRoot(state)
                                            let rootIdx: int32 = workspaceRootIndexForPath(state.workspaceRoots, root)
                                            if rootIdx >= 0:
                                                let label = workspaceRootLabel(seqGetString(state.workspaceRoots, rootIdx))
                                                if len(label) > 0:
                                                    openPath = joinPath(label, path)
                                            state = openEditorPath(state, openPath)
                                            cursorDirty = true
                                            state.lastEvent = "vcs-open"
                                    else:
                                        state.lastEvent = "vcs"
                                elif state.leftPaneTab == lpRun:
                                    let actionCount: int32 = runActionCount()
                                    let actionIdx: int32 = lineIdx
                                    if actionIdx >= 0 && actionIdx < actionCount:
                                        let actionKind = runActionKind(actionIdx)
                                        if actionKind == "diag":
                                            state = guiRunLanguageDiagnostics(state)
                                        else:
                                            state = guiTaskRun(state, guiTaskCommand(actionKind))
                                        state.lastEvent = "run-" + actionKind
                                    else:
                                        state.lastEvent = "run"
                                    state.lastEvent = "run"
                                elif state.leftPaneTab == lpCodex:
                                    state = guiCodexShow(state)
                                    let panelX: int32 = barW
                                    let panelW: int32 = maxInt(0, state.layout.leftW - barW)
                                    if panelW <= 0:
                                        state.lastEvent = "codex"
                                    else:
                                        let codexCount: int32 = seqLenString(state.codex.lines)
                                        let contentX: float64 = float64(panelX + panelPaddingX(state.layout))
                                        var contentMaxW: float64 = float64(panelW - 2.0 * panelPaddingX(state.layout))
                                        if contentMaxW < 0.0:
                                            contentMaxW = 0.0
                                        let headerTop: int32 = state.layout.contentY
                                        let headerH: int32 = panelHeaderHeight(state.layout)
                                        let headerActions: CodexActionRect[] = codexToolbarActionRects(state, state.layout, contentX, contentX + contentMaxW, headerTop, headerH)
                                        for headerIdx in 0..<headerActions.len:
                                            let rect = headerActions[headerIdx]
                                            if px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h:
                                                state.focus = fkCodex
                                                if rect.action.enabled:
                                                    if rect.action.cmd == "login":
                                                        state = guiCodexStartLoginFlow(state)
                                                        state.lastEvent = "codex-login"
                                                    elif rect.action.cmd == "connect":
                                                        state = guiCodexConnect(state)
                                                        state.lastEvent = "codex-connect"
                                                    elif rect.action.cmd == "stop":
                                                        state = guiCodexStop(state, "")
                                                        state.lastEvent = "codex-stop"
                                                    elif rect.action.cmd == "new":
                                                        state = guiCodexNewThread(state, "")
                                                        state.lastEvent = "codex-new"
                                                    elif rect.action.cmd == "threads":
                                                        state = guiCodexListThreads(state)
                                                        state.lastEvent = "codex-threads"
                                                    elif rect.action.cmd == "resume":
                                                        if len(state.codex.threadId) > 0:
                                                            state = guiCodexResumeThread(state, state.codex.threadId)
                                                        state.lastEvent = "codex-resume"
                                                    elif rect.action.cmd == "preview":
                                                        state = guiCodexPreviewLastDiff(state)
                                                        state.lastEvent = "codex-preview"
                                                    elif rect.action.cmd == "apply":
                                                        state = guiCodexApplyLastDiff(state)
                                                        state.lastEvent = "codex-apply"
                                                    elif rect.action.cmd == "approve":
                                                        state = guiCodexApprove(state)
                                                        state.lastEvent = "codex-approve"
                                                    elif rect.action.cmd == "decline":
                                                        state = guiCodexDecline(state)
                                                        state.lastEvent = "codex-decline"
                                                    elif rect.action.cmd == "interrupt":
                                                        state = guiCodexInterrupt(state)
                                                        state.lastEvent = "codex-interrupt"
                                                    elif rect.action.cmd == "clear":
                                                        state = guiCodexClear(state)
                                                        state.lastEvent = "codex-clear"
                                                    elif rect.action.cmd == "settings":
                                                        state = guiCodexOpenConfig(state)
                                                        state.lastEvent = "codex-settings"
                                                    else:
                                                        state.lastEvent = "codex-action"
                                                else:
                                                    state.lastEvent = "codex-action-disabled"
                                                continue
                                        let contentListY: float64 = panelListStartY(state.layout, state.layout.contentY)
                                        let metaY: float64 = codexComputeMetaY(state, state.layout, contentX, contentMaxW, contentListY)
                                        var calloutTitle: str = ""
                                        var calloutBody: str = ""
                                        var calloutX: float64 = 0.0
                                        var calloutY: float64 = 0.0
                                        var calloutW: float64 = 0.0
                                        var calloutH: float64 = 0.0
                                        var calloutRects: CodexActionRect[] = default[CodexActionRect[]]
                                        var extraRects: CodexActionRect[] = default[CodexActionRect[]]
                                        var actionBottom: float64 = metaY
                                        codexComputeActionLayout(state, state.layout, contentX, contentMaxW, metaY, calloutTitle, calloutBody, calloutX, calloutY, calloutW, calloutH, calloutRects, extraRects, actionBottom)
                                        for actionIdx in 0..<calloutRects.len:
                                            let rect = calloutRects[actionIdx]
                                            if px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h:
                                                state.focus = fkCodex
                                                if rect.action.enabled:
                                                    if rect.action.cmd == "login":
                                                        state = guiCodexStartLoginFlow(state)
                                                        state.lastEvent = "codex-login"
                                                    elif rect.action.cmd == "connect":
                                                        state = guiCodexConnect(state)
                                                        state.lastEvent = "codex-connect"
                                                    elif rect.action.cmd == "apikey":
                                                        state = guiCodexOpenConfig(state)
                                                        state.lastEvent = "codex-settings"
                                                    else:
                                                        state.lastEvent = "codex-action"
                                                else:
                                                    state.lastEvent = "codex-action-disabled"
                                                continue
                                        for actionIdx in 0..<extraRects.len:
                                            let rect = extraRects[actionIdx]
                                            if px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h:
                                                state.focus = fkCodex
                                                if rect.action.enabled:
                                                    if rect.action.cmd == "preview":
                                                        state = guiCodexPreviewLastDiff(state)
                                                        state.lastEvent = "codex-preview"
                                                    elif rect.action.cmd == "apply":
                                                        state = guiCodexApplyLastDiff(state)
                                                        state.lastEvent = "codex-apply"
                                                    elif rect.action.cmd == "approve":
                                                        state = guiCodexApprove(state)
                                                        state.lastEvent = "codex-approve"
                                                    elif rect.action.cmd == "decline":
                                                        state = guiCodexDecline(state)
                                                        state.lastEvent = "codex-decline"
                                                    else:
                                                        state.lastEvent = "codex-action"
                                                else:
                                                    state.lastEvent = "codex-action-disabled"
                                                continue
                                        let paneBottom: float64 = float64(state.layout.contentY + state.layout.contentH)
                                        let inputH: float64 = codexInputHeight(state.layout)
                                        var inputY: float64 = paneBottom - inputH - 8.0 * state.layout.scale
                                        if inputY < actionBottom + 8.0 * state.layout.scale:
                                            inputY = actionBottom + 8.0 * state.layout.scale
                                        let inputX: float64 = contentX
                                        let inputW: float64 = contentMaxW
                                        let sendGap: float64 = 6.0 * state.layout.scale
                                        var sendW: float64 = inputH
                                        if sendW + sendGap > inputW:
                                            sendW = 0.0
                                        let sendX: float64 = inputX + inputW - sendW
                                        let sendEnabled: bool = guiCodexIsAuthed(state) && len(trimLine(state.codex.input)) > 0
                                        if sendW > 0.0 && px >= sendX && px <= sendX + sendW && py >= inputY && py <= inputY + inputH:
                                            state.focus = fkCodex
                                            if sendEnabled:
                                                let prompt = state.codex.input
                                                var feedbackHandled = false
                                                var feedbackClear = false
                                                state = guiCodexFeedbackHandleInput(state, prompt, feedbackHandled, feedbackClear)
                                                if feedbackHandled:
                                                    if feedbackClear:
                                                        state.codex.input = ""
                                                    state.lastEvent = "codex-feedback"
                                                else:
                                                    var cmdHandled = false
                                                    var cmdClear = false
                                                    state = guiCodexHandleSlashCommand(state, prompt, cmdHandled, cmdClear)
                                                    if cmdHandled:
                                                        if cmdClear:
                                                            state.codex.input = ""
                                                        state.lastEvent = "codex-command"
                                                    else:
                                                        state = guiCodexAsk(state, prompt)
                                                        state.codex.input = ""
                                                        state.lastEvent = "codex-send"
                                            else:
                                                state.lastEvent = "codex-send-disabled"
                                            continue
                                        var inputTextW: float64 = inputW
                                        if sendW > 0.0:
                                            inputTextW = inputW - sendW - sendGap
                                        if px >= inputX && px <= inputX + inputTextW && py >= inputY && py <= inputY + inputH:
                                            state.focus = fkCodex
                                            state.lastEvent = "codex-input"
                                            continue
                                        let messagesTop: float64 = actionBottom
                                        var messagesBottom: float64 = inputY - 8.0 * state.layout.scale
                                        let queueCount: int32 = seqLenString(state.codex.queue)
                                        if queueCount > 0:
                                            let queueLineH: float64 = state.layout.smallFont + 4.0 * state.layout.scale
                                            messagesBottom = messagesBottom - queueLineH - 4.0 * state.layout.scale
                                        let msgH: float64 = codexMessageHeight(state.layout)
                                        let msgGap: float64 = 6.0 * state.layout.scale
                                        let msgStride: float64 = msgH + msgGap
                                        let availH: float64 = messagesBottom - messagesTop
                                        if availH >= msgH && codexCount > 0 && px >= contentX && px <= contentX + contentMaxW && py >= messagesTop && py <= messagesBottom:
                                            let visible: int32 = maxInt(1, int32(availH / msgStride))
                                            if visible > 0:
                                                let maxStart: int32 = maxInt(0, codexCount - visible)
                                                let scroll: int32 = clampInt(state.codex.scroll, 0, maxStart)
                                                let startIdx: int32 = maxStart - scroll
                                                let relIdx: int32 = int32((py - messagesTop) / msgStride)
                                                if relIdx >= 0 && relIdx < visible:
                                                    let entryIdx: int32 = startIdx + relIdx
                                                    if entryIdx >= 0 && entryIdx < codexCount:
                                                        let lineText = seqGetString(state.codex.lines, entryIdx)
                                                        state.codex.selected = entryIdx
                                                        state.focus = fkCodex
                                                        if state.codex.status == "threads" || startsWithPrefix(lineText, "thr_"):
                                                            let threadId = guiCodexThreadIdFromLine(lineText)
                                                            if len(threadId) > 0 && startsWithPrefix(threadId, "thr_"):
                                                                state = guiCodexSelectThread(state, threadId)
                                                                state.lastEvent = "codex-thread"
                                                            else:
                                                                state.statusMsg = "codex: line " + intToStr(entryIdx + 1)
                                                                state.lastEvent = "codex-select"
                                                        else:
                                                            let url = guiCodexUrlFromLine(lineText)
                                                            if len(url) > 0:
                                                                state = guiOpenUrl(state, url)
                                                                state.lastEvent = "codex-url"
                                                            else:
                                                                let target = guiCodexOpenTargetFromLine(lineText)
                                                                if len(target) > 0:
                                                                    state = guiCodexOpenTarget(state, target)
                                                                    cursorDirty = true
                                                                    state.lastEvent = "codex-open"
                                                                else:
                                                                    state.statusMsg = "codex: line " + intToStr(entryIdx + 1)
                                                                    state.lastEvent = "codex-select"
                                                    else:
                                                        state.lastEvent = "codex"
                                                else:
                                                    state.lastEvent = "codex"
                                        else:
                                            state.lastEvent = "codex"
                                else:
                                    state.lastEvent = "left-panel"
                    elif inMinimap:
                        let totalVisible: int32 = visibleLineCount(state.editor)
                        let editorH: int32 = state.layout.editorH
                        if totalVisible > 0 && editorH > 0:
                            var relY: float64 = py - float64(state.layout.contentY)
                            if relY < 0.0:
                                relY = 0.0
                            elif relY > float64(editorH):
                                relY = float64(editorH)
                            let ratio: float64 = relY / float64(editorH)
                            let offset: int32 = clampInt(int32(ratio * float64(totalVisible)), 0, totalVisible - 1)
                            let targetLine: int32 = visibleLineAtOffset(state.editor, 0, offset)
                            state.focus = fkEditor
                            state.editor = clearMultiCursors(state.editor)
                            state.editor = clearSelection(state.editor)
                            state.editor.cursorLine = targetLine
                            let lineText = seqGetString(state.editor.lines, targetLine)
                            state.editor.cursorCol = clampInt(state.editor.cursorCol, 0, len(lineText))
                            state.editor.desiredCol = desiredColForLineText(lineText, state.editor.cursorCol)
                            state.editor = ensureCursorVisible(state.editor, state.layout)
                            cursorDirty = true
                            state.lastEvent = "minimap"
                    elif inRightPanel:
                        let tabIdx: int32 = rightPaneTabIndexAtPoint(state, px, py)
                        if tabIdx >= 0:
                            state.rightPaneTab = rightPaneTabFromIndex(tabIdx)
                            state.hoverRightPaneRow = -1
                            if state.rightPaneTab == rpCodex:
                                state.focus = fkCodex
                            elif state.focus == fkCodex:
                                state.focus = fkEditor
                            state.lastEvent = "right-tab"
                        else:
                            let listY: float64 = rightPaneContentListStartY(state.layout)
                            let contentLines: int32 = rightPaneContentVisibleLines(state.layout)
                            if py >= listY:
                                let relY: float64 = py - listY
                                let lineIdx: int32 = int32(relY / state.layout.lineHeight)
                                if lineIdx >= 0 && (lineIdx < contentLines || state.rightPaneTab == rpCodex):
                                    if state.rightPaneTab == rpOutline:
                                        let outlineItems: str[] = state.editor.outlineEntries
                                        if lineIdx < seqLenString(outlineItems):
                                            let entry = seqGetString(outlineItems, lineIdx)
                                            state = gotoLine(state, symbolLine(entry), symbolCol(entry))
                                            cursorDirty = true
                                            state.lastEvent = "outline"
                                    elif state.rightPaneTab == rpDiagnostics:
                                        if lineIdx < state.diagnostics.len:
                                            let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(state.diagnostics, lineIdx)
                                            state = gotoLine(state, entry.line, entry.col)
                                            cursorDirty = true
                                            state.lastEvent = "diagnostic"
                                    elif state.rightPaneTab == rpDebugger:
                                        let debugLines: str[] = guiDebuggerLines(state.debugger)
                                        if lineIdx < seqLenString(debugLines):
                                            let entry = seqGetString(debugLines, lineIdx)
                                            let parsed: PathLineCol = guiDebugPathFromLine(entry)
                                            if len(parsed.path) > 0:
                                                let resolved = resolveWorkspacePath(state, parsed.path)
                                                if fileExists(resolved):
                                                    state = openEditorPath(state, resolved)
                                                    if parsed.hasLine:
                                                        var targetCol: int32 = 0
                                                        if parsed.hasCol:
                                                            targetCol = parsed.col
                                                        state = gotoLine(state, parsed.line, targetCol)
                                                        cursorDirty = true
                                                    state.lastEvent = "debug-open"
                                    elif state.rightPaneTab == rpVcs:
                                        var entryIdx: int32 = lineIdx
                                        var lineOffset: int32 = 0
                                        let vcsCounts: VcsCounts = guiVcsCounts(state.vcsLines)
                                        let countsLabel = guiVcsCountsLabel(vcsCounts)
                                        if len(state.vcsSummary) > 0:
                                            if lineIdx == 0:
                                                state.lastEvent = "vcs-summary"
                                                entryIdx = -1
                                            lineOffset = lineOffset + 1
                                        if (len(state.vcsSummary) > 0 || seqLenString(state.vcsLines) > 0) && len(countsLabel) > 0:
                                            if lineIdx == lineOffset:
                                                state.lastEvent = "vcs-counts"
                                                entryIdx = -1
                                            lineOffset = lineOffset + 1
                                        if entryIdx >= 0:
                                            entryIdx = lineIdx - lineOffset
                                        if entryIdx >= 0 && entryIdx < seqLenString(state.vcsLines):
                                            let entry = seqGetString(state.vcsLines, entryIdx)
                                            let path = guiVcsPathFromLine(entry)
                                            if len(path) > 0:
                                                var openPath = path
                                                let root = if len(state.vcsRoot) > 0: state.vcsRoot else: guiWorkspaceActiveRoot(state)
                                                let rootIdx: int32 = workspaceRootIndexForPath(state.workspaceRoots, root)
                                                if rootIdx >= 0:
                                                    let label = workspaceRootLabel(seqGetString(state.workspaceRoots, rootIdx))
                                                    if len(label) > 0:
                                                        openPath = joinPath(label, path)
                                                state = openEditorPath(state, openPath)
                                                cursorDirty = true
                                                state.lastEvent = "vcs-open"
                                    elif state.rightPaneTab == rpCodex:
                                        let codexCount: int32 = seqLenString(state.codex.lines)
                                        let rightPaneX: int32 = state.layout.leftW + state.layout.editorW
                                        let rightPaneW: int32 = state.layout.rightW
                                        let contentX: float64 = float64(rightPaneX + panelPaddingX(state.layout))
                                        let contentMaxW: float64 = float64(rightPaneW - 2.0 * panelPaddingX(state.layout))
                                        let headerTop: int32 = state.layout.contentY
                                        let headerH: int32 = panelHeaderHeight(state.layout)
                                        let headerActions: CodexActionRect[] = codexToolbarActionRects(state, state.layout, contentX, contentX + contentMaxW, headerTop, headerH)
                                        for headerIdx in 0..<headerActions.len:
                                            let rect = headerActions[headerIdx]
                                            if px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h:
                                                state.focus = fkCodex
                                                if rect.action.enabled:
                                                    if rect.action.cmd == "login":
                                                        state = guiCodexStartLoginFlow(state)
                                                        state.lastEvent = "codex-login"
                                                    elif rect.action.cmd == "connect":
                                                        state = guiCodexConnect(state)
                                                        state.lastEvent = "codex-connect"
                                                    elif rect.action.cmd == "stop":
                                                        state = guiCodexStop(state, "")
                                                        state.lastEvent = "codex-stop"
                                                    elif rect.action.cmd == "new":
                                                        state = guiCodexNewThread(state, "")
                                                        state.lastEvent = "codex-new"
                                                    elif rect.action.cmd == "threads":
                                                        state = guiCodexListThreads(state)
                                                        state.lastEvent = "codex-threads"
                                                    elif rect.action.cmd == "resume":
                                                        if len(state.codex.threadId) > 0:
                                                            state = guiCodexResumeThread(state, state.codex.threadId)
                                                        state.lastEvent = "codex-resume"
                                                    elif rect.action.cmd == "preview":
                                                        state = guiCodexPreviewLastDiff(state)
                                                        state.lastEvent = "codex-preview"
                                                    elif rect.action.cmd == "apply":
                                                        state = guiCodexApplyLastDiff(state)
                                                        state.lastEvent = "codex-apply"
                                                    elif rect.action.cmd == "approve":
                                                        state = guiCodexApprove(state)
                                                        state.lastEvent = "codex-approve"
                                                    elif rect.action.cmd == "decline":
                                                        state = guiCodexDecline(state)
                                                        state.lastEvent = "codex-decline"
                                                    elif rect.action.cmd == "interrupt":
                                                        state = guiCodexInterrupt(state)
                                                        state.lastEvent = "codex-interrupt"
                                                    elif rect.action.cmd == "clear":
                                                        state = guiCodexClear(state)
                                                        state.lastEvent = "codex-clear"
                                                    elif rect.action.cmd == "settings":
                                                        state = guiCodexOpenConfig(state)
                                                        state.lastEvent = "codex-settings"
                                                    else:
                                                        state.lastEvent = "codex-action"
                                                else:
                                                    state.lastEvent = "codex-action-disabled"
                                                continue
                                        let contentListY: float64 = rightPaneContentListStartY(state.layout)
                                        let metaY: float64 = codexComputeMetaY(state, state.layout, contentX, contentMaxW, contentListY)
                                        var calloutTitle: str = ""
                                        var calloutBody: str = ""
                                        var calloutX: float64 = 0.0
                                        var calloutY: float64 = 0.0
                                        var calloutW: float64 = 0.0
                                        var calloutH: float64 = 0.0
                                        var calloutRects: CodexActionRect[] = default[CodexActionRect[]]
                                        var extraRects: CodexActionRect[] = default[CodexActionRect[]]
                                        var actionBottom: float64 = metaY
                                        codexComputeActionLayout(state, state.layout, contentX, contentMaxW, metaY, calloutTitle, calloutBody, calloutX, calloutY, calloutW, calloutH, calloutRects, extraRects, actionBottom)
                                        for actionIdx in 0..<calloutRects.len:
                                            let rect = calloutRects[actionIdx]
                                            if px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h:
                                                state.focus = fkCodex
                                                if rect.action.enabled:
                                                    if rect.action.cmd == "login":
                                                        state = guiCodexStartLoginFlow(state)
                                                        state.lastEvent = "codex-login"
                                                    elif rect.action.cmd == "connect":
                                                        state = guiCodexConnect(state)
                                                        state.lastEvent = "codex-connect"
                                                    elif rect.action.cmd == "apikey":
                                                        state = guiCodexOpenConfig(state)
                                                        state.lastEvent = "codex-settings"
                                                    else:
                                                        state.lastEvent = "codex-action"
                                                else:
                                                    state.lastEvent = "codex-action-disabled"
                                                continue
                                        for actionIdx in 0..<extraRects.len:
                                            let rect = extraRects[actionIdx]
                                            if px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h:
                                                state.focus = fkCodex
                                                if rect.action.enabled:
                                                    if rect.action.cmd == "preview":
                                                        state = guiCodexPreviewLastDiff(state)
                                                        state.lastEvent = "codex-preview"
                                                    elif rect.action.cmd == "apply":
                                                        state = guiCodexApplyLastDiff(state)
                                                        state.lastEvent = "codex-apply"
                                                    elif rect.action.cmd == "approve":
                                                        state = guiCodexApprove(state)
                                                        state.lastEvent = "codex-approve"
                                                    elif rect.action.cmd == "decline":
                                                        state = guiCodexDecline(state)
                                                        state.lastEvent = "codex-decline"
                                                    else:
                                                        state.lastEvent = "codex-action"
                                                else:
                                                    state.lastEvent = "codex-action-disabled"
                                                continue
                                        let paneBottom: float64 = float64(state.layout.contentY + state.layout.contentH)
                                        let inputH: float64 = codexInputHeight(state.layout)
                                        var inputY: float64 = paneBottom - inputH - 8.0 * state.layout.scale
                                        if inputY < actionBottom + 8.0 * state.layout.scale:
                                            inputY = actionBottom + 8.0 * state.layout.scale
                                        let inputX: float64 = contentX
                                        let inputW: float64 = contentMaxW
                                        let sendGap: float64 = 6.0 * state.layout.scale
                                        var sendW: float64 = inputH
                                        if sendW + sendGap > inputW:
                                            sendW = 0.0
                                        let sendX: float64 = inputX + inputW - sendW
                                        let sendEnabled: bool = guiCodexIsAuthed(state) && len(trimLine(state.codex.input)) > 0
                                        if sendW > 0.0 && px >= sendX && px <= sendX + sendW && py >= inputY && py <= inputY + inputH:
                                            state.focus = fkCodex
                                            if sendEnabled:
                                                let prompt = state.codex.input
                                                var feedbackHandled = false
                                                var feedbackClear = false
                                                state = guiCodexFeedbackHandleInput(state, prompt, feedbackHandled, feedbackClear)
                                                if feedbackHandled:
                                                    if feedbackClear:
                                                        state.codex.input = ""
                                                    state.lastEvent = "codex-feedback"
                                                else:
                                                    var cmdHandled = false
                                                    var cmdClear = false
                                                    state = guiCodexHandleSlashCommand(state, prompt, cmdHandled, cmdClear)
                                                    if cmdHandled:
                                                        if cmdClear:
                                                            state.codex.input = ""
                                                        state.lastEvent = "codex-command"
                                                    else:
                                                        state = guiCodexAsk(state, prompt)
                                                        state.codex.input = ""
                                                        state.lastEvent = "codex-send"
                                            else:
                                                state.lastEvent = "codex-send-disabled"
                                            continue
                                        var inputTextW: float64 = inputW
                                        if sendW > 0.0:
                                            inputTextW = inputW - sendW - sendGap
                                        if px >= inputX && px <= inputX + inputTextW && py >= inputY && py <= inputY + inputH:
                                            state.focus = fkCodex
                                            state.lastEvent = "codex-input"
                                            continue
                                        let messagesTop: float64 = actionBottom
                                        let messagesBottom: float64 = inputY - 8.0 * state.layout.scale
                                        let msgH: float64 = codexMessageHeight(state.layout)
                                        let msgGap: float64 = 6.0 * state.layout.scale
                                        let msgStride: float64 = msgH + msgGap
                                        let availH: float64 = messagesBottom - messagesTop
                                        if availH >= msgH && codexCount > 0 && px >= contentX && px <= contentX + contentMaxW && py >= messagesTop && py <= messagesBottom:
                                            let visible: int32 = maxInt(1, int32(availH / msgStride))
                                            if visible > 0:
                                                let startIdx: int32 = maxInt(0, codexCount - visible)
                                                let relIdx: int32 = int32((py - messagesTop) / msgStride)
                                                if relIdx >= 0 && relIdx < visible:
                                                    let entryIdx: int32 = startIdx + relIdx
                                                    if entryIdx >= 0 && entryIdx < codexCount:
                                                        let lineText = seqGetString(state.codex.lines, entryIdx)
                                                        state.codex.selected = entryIdx
                                                        state.focus = fkCodex
                                                        if state.codex.status == "threads" || startsWithPrefix(lineText, "thr_"):
                                                            let threadId = guiCodexThreadIdFromLine(lineText)
                                                            if len(threadId) > 0 && startsWithPrefix(threadId, "thr_"):
                                                                state = guiCodexSelectThread(state, threadId)
                                                                state.lastEvent = "codex-thread"
                                                            else:
                                                                state.statusMsg = "codex: line " + intToStr(entryIdx + 1)
                                                                state.lastEvent = "codex-select"
                                                        else:
                                                            let url = guiCodexUrlFromLine(lineText)
                                                            if len(url) > 0:
                                                                state = guiOpenUrl(state, url)
                                                                state.lastEvent = "codex-url"
                                                            else:
                                                                let target = guiCodexOpenTargetFromLine(lineText)
                                                                if len(target) > 0:
                                                                    state = guiCodexOpenTarget(state, target)
                                                                    cursorDirty = true
                                                                    state.lastEvent = "codex-open"
                                                                else:
                                                                    state.statusMsg = "codex: line " + intToStr(entryIdx + 1)
                                                                    state.lastEvent = "codex-select"
                                                    else:
                                                        state.lastEvent = "codex"
                                                else:
                                                    state.lastEvent = "codex"
                                        else:
                                            state.lastEvent = "codex"
                                    elif state.rightPaneTab == rpTasks:
                                        state.lastEvent = "tasks"
                            else:
                                state.lastEvent = "right-panel"
                    elif inEditor:
                        state.focus = fkEditor
                        state.editor = clearSelectionHistory(state.editor)
                        let shiftHeld: bool = hasShift(eventLayout, mods)
                        let altHeld: bool = hasAlt(eventLayout, mods)
                        let gotoHeld: bool = gotoClickModifier(eventLayout, mods)
                        let pane: int32 = editorPaneIndex(state.layout, py, state.editor.splitActive)
                        if state.editor.splitActive:
                            state.editor.splitPane = pane
                        let paneMetrics: EditorPaneMetrics = editorPaneMetrics(state.layout, pane, state.editor.splitActive)
                        let paneScroll: int32 = scrollLineForPane(state.editor, pane)
                        let inGutter: bool = px < state.layout.codeX
                        if button != 0 && ! inGutter && ! altHeld && ! gotoHeld:
                            state = guiCodexAddSelection(state)
                            state.lastEvent = "codex-add-selection"
                            continue
                        if gotoHeld && ! inGutter:
                            let pos: CursorPos = cursorFromPointWithScroll(state.editor, state.layout, px, py, paneScroll, paneMetrics.codeY)
                            state.editor = clearMultiCursors(state.editor)
                            state.editor = clearSelection(state.editor)
                            state.editor = setCursorFromPos(state.editor, pos)
                            state = gotoDefinitionAt(state, pos.line, pos.col)
                            cursorDirty = true
                            state.lastEvent = "goto-def-click"
                            continue
                        if inGutter && altHeld:
                            let lineIdx: int32 = lineIndexFromPointWithScroll(state.editor, state.layout, py, paneScroll, paneMetrics.codeY)
                            state.editor = toggleFoldAtLine(state.editor, lineIdx)
                            cursorDirty = true
                            state.lastEvent = "fold-toggle"
                        elif inGutter && ! altHeld:
                            let lineIdx: int32 = lineIndexFromPointWithScroll(state.editor, state.layout, py, paneScroll, paneMetrics.codeY)
                            if button == 0 && ! state.editor.largeFile && lineIdx >= 0 && lineIdx < seqLenString(state.editor.lines):
                                let lineText = seqGetString(state.editor.lines, lineIdx)
                                if guiCodexTodoLine(lineText):
                                    let relY: float64 = py - paneMetrics.codeY
                                    var row: int32 = 0
                                    if state.layout.lineHeight > 0.0 && relY > 0.0:
                                        row = int32(relY / state.layout.lineHeight)
                                    let lineTop: float64 = paneMetrics.codeY + float64(row * state.layout.lineHeight)
                                    var lensX: float64 = 0.0
                                    var lensY: float64 = 0.0
                                    var lensW: float64 = 0.0
                                    var lensH: float64 = 0.0
                                    guiCodexTodoLensBounds(state.layout, state.layout.editorX, lineIdx, lineTop, lensX, lensY, lensW, lensH)
                                    if px >= lensX && px <= lensX + lensW && py >= lensY && py <= lensY + lensH:
                                        let prompt = guiCodexTodoPromptForLine(state, lineIdx, lineText)
                                        state = guiCodexAsk(state, prompt)
                                        state.lastEvent = "codex-todo"
                                        continue
                            state.editor = clearMultiCursors(state.editor)
                            var anchorLine: int32 = lineIdx
                            if shiftHeld && state.editor.selectionActive:
                                anchorLine = state.editor.selectionAnchorLine
                            state.editor = setLineSelection(state.editor, anchorLine, lineIdx)
                            state.lineSelectActive = true
                            state.lineSelectAnchorLine = anchorLine
                            cursorDirty = true
                            if button == 0:
                                state.draggingEditor = true
                                state.dragButton = button
                                state.dragPane = pane
                                state.lastEvent = "line-select"
                            else:
                                state.lastEvent = "line-click"
                        else:
                            let pos: CursorPos = cursorFromPointWithScroll(state.editor, state.layout, px, py, paneScroll, paneMetrics.codeY)
                            if altHeld:
                                state.editor = clearSelection(state.editor)
                                state.editor = toggleMultiCursor(state.editor, pos)
                                if button == 0:
                                    state.draggingEditor = true
                                    state.dragButton = button
                                    state.dragMulti = true
                                    state.dragPane = pane
                                    state.dragAnchorLine = pos.line
                                    state.dragAnchorCol = pos.col
                                state.lastEvent = "multi-click"
                            else:
                                state.editor = clearMultiCursors(state.editor)
                                if shiftHeld:
                                    state.editor = startSelection(state.editor)
                                    state.editor = setCursorFromPos(state.editor, pos)
                                else:
                                    state.editor = setCursorFromPos(state.editor, pos)
                                    state.editor = clearSelection(state.editor)
                                    state.editor = startSelection(state.editor)
                                cursorDirty = true
                                if button == 0:
                                    state.draggingEditor = true
                                    state.dragButton = button
                                    state.dragPane = pane
                                    state.lastEvent = "drag-start"
                                else:
                                    state.lastEvent = "click"
                    elif inBottomPane:
                        let tabIdx: int32 = bottomPaneTabIndexAtPoint(state, px, py)
                        if tabIdx >= 0:
                            state.bottomPaneTab = bottomPaneTabFromIndex(tabIdx)
                            if state.bottomPaneTab == bpTerminal:
                                state.focus = fkTerminal
                                state = cancelCompletion(state)
                            elif state.focus == fkTerminal:
                                state.focus = fkEditor
                            state.lastEvent = "bottom-tab"
                        else:
                            if state.bottomPaneTab != bpTerminal && state.focus == fkTerminal:
                                state.focus = fkEditor
                            if state.bottomPaneTab == bpTerminal:
                                let termIdx: int32 = terminalTabIndexAtPoint(state, px, py)
                                if termIdx >= 0:
                                    state = guiTerminalSwitchSession(state, termIdx)
                                    state.focus = fkTerminal
                                    state = cancelCompletion(state)
                                    state.lastEvent = "terminal-tab"
                                else:
                                    state.focus = fkTerminal
                                    state = cancelCompletion(state)
                                    state.lastEvent = "terminal-click"
                            elif state.bottomPaneTab == bpProblems:
                                let panelTopI: int32 = bottomPaneContentTop(state.layout)
                                let panelH: int32 = bottomPaneContentHeight(state.layout)
                                let listY: float64 = panelListStartY(state.layout, panelTopI)
                                let listLines: int32 = panelListVisibleLines(state.layout, panelH)
                                let headerTop: float64 = float64(panelTopI)
                                let headerBottom: float64 = headerTop + float64(panelHeaderHeight(state.layout))
                                let refreshLabel = "REFRESH"
                                let refreshW: float64 = textWidthForFont(refreshLabel, state.layout.smallFont, state.layout)
                                let refreshX: float64 = float64(state.layout.editorX + state.layout.editorW - panelPaddingX(state.layout) - refreshW)
                                var actionHit: bool = false
                                if py >= headerTop && py <= headerBottom && px >= refreshX && px <= refreshX + refreshW:
                                    state = guiRunLanguageDiagnostics(state)
                                    state.lastEvent = "problems-refresh"
                                    actionHit = true
                                if ! actionHit && py >= listY:
                                    let lineIdx: int32 = int32((py - listY) / state.layout.lineHeight)
                                    if lineIdx >= 0 && lineIdx < listLines:
                                        let total: int32 = state.diagnostics.len
                                        let maxScroll: int32 = maxInt(0, total - listLines)
                                        let startIdx: int32 = clampInt(state.bottomProblemsScroll, 0, maxScroll)
                                        let entryIdx: int32 = startIdx + lineIdx
                                        if entryIdx >= 0 && entryIdx < total:
                                            state.bottomProblemsSelected = entryIdx
                                            let entry: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(state.diagnostics, entryIdx)
                                            state = gotoLine(state, entry.line, entry.col)
                                            cursorDirty = true
                                            state.lastEvent = "diagnostic"
                                        else:
                                            state.lastEvent = "problems"
                                    else:
                                        state.lastEvent = "problems"
                                else:
                                    state.lastEvent = "problems"
                            elif state.bottomPaneTab == bpOutput:
                                let panelTopI: int32 = bottomPaneContentTop(state.layout)
                                let panelH: int32 = bottomPaneContentHeight(state.layout)
                                let listY: float64 = panelListStartY(state.layout, panelTopI)
                                let listLines: int32 = panelListVisibleLines(state.layout, panelH)
                                let headerTop: float64 = float64(panelTopI)
                                let headerBottom: float64 = headerTop + float64(panelHeaderHeight(state.layout))
                                let clearLabel = "CLEAR"
                                let clearW: float64 = textWidthForFont(clearLabel, state.layout.smallFont, state.layout)
                                let clearX: float64 = float64(state.layout.editorX + state.layout.editorW - panelPaddingX(state.layout) - clearW)
                                var actionHit: bool = false
                                if py >= headerTop && py <= headerBottom && px >= clearX && px <= clearX + clearW:
                                    state.taskLog = default[str[]]
                                    state.bottomOutputScroll = 0
                                    state.bottomOutputSelected = -1
                                    state.lastEvent = "output-clear"
                                    actionHit = true
                                if ! actionHit && py >= listY:
                                    let lineIdx: int32 = int32((py - listY) / state.layout.lineHeight)
                                    if lineIdx >= 0 && lineIdx < listLines:
                                        let total: int32 = seqLenString(state.taskLog)
                                        let maxScroll: int32 = maxInt(0, total - listLines)
                                        let startIdx: int32 = clampInt(state.bottomOutputScroll, 0, maxScroll)
                                        let entryIdx: int32 = startIdx + lineIdx
                                        if entryIdx >= 0 && entryIdx < total:
                                            state.bottomOutputSelected = entryIdx
                                            state.lastEvent = "output-select"
                                        else:
                                            state.lastEvent = "output"
                                    else:
                                        state.lastEvent = "output"
                                else:
                                    state.lastEvent = "output"
                            else:
                                state.lastEvent = "debug-console"
                    if debugPointer:
                        textutils.print("[input] lastEvent=" + state.lastEvent + "\n")
                elif kind == 8:
                    state = guiClearHover(state)
                    if debugPointer:
                        let rawX = loadF64(ev, xOffset)
                        let rawY = loadF64(ev, yOffset)
                        var px: float64 = 0.0
                        var py: float64 = 0.0
                        scalePointer(rawX, rawY, inputScale, width, height, px, py)
                        let mods: uint32 = loadU32(ev, modifiersOffset)
                        let button: int32 = loadI32(ev, buttonOffset)
                        textutils.print("[input] pointer-up raw=" + intToStr(int32(rawX)) + "," + intToStr(int32(rawY)) + " px=" + intToStr(int32(px)) + "," + intToStr(int32(py)) + " scale=" + intToStr(int32(inputScale * 100.0)) + " btn=" + intToStr(button) + " mods=" + intToStr(int32(mods)) + "\n")
                    state.draggingEditor = false
                    state.dragButton = -1
                    state.dragMulti = false
                    state.lineSelectActive = false
                    state.hoverExplorerAction = ExplorerActionNone
                    state.hoverSearchAction = SearchActionNone
                    state.hoverVcsAction = VcsActionNone
                    state.hoverLeftPaneTab = -1
                    state.hoverActivityBottom = ActivityBottomNone
                    if state.resizeDrag != rdNone:
                        state.resizeDrag = rdNone
                        state = guiWorkspaceStateSave(state)
                        state.lastEvent = "resize-end"
                    else:
                        state.lastEvent = "pointer-up"
                elif kind == 9:
                    let rawX = loadF64(ev, xOffset)
                    let rawY = loadF64(ev, yOffset)
                    var px: float64 = 0.0
                    var py: float64 = 0.0
                    scalePointer(rawX, rawY, inputScale, width, height, px, py)
                    if state.resizeDrag != rdNone:
                        state = applyResizeDrag(state, width, height, scale, px, py)
                        state.lastEvent = "resize"
                        continue
                    if state.draggingEditor && state.lineSelectActive:
                        let pane: int32 = if state.editor.splitActive: state.dragPane else: 0
                        if state.editor.splitActive:
                            state.editor.splitPane = pane
                        let paneMetrics: EditorPaneMetrics = editorPaneMetrics(state.layout, pane, state.editor.splitActive)
                        let paneScroll: int32 = scrollLineForPane(state.editor, pane)
                        let lineIdx: int32 = lineIndexFromPointWithScroll(state.editor, state.layout, py, paneScroll, paneMetrics.codeY)
                        state.focus = fkEditor
                        state.editor = setLineSelection(state.editor, state.lineSelectAnchorLine, lineIdx)
                        cursorDirty = true
                        state.lastEvent = "line-drag"
                    elif state.draggingEditor && state.dragMulti:
                        let pane: int32 = if state.editor.splitActive: state.dragPane else: 0
                        if state.editor.splitActive:
                            state.editor.splitPane = pane
                        let paneMetrics: EditorPaneMetrics = editorPaneMetrics(state.layout, pane, state.editor.splitActive)
                        let paneScroll: int32 = scrollLineForPane(state.editor, pane)
                        let pos: CursorPos = cursorFromPointWithScroll(state.editor, state.layout, px, py, paneScroll, paneMetrics.codeY)
                        state.focus = fkEditor
                        state.editor = setMultiCursorsFromRange(state.editor, state.dragAnchorLine, pos.line, pos.col)
                        cursorDirty = true
                        state.lastEvent = "multi-drag"
                    elif state.draggingEditor:
                        let pane: int32 = if state.editor.splitActive: state.dragPane else: 0
                        if state.editor.splitActive:
                            state.editor.splitPane = pane
                        let paneMetrics: EditorPaneMetrics = editorPaneMetrics(state.layout, pane, state.editor.splitActive)
                        let paneScroll: int32 = scrollLineForPane(state.editor, pane)
                        state.focus = fkEditor
                        state.editor = setCursorFromPointWithScroll(state.editor, state.layout, px, py, paneScroll, paneMetrics.codeY)
                        cursorDirty = true
                        state.lastEvent = "drag"
                    else:
                        let tabStripW: int32 = tabStripWidth(state.layout)
                        let tabControl: int32 = tabStripControlHit(state, tabStripW, px, py)
                        state.hoverTabControl = tabControl
                        if tabControl != TabControlNone:
                            state.hoverTab = -1
                            state.hoverTabClose = false
                        else:
                            let tabHover: TabHover = tabHoverInfoAtPoint(state, px, py)
                            state.hoverTab = tabHover.idx
                            state.hoverTabClose = tabHover.onClose
                        state.hoverRightPaneTab = rightPaneTabIndexAtPoint(state, px, py)
                        state.hoverBottomPaneTab = bottomPaneTabIndexAtPoint(state, px, py)
                        let barW: int32 = activityBarWidth(state.layout)
                        let inLeftPanel: bool = px >= 0.0 && px <= float64(state.layout.leftW) && py >= float64(state.layout.contentY) && py <= float64(state.layout.contentY + state.layout.contentH)
                        if inLeftPanel && px > float64(barW) && state.leftPaneTab == lpExplorer:
                            state.hoverExplorerAction = explorerHeaderActionHit(state.layout, px, py)
                        else:
                            state.hoverExplorerAction = ExplorerActionNone
                        if inLeftPanel && px > float64(barW) && state.leftPaneTab == lpSearch:
                            state.hoverSearchAction = searchHeaderActionHit(state.layout, px, py)
                        else:
                            state.hoverSearchAction = SearchActionNone
                        if inLeftPanel && px > float64(barW) && state.leftPaneTab == lpVcs:
                            state.hoverVcsAction = vcsHeaderActionHit(state.layout, px, py)
                        else:
                            state.hoverVcsAction = VcsActionNone
                        if inLeftPanel && px <= float64(barW):
                            state.hoverLeftPaneTab = leftPaneTabIndexAtPoint(state, px, py)
                            state.hoverActivityBottom = activityBottomIndexAtPoint(state, px, py)
                        else:
                            state.hoverLeftPaneTab = -1
                            state.hoverActivityBottom = ActivityBottomNone
                        state.hoverLeftPaneRow = -1
                        if inLeftPanel && px > float64(barW):
                            let debugOffset: int32 = explorerDebugLineOffset(state.layout)
                            let listYBase: float64 = explorerListStartY(state.layout) + float64(debugOffset * state.layout.lineHeight)
                            if state.leftPaneTab == lpExplorer:
                                if py >= listYBase:
                                    let lineIdx: int32 = int32((py - listYBase) / state.layout.lineHeight)
                                    if lineIdx >= 0 && lineIdx < explorerVisibleLines(state.layout):
                                        let itemIdx: int32 = state.explorer.scroll + lineIdx
                                        if itemIdx >= 0 && itemIdx < seqLenString(state.explorer.items):
                                            state.hoverLeftPaneRow = lineIdx
                            elif state.leftPaneTab == lpSearch:
                                var resultStartY: float64 = listYBase
                                var offset: int32 = 0
                                if len(state.search.query) > 0:
                                    resultStartY = listYBase + state.layout.lineHeight
                                    offset = 1
                                if py >= resultStartY:
                                    let lineIdx: int32 = int32((py - resultStartY) / state.layout.lineHeight)
                                    let totalResults: int32 = seqLenString(state.searchResults)
                                    let visibleLines: int32 = maxInt(1, explorerVisibleLines(state.layout) - offset)
                                    if lineIdx >= 0 && lineIdx < visibleLines:
                                        let maxScroll: int32 = maxInt(0, totalResults - visibleLines)
                                        let startIdx: int32 = clampInt(state.searchScroll, 0, maxScroll)
                                        let entryIdx: int32 = startIdx + lineIdx
                                        if entryIdx >= 0 && entryIdx < totalResults:
                                            state.hoverLeftPaneRow = lineIdx
                            elif state.leftPaneTab == lpVcs:
                                let summary: str = state.vcsSummary
                                let summaryLower = textutils.toLowerAscii(summary)
                                let summaryIsError: bool = summaryLower == "not a git repo" || summaryLower == "git error"
                                let vcsCount: int32 = seqLenString(state.vcsLines)
                                let vcsCounts: VcsCounts = guiVcsCounts(state.vcsLines)
                                let countsLabel = guiVcsCountsLabel(vcsCounts)
                                var lineOffset: int32 = 0
                                if len(summary) > 0:
                                    lineOffset = lineOffset + 1
                                let showCounts: bool = (len(summary) > 0 || vcsCount > 0) && ! summaryIsError && len(countsLabel) > 0
                                if showCounts:
                                    lineOffset = lineOffset + 1
                                let listStartY: float64 = listYBase + float64(lineOffset * state.layout.lineHeight)
                                if py >= listStartY:
                                    let lineIdx: int32 = int32((py - listStartY) / state.layout.lineHeight)
                                    let visibleLines: int32 = maxInt(1, explorerVisibleLines(state.layout) - lineOffset)
                                    if lineIdx >= 0 && lineIdx < visibleLines && lineIdx < vcsCount:
                                        state.hoverLeftPaneRow = lineIdx
                            elif state.leftPaneTab == lpCodex:
                                let panelX: int32 = barW
                                let panelW: int32 = maxInt(0, state.layout.leftW - barW)
                                if panelW > 0:
                                    let codexCount: int32 = seqLenString(state.codex.lines)
                                    let contentX: float64 = float64(panelX + panelPaddingX(state.layout))
                                    var contentMaxW: float64 = float64(panelW - 2.0 * panelPaddingX(state.layout))
                                    if contentMaxW < 0.0:
                                        contentMaxW = 0.0
                                    let contentListY: float64 = panelListStartY(state.layout, state.layout.contentY)
                                    let metaY: float64 = codexComputeMetaY(state, state.layout, contentX, contentMaxW, contentListY)
                                    var calloutTitle: str = ""
                                    var calloutBody: str = ""
                                    var calloutX: float64 = 0.0
                                    var calloutY: float64 = 0.0
                                    var calloutW: float64 = 0.0
                                    var calloutH: float64 = 0.0
                                    var calloutRects: CodexActionRect[] = default[CodexActionRect[]]
                                    var extraRects: CodexActionRect[] = default[CodexActionRect[]]
                                    var actionBottom: float64 = metaY
                                    codexComputeActionLayout(state, state.layout, contentX, contentMaxW, metaY, calloutTitle, calloutBody, calloutX, calloutY, calloutW, calloutH, calloutRects, extraRects, actionBottom)
                                    let paneBottom: float64 = float64(state.layout.contentY + state.layout.contentH)
                                    let inputH: float64 = codexInputHeight(state.layout)
                                    var inputY: float64 = paneBottom - inputH - 8.0 * state.layout.scale
                                    if inputY < actionBottom + 8.0 * state.layout.scale:
                                        inputY = actionBottom + 8.0 * state.layout.scale
                                    let messagesTop: float64 = actionBottom
                                    let messagesBottom: float64 = inputY - 8.0 * state.layout.scale
                                    let msgH: float64 = codexMessageHeight(state.layout)
                                    let msgGap: float64 = 6.0 * state.layout.scale
                                    let msgStride: float64 = msgH + msgGap
                                    let availH: float64 = messagesBottom - messagesTop
                                    if codexCount > 0 && availH >= msgH && px >= contentX && px <= contentX + contentMaxW && py >= messagesTop && py <= messagesBottom:
                                        let visible: int32 = maxInt(1, int32(availH / msgStride))
                                        if visible > 0:
                                            let startIdx: int32 = maxInt(0, codexCount - visible)
                                            let relIdx: int32 = int32((py - messagesTop) / msgStride)
                                            if relIdx >= 0 && relIdx < visible:
                                                let entryIdx: int32 = startIdx + relIdx
                                                if entryIdx >= 0 && entryIdx < codexCount:
                                                    state.hoverLeftPaneRow = entryIdx
                            else:
                                if py >= listYBase:
                                    let lineIdx: int32 = int32((py - listYBase) / state.layout.lineHeight)
                                    let actionCount: int32 = runActionCount()
                                    if lineIdx >= 0 && lineIdx < explorerVisibleLines(state.layout) && lineIdx < actionCount:
                                        state.hoverLeftPaneRow = lineIdx
                        state.hoverRightPaneRow = -1
                        let rightW: int32 = state.layout.rightW
                        let inRightPanel: bool = rightW > 0 && px >= float64(state.layout.leftW + state.layout.editorW) && px <= float64(state.layout.leftW + state.layout.editorW + rightW) && py >= float64(state.layout.contentY) && py <= float64(state.layout.contentY + state.layout.contentH)
                        if inRightPanel:
                            let listY: float64 = rightPaneContentListStartY(state.layout)
                            let contentLines: int32 = rightPaneContentVisibleLines(state.layout)
                            if py >= listY:
                                let lineIdx: int32 = int32((py - listY) / state.layout.lineHeight)
                                if lineIdx >= 0 && (lineIdx < contentLines || state.rightPaneTab == rpCodex):
                                    if state.rightPaneTab == rpOutline:
                                        if lineIdx < seqLenString(state.editor.outlineEntries):
                                            state.hoverRightPaneRow = lineIdx
                                    elif state.rightPaneTab == rpDiagnostics:
                                        if lineIdx < state.diagnostics.len:
                                            state.hoverRightPaneRow = lineIdx
                                    elif state.rightPaneTab == rpDebugger:
                                        let debugLines: str[] = guiDebuggerLines(state.debugger)
                                        if lineIdx < seqLenString(debugLines):
                                            state.hoverRightPaneRow = lineIdx
                                    elif state.rightPaneTab == rpVcs:
                                        var entryIdx: int32 = lineIdx
                                        var lineOffset: int32 = 0
                                        let vcsCounts: VcsCounts = guiVcsCounts(state.vcsLines)
                                        let countsLabel = guiVcsCountsLabel(vcsCounts)
                                        if len(state.vcsSummary) > 0:
                                            if lineIdx == 0:
                                                entryIdx = -1
                                            lineOffset = lineOffset + 1
                                        if (len(state.vcsSummary) > 0 || seqLenString(state.vcsLines) > 0) && len(countsLabel) > 0:
                                            if lineIdx == lineOffset:
                                                entryIdx = -1
                                            lineOffset = lineOffset + 1
                                        if entryIdx >= 0:
                                            entryIdx = lineIdx - lineOffset
                                        if entryIdx >= 0 && entryIdx < seqLenString(state.vcsLines):
                                            state.hoverRightPaneRow = lineIdx
                                    elif state.rightPaneTab == rpCodex:
                                        let codexCount: int32 = seqLenString(state.codex.lines)
                                        let rightPaneX: int32 = state.layout.leftW + state.layout.editorW
                                        let rightPaneW: int32 = state.layout.rightW
                                        let contentX: float64 = float64(rightPaneX + panelPaddingX(state.layout))
                                        let contentMaxW: float64 = float64(rightPaneW - 2.0 * panelPaddingX(state.layout))
                                        let contentListY: float64 = rightPaneContentListStartY(state.layout)
                                        let metaY: float64 = codexComputeMetaY(state, state.layout, contentX, contentMaxW, contentListY)
                                        var calloutTitle: str = ""
                                        var calloutBody: str = ""
                                        var calloutX: float64 = 0.0
                                        var calloutY: float64 = 0.0
                                        var calloutW: float64 = 0.0
                                        var calloutH: float64 = 0.0
                                        var calloutRects: CodexActionRect[] = default[CodexActionRect[]]
                                        var extraRects: CodexActionRect[] = default[CodexActionRect[]]
                                        var actionBottom: float64 = metaY
                                        codexComputeActionLayout(state, state.layout, contentX, contentMaxW, metaY, calloutTitle, calloutBody, calloutX, calloutY, calloutW, calloutH, calloutRects, extraRects, actionBottom)
                                        let paneBottom: float64 = float64(state.layout.contentY + state.layout.contentH)
                                        let inputH: float64 = codexInputHeight(state.layout)
                                        var inputY: float64 = paneBottom - inputH - 8.0 * state.layout.scale
                                        if inputY < actionBottom + 8.0 * state.layout.scale:
                                            inputY = actionBottom + 8.0 * state.layout.scale
                                        let messagesTop: float64 = actionBottom
                                        let messagesBottom: float64 = inputY - 8.0 * state.layout.scale
                                        let msgH: float64 = codexMessageHeight(state.layout)
                                        let msgGap: float64 = 6.0 * state.layout.scale
                                        let msgStride: float64 = msgH + msgGap
                                        let availH: float64 = messagesBottom - messagesTop
                                        if codexCount > 0 && availH >= msgH && px >= contentX && px <= contentX + contentMaxW && py >= messagesTop && py <= messagesBottom:
                                            let visible: int32 = maxInt(1, int32(availH / msgStride))
                                            if visible > 0:
                                                let startIdx: int32 = maxInt(0, codexCount - visible)
                                                let relIdx: int32 = int32((py - messagesTop) / msgStride)
                                                if relIdx >= 0 && relIdx < visible:
                                                    let entryIdx: int32 = startIdx + relIdx
                                                    if entryIdx >= 0 && entryIdx < codexCount:
                                                        state.hoverRightPaneRow = entryIdx
                                    elif state.rightPaneTab == rpTasks:
                                        let taskCount: int32 = seqLenString(state.taskLog)
                                        if taskCount > 0:
                                            let taskStart: int32 = maxInt(0, taskCount - contentLines)
                                            if taskStart + lineIdx < taskCount:
                                                state.hoverRightPaneRow = lineIdx
                        state.hoverBottomPaneRow = -1
                        let inBottomPane: bool = px >= float64(state.layout.editorX) && px <= float64(state.layout.editorX + state.layout.editorW) && py >= float64(state.layout.bottomY) && py <= float64(state.layout.bottomY + state.layout.bottomH)
                        if inBottomPane && state.layout.bottomH > 0:
                            let panelTopI: int32 = bottomPaneContentTop(state.layout)
                            let panelH: int32 = bottomPaneContentHeight(state.layout)
                            let listY: float64 = panelListStartY(state.layout, panelTopI)
                            let listLines: int32 = panelListVisibleLines(state.layout, panelH)
                            if py >= listY:
                                let lineIdx: int32 = int32((py - listY) / state.layout.lineHeight)
                                if lineIdx >= 0 && lineIdx < listLines:
                                    if state.bottomPaneTab == bpProblems:
                                        let total: int32 = state.diagnostics.len
                                        let maxScroll: int32 = maxInt(0, total - listLines)
                                        let startIdx: int32 = clampInt(state.bottomProblemsScroll, 0, maxScroll)
                                        let entryIdx: int32 = startIdx + lineIdx
                                        if entryIdx >= 0 && entryIdx < total:
                                            state.hoverBottomPaneRow = lineIdx
                                    elif state.bottomPaneTab == bpOutput:
                                        let total: int32 = seqLenString(state.taskLog)
                                        let maxScroll: int32 = maxInt(0, total - listLines)
                                        let startIdx: int32 = clampInt(state.bottomOutputScroll, 0, maxScroll)
                                        let entryIdx: int32 = startIdx + lineIdx
                                        if entryIdx >= 0 && entryIdx < total:
                                            state.hoverBottomPaneRow = lineIdx
                        state = updateHoverFromPoint(state, px, py)
                elif kind == 11:
                    state = guiClearHover(state)
                    state.draggingEditor = false
                    state.dragButton = -1
                    state.dragMulti = false
                    state.lineSelectActive = false
                    state.hoverTab = -1
                    state.hoverTabClose = false
                    state.hoverTabControl = TabControlNone
                    state.hoverExplorerAction = ExplorerActionNone
                    state.hoverSearchAction = SearchActionNone
                    state.hoverVcsAction = VcsActionNone
                    state.hoverLeftPaneTab = -1
                    state.hoverActivityBottom = ActivityBottomNone
                    if state.resizeDrag != rdNone:
                        state.resizeDrag = rdNone
                        state = guiWorkspaceStateSave(state)
                        state.lastEvent = "resize-cancel"
                    else:
                        state.lastEvent = "pointer-leave"
                elif kind == 10:
                    state = guiClearHover(state)
                    let dy: float64 = loadF64(ev, deltaYOffset)
                    let rawX = loadF64(ev, xOffset)
                    let rawY = loadF64(ev, yOffset)
                    var px: float64 = 0.0
                    var py: float64 = 0.0
                    scalePointer(rawX, rawY, inputScale, width, height, px, py)
                    let tabStartX: float64 = tabStripStartX(state.layout)
                    let tabEndX: float64 = tabStripEndX(width, state.layout)
                    let tabTop: float64 = tabStripTop(state.layout)
                    let tabH: int32 = tabStripHeight(state.layout)
                    let inTabStrip: bool = tabH > 0 && py >= tabTop && py <= tabTop + float64(tabH) && px >= tabStartX && px <= tabEndX
                    if inTabStrip:
                        let tabStep: float64 = tabMinWidth(state.layout)
                        var delta: float64 = 0.0
                        if dy > 0.0:
                            delta = -tabStep
                        elif dy < 0.0:
                            delta = tabStep
                        if delta != 0.0:
                            state = tabStripScroll(state, tabStripWidth(state.layout), delta)
                            state.lastEvent = "scroll-tabs"
                            continue
                    let inLeftPanel: bool = px >= 0.0 && px <= float64(state.layout.leftW) && py >= float64(state.layout.contentY) && py <= float64(state.layout.contentY + state.layout.contentH)
                    if inLeftPanel:
                        if state.leftPaneTab == lpExplorer:
                            if dy > 0.0:
                                state.explorer = scrollExplorer(state.explorer, -3, state.layout)
                            elif dy < 0.0:
                                state.explorer = scrollExplorer(state.explorer, 3, state.layout)
                            state.lastEvent = "scroll-explorer"
                        elif state.leftPaneTab == lpSearch:
                            let totalResults: int32 = seqLenString(state.searchResults)
                            let offset: int32 = if len(state.search.query) > 0: 1 else: 0
                            let visibleLines: int32 = maxInt(1, explorerVisibleLines(state.layout) - offset)
                            let maxScroll: int32 = maxInt(0, totalResults - visibleLines)
                            if dy > 0.0:
                                state.searchScroll = clampInt(state.searchScroll - 3, 0, maxScroll)
                            elif dy < 0.0:
                                state.searchScroll = clampInt(state.searchScroll + 3, 0, maxScroll)
                            state.lastEvent = "scroll-search"
                    else:
                        var scrollHandled = false
                        let inBottomPane: bool = px >= float64(state.layout.editorX) && px <= float64(state.layout.editorX + state.layout.editorW) && py >= float64(state.layout.bottomY) && py <= float64(state.layout.bottomY + state.layout.bottomH)
                        if inBottomPane && state.layout.bottomH > 0:
                            if state.bottomPaneTab == bpProblems:
                                let panelH: int32 = bottomPaneContentHeight(state.layout)
                                let listLines: int32 = panelListVisibleLines(state.layout, panelH)
                                let total: int32 = state.diagnostics.len
                                let maxScroll: int32 = maxInt(0, total - listLines)
                                if dy > 0.0:
                                    state.bottomProblemsScroll = clampInt(state.bottomProblemsScroll - 3, 0, maxScroll)
                                elif dy < 0.0:
                                    state.bottomProblemsScroll = clampInt(state.bottomProblemsScroll + 3, 0, maxScroll)
                                state.lastEvent = "scroll-problems"
                                scrollHandled = true
                            elif state.bottomPaneTab == bpOutput:
                                let panelH: int32 = bottomPaneContentHeight(state.layout)
                                let listLines: int32 = panelListVisibleLines(state.layout, panelH)
                                let total: int32 = seqLenString(state.taskLog)
                                let maxScroll: int32 = maxInt(0, total - listLines)
                                if dy > 0.0:
                                    state.bottomOutputScroll = clampInt(state.bottomOutputScroll - 3, 0, maxScroll)
                                elif dy < 0.0:
                                    state.bottomOutputScroll = clampInt(state.bottomOutputScroll + 3, 0, maxScroll)
                                state.lastEvent = "scroll-output"
                                scrollHandled = true
                        if ! scrollHandled:
                            let inEditor: bool = px >= float64(state.layout.editorX) && px <= float64(state.layout.editorX + state.layout.editorW) && py >= float64(state.layout.editorY) && py <= float64(state.layout.bottomY)
                            if inEditor && state.editor.splitActive:
                                let pane: int32 = editorPaneIndex(state.layout, py, true)
                                state.editor.splitPane = pane
                            if dy > 0.0:
                                state.editor = scrollLines(state.editor, -3, state.layout)
                                scrollDirty = true
                            elif dy < 0.0:
                                state.editor = scrollLines(state.editor, 3, state.layout)
                                scrollDirty = true
                            if scrollDirty:
                                state.lastEvent = "scroll"
            if cursorDirty:
                state.editor = ensureCursorVisible(state.editor, state.layout)
            elif scrollDirty:
                state.editor = scrollLines(state.editor, 0, state.layout)
            if got > 0:
                if state.focus != fkEditor || state.overlay.kind != okNone:
                    state = guiClearSignature(state)
                else:
                    state = updateSignatureHint state
            if got > 0:
                state.renderDirty = true
                state.renderNextMs = 0
        if state.perf.enabled:
            let eventsEndMs = guiNowMs()
            state.perf.eventsMs = guiMsDiff(perfEventsStartMs, eventsEndMs)
        let nowMsTick: int64 = guiNowMs()
        let hadInput: bool = got > 0
        if hadInput:
            state.lastInputMs = nowMsTick
        let backgroundNeeded = state.terminal.ptyActive || state.taskRunner.active || guiTaskQueueLen(state.taskRunner) > 0 || state.codex.ptyActive || seqLenString(state.codex.sendQueue) > 0 || state.diagPending || state.autoSavePending || state.recoveryPending || state.diagnosticsDirty || ! state.editor.outlineReady || ! state.editor.semanticReady
        var runBackground = true
        if hadInput:
            runBackground = false
        if got == 0 && ! state.renderDirty && ! backgroundNeeded && state.backgroundTickIntervalMs > 0:
            if state.backgroundTickNextMs > 0 && nowMsTick < state.backgroundTickNextMs:
                runBackground = false
            else:
                state.backgroundTickNextMs = nowMsTick + int64(state.backgroundTickIntervalMs)
        elif state.backgroundTickIntervalMs > 0:
            state.backgroundTickNextMs = nowMsTick + int64(state.backgroundTickIntervalMs)
        if runBackground:
            let recentInput = state.backgroundInteractiveDelayMs > 0 && state.lastInputMs > 0 && (nowMsTick - state.lastInputMs) < int64(state.backgroundInteractiveDelayMs)
            var bgBudgetMs: int32 = state.backgroundBudgetMs
            let bgStartMs: int64 = nowMsTick
            var bgExpired = false
            state = syncActiveBuffer(state)
            if ! bgExpired:
                state = guiDesktopCommandTick(state)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
            if ! recentInput && ! bgExpired:
                let outlineBudget = if bgBudgetMs > 0: bgBudgetMs else: 0
                state = guiOutlineScanTick(state, state.outlineChunkLines, outlineBudget)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
            if ! recentInput && ! bgExpired:
                let semanticBudget = if bgBudgetMs > 0: bgBudgetMs else: 0
                state = guiSemanticScanTick(state, state.semanticChunkLines, semanticBudget)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
            if state.perf.enabled:
                perfPtyStartMs = guiNowMs()
            if ! bgExpired:
                state = guiPtyTick(state)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
            if state.perf.enabled:
                let ptyEndMs = guiNowMs()
                state.perf.ptyMs = guiMsDiff(perfPtyStartMs, ptyEndMs)
            if state.perf.enabled:
                perfTaskStartMs = guiNowMs()
            if ! recentInput && ! bgExpired:
                state = guiTaskRunnerTick(state)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
            if state.perf.enabled:
                let taskEndMs = guiNowMs()
                state.perf.taskMs = guiMsDiff(perfTaskStartMs, taskEndMs)
            if state.perf.enabled:
                perfCodexStartMs = guiNowMs()
            if ! bgExpired:
                state = guiCodexTick(state)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
            if ! bgExpired:
                state = guiCodexAuthTick(state)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
            if state.perf.enabled:
                let codexEndMs = guiNowMs()
                state.perf.codexMs = guiMsDiff(perfCodexStartMs, codexEndMs)
            if state.perf.enabled:
                perfDiagStartMs = guiNowMs()
            if ! recentInput && ! bgExpired:
                state = guiTickAutoDiagnostics(state, got)
                state = guiTickAutoSave(state, got)
                state = guiTickRecovery(state, got)
                if state.diagnosticsDirty && got == 0:
                    if state.diagChunkLines > 0:
                        state = guiDiagScanTick(state, state.diagChunkLines, bgBudgetMs)
                    else:
                        state = guiUpdateDiagnostics(state)
            if state.perf.enabled:
                let diagEndMs = guiNowMs()
                state.perf.diagMs = guiMsDiff(perfDiagStartMs, diagEndMs)
            if ! recentInput && ! bgExpired && ! state.projectIndexReady && state.projectChunkFiles > 0:
                state = guiProjectIndexTick(state, state.projectChunkFiles, bgBudgetMs)
                bgExpired = guiBudgetExpired(bgStartMs, bgBudgetMs)
        state = guiUpdateRenderLite(state)
        if state.quitRequested:
            state = guiWorkspaceStateSave(state)
            running = false
        if ! running:
            break

        var allowRender: bool = state.renderDirty
        if allowRender && state.renderMinIntervalMs > 0 && ! hadInput:
            let nowMs: int64 = guiNowMs()
            if state.renderNextMs > nowMs:
                allowRender = false
        if ! allowRender:
            if got == 0 && len(state.lastEvent) == 0:
                state.lastEvent = "idle"
            continue

        let beginRc: int32 = chengGuiNativeBeginFrame(surface)
        chengGuiNativeGetSurfaceInfo(surface, &info)
        let newW: int32 = int32(info.pixelWidth)
        let newH: int32 = int32(info.pixelHeight)
        let newScale: float64 = info.scale
        let newLogicalW: float64 = info.logicalWidth
        let newLogicalH: float64 = info.logicalHeight

        if newScale > 0.0 && newScale != scale:
            scale = newScale
        if newLogicalW > 0.0:
            logicalWidth = newLogicalW
        if newLogicalH > 0.0:
            logicalHeight = newLogicalH
        if newW > 0 && newH > 0 && (newW != width || newH != height):
            width = newW
            height = newH
            strideBytes = width * 4
            bufSize = strideBytes * height
            pixels = realloc(pixels, bufSize)
        state = clampPaneSizes(state, width, height, scale)
        let newLayoutKey: int64 = calcLayoutKey(state, width, height, scale)
        if newLayoutKey != state.layoutKey:
            state.layout = calcLayout(state, width, height, scale)
            state.layoutKey = newLayoutKey

        if got == 0 && len(state.lastEvent) == 0:
            state.lastEvent = "idle"
        var renderStartMs: int64 = guiNowMs()
        if state.perf.enabled:
            perfRenderStartMs = renderStartMs
        renderGui(pixels, width, height, strideBytes, scale, textBackend, state)
        let renderEndMs = guiNowMs()
        if state.perf.enabled:
            state.perf.renderMs = guiMsDiff(renderStartMs, renderEndMs)
        perfPresentStartMs = renderEndMs
        let presentRc: int32 = chengGuiNativePresentPixels(surface, pixels, int32(width), int32(height), int32(strideBytes))
        let endRc: int32 = chengGuiNativeEndFrame(surface)
        let presentEndMs = guiNowMs()
        state.renderLastMs = guiMsDiff(renderStartMs, presentEndMs)
        if state.perf.enabled:
            state.perf.presentMs = guiMsDiff(perfPresentStartMs, presentEndMs)
            state.perf.frameMs = guiMsDiff(perfFrameStartMs, presentEndMs)
            if state.perf.frameMs >= state.perf.slowFrameMs:
                state.perf.slowFrames = state.perf.slowFrames + 1
            if state.perf.logEveryMs > 0 && presentEndMs - state.perf.lastLogMs >= int64(state.perf.logEveryMs):
                state.perf.lastLogMs = presentEndMs
                textutils.print("[perf] frame=" + intToStr(state.perf.frameMs) + "ms poll=" + intToStr(state.perf.pollMs) + " events=" + intToStr(state.perf.eventsMs) + " pty=" + intToStr(state.perf.ptyMs) + " task=" + intToStr(state.perf.taskMs) + " codex=" + intToStr(state.perf.codexMs) + " diag=" + intToStr(state.perf.diagMs) + " render=" + intToStr(state.perf.renderMs) + " present=" + intToStr(state.perf.presentMs) + " slow=" + intToStr(state.perf.slowFrames) + "\n")
            state.renderNextMs = presentEndMs + int64(state.renderMinIntervalMs)
        else:
            if state.renderMinIntervalMs > 0:
                state.renderNextMs = presentEndMs + int64(state.renderMinIntervalMs)
        state.renderDirty = false

        if frame == 0 || beginRc != 0 || presentRc != 0 || endRc != 0:
            textutils.print("[gui-native] frame=" + intToStr(int32(frame)) + " events=" + intToStr(int32(got)) + " begin=" + intToStr(beginRc) + " present=" + intToStr(presentRc) + " end=" + intToStr(endRc) + "\n")

        frame = frame + 1
        if frames > 0 && frame >= frames:
            running = false

    state = guiTerminalShutdownAll(state)
    p2p_bridge.guiP2PStop()
    dealloc(pixels)
    dealloc(events)
    chengGuiNativeDestroySurface(surface)
    chengGuiNativeDestroyWindow(window)
    chengGuiNativeShutdown()
    textutils.print "[gui-native] exit\n"
    return "[gui-native] demo finished\n"
