import std/os
import std/strings

fn cEq(a: char, b: char): bool =
    let va = int32(a)
    let vb = int32(b)
    if va < vb:
        return false
    if va > vb:
        return false
    return true

fn cNe(a: char, b: char): bool =
    return int32(a) != int32(b)

fn cGe(a: char, b: char): bool =
    return int32(a) >= int32(b)

fn cLe(a: char, b: char): bool =
    return int32(a) <= int32(b)

fn escapeChengString(text: str): str =
    if len(text) == 0:
        return ""
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < len(text):
        let ch = text[idx]
        if cEq(ch, '\\'):
            out = out + "\\\\"
        elif cEq(ch, '"'):
            out = out + "\\\""
        elif cEq(ch, '\n'):
            out = out + "\\n"
        elif cEq(ch, '\r'):
            out = out + "\\r"
        elif cEq(ch, '\t'):
            out = out + "\\t"
        else:
            out = out + charToStr(ch)
        idx = idx + int32(1)
    return out

fn buildProjectName(projectProfileName, profile: str): str =
    if len(projectProfileName) > 0:
        return projectProfileName
    if len(profile) > 0:
        return profile
    return "r2capp"

fn buildEntrySource(profile: str, moduleCount: int32): str =
    var out: str = ""
    out = out + "import gui/browser/web\n"
    out = out + "import cheng/r2capp/runtime_generated as generatedRuntime\n\n"
    out = out + "fn mount(page: web.BrowserPage): bool =\n"
    out = out + "    return generatedRuntime.mountGenerated(page)\n\n"
    out = out + "fn compileProfile(): str =\n"
    out = out + "    return \"" + escapeChengString(profile) + "\"\n\n"
    out = out + "fn compiledModuleCount(): int32 =\n"
    out = out + "    return int32(" + strings.intToStr(moduleCount) + ")\n"
    return out

fn buildDomGeneratedSource(projectName: str): str =
    let projectName = buildProjectName(projectName, "")
    var out: str = ""
    out = out + "import gui/browser/web\n\n"
    out = out + "fn profileId(): str =\n"
    out = out + "    return \"" + escapeChengString(projectName) + "\"\n\n"
    out = out + "fn mountDom(page: web.BrowserPage): bool =\n"
    out = out + "    if page == nil:\n"
    out = out + "        return false\n"
    out = out + "    if len(page.r2cApp) == 0:\n"
    out = out + "        page.r2cApp = \"" + escapeChengString(projectName) + "\"\n"
    out = out + "    return true\n"
    return out

fn buildEventsGeneratedSource(projectName: str): str =
    projectName
    var out: str = ""
    out = out + "import gui/browser/web\n\n"
    out = out + "fn dispatchEvent(page: web.BrowserPage, eventName, targetSelector, payload: str): bool =\n"
    out = out + "    if page == nil:\n"
    out = out + "        return false\n"
    out = out + "    page.r2cCurrentTab = page.r2cCurrentTab\n"
    out = out + "    page.r2cLocale = page.r2cLocale\n"
    out = out + "    page.snapshotText = page.snapshotText + \"EVENT:\" + eventName + \";TARGET:\" + targetSelector + \";PAYLOAD:\" + payload + \"\\n\"\n"
    out = out + "    return true\n"
    return out

fn buildWebApiGeneratedSource(projectName: str): str =
    projectName
    var out: str = ""
    out = out + "import gui/browser/web\n\n"
    out = out + "fn bootstrapWebApi(page: web.BrowserPage): bool =\n"
    out = out + "    if page == nil:\n"
    out = out + "        return false\n"
    out = out + "    return true\n\n"
    out = out + "fn drainEffectsWebApi(page: web.BrowserPage, limit: int32): int32 =\n"
    out = out + "    if page == nil:\n"
    out = out + "        return int32(0)\n"
    out = out + "    if limit < int32(0):\n"
    out = out + "        return int32(0)\n"
    out = out + "    return int32(0)\n"
    return out

fn runtimeTemplatePath(): str =
    let envRoot = os.getEnv("GUI_ROOT")
    if len(envRoot) > 0:
        let byEnvSrcRoot = envRoot + "/tools/r2c_aot/runtime_generated_template.cheng"
        if os.fileExists(byEnvSrcRoot):
            return byEnvSrcRoot
        let byEnvPkgRoot = envRoot + "/src/tools/r2c_aot/runtime_generated_template.cheng"
        if os.fileExists(byEnvPkgRoot):
            return byEnvPkgRoot
    let absolutePath = "/Users/lbcheng/.cheng-packages/cheng-gui/src/tools/r2c_aot/runtime_generated_template.cheng"
    if os.fileExists(absolutePath):
        return absolutePath
    let localPath = "src/tools/r2c_aot/runtime_generated_template.cheng"
    if os.fileExists(localPath):
        return localPath
    return ""

fn replaceTokenAll(text, token, value: str): str =
    if len(text) == 0 || len(token) == 0:
        return text
    var out: str = ""
    var idx: int32 = int32(0)
    let tLen = len(token)
    while idx < len(text):
        var matched = false
        if idx + tLen <= len(text):
            matched = true
            var j: int32 = int32(0)
            while j < tLen:
                if int32(text[idx + j]) != int32(token[j]):
                    matched = false
                    break
                j = j + int32(1)
        if matched:
            out = out + value
            idx = idx + tLen
        else:
            out = out + charToStr(text[idx])
            idx = idx + int32(1)
    return out

fn findChar(text: str, needle: char, start: int32): int32 =
    if len(text) <= 0:
        return int32(-1)
    var idx = start
    if idx < int32(0):
        idx = int32(0)
    while idx < len(text):
        if cEq(text[idx], needle):
            return idx
        idx = idx + int32(1)
    return int32(-1)

fn lowerAsciiChar(ch: char): char =
    if int32(ch) >= int32('A') && int32(ch) <= int32('Z'):
        return char(int32(ch) - int32('A') + int32('a'))
    return ch

fn lowerAscii(text: str): str =
    if len(text) <= 0:
        return ""
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < len(text):
        out = out + charToStr(lowerAsciiChar(text[idx]))
        idx = idx + int32(1)
    return out

fn containsText(text, needle: str): bool =
    if len(text) == 0 || len(needle) == 0:
        return false
    if len(needle) <= 0:
        return true
    if len(text) < len(needle):
        return false
    var idx: int32 = int32(0)
    while idx + len(needle) <= len(text):
        var matched = true
        var j: int32 = int32(0)
        while j < len(needle):
            if cNe(text[idx + j], needle[j]):
                matched = false
                break
            j = j + int32(1)
        if matched:
            return true
        idx = idx + int32(1)
    return false

fn normalizeModuleId(moduleId: str): str =
    if len(moduleId) == 0:
        return "/unknown"
    if cEq(moduleId[0], '/'):
        return moduleId
    return "/" + moduleId

fn semanticRouteHintFromText(moduleId, value: str): str =
    if len(moduleId) == 0:
        moduleId = ""
    if len(value) == 0:
        value = ""
    let source = lowerAscii(moduleId + "|" + value)
    if containsText(source, "language"):
        return "lang_select"
    if containsText(source, "publish"):
        if containsText(source, "crowdfunding"):
            return "publish_crowdfunding"
        if containsText(source, "secondhand"):
            return "publish_secondhand"
        if containsText(source, "product"):
            return "publish_product"
        if containsText(source, "content"):
            return "publish_content"
        if containsText(source, "food"):
            return "publish_food"
        if containsText(source, "ride"):
            return "publish_ride"
        if containsText(source, "rent"):
            return "publish_rent"
        if containsText(source, "sell"):
            return "publish_sell"
        if containsText(source, "hire"):
            return "publish_hire"
        if containsText(source, "job"):
            return "publish_job"
        if containsText(source, "live"):
            return "publish_live"
        if containsText(source, "app"):
            return "publish_app"
        return "publish_selector"
    if containsText(source, "trading") || containsText(source, "kline") || containsText(source, "chart"):
        return "trading_main"
    if containsText(source, "marketplace"):
        return "marketplace_main"
    if containsText(source, "update"):
        return "update_center_main"
    if containsText(source, "ecom"):
        return "ecom_main"
    if containsText(source, "message") || containsText(source, "chat"):
        return "tab_messages"
    if containsText(source, "node"):
        return "tab_nodes"
    if containsText(source, "profile") || containsText(source, "wallet"):
        return "tab_profile"
    if containsText(source, "home"):
        return "home_default"
    return ""

fn semanticRoleByKind(kind: str): str =
    if kind == "jsx-tag":
        return "element"
    if kind == "id" || kind == "class" || kind == "testid":
        return "element"
    if kind == "event":
        return "event"
    if kind == "hook":
        return "hook"
    return "text"

fn semanticEventBindingByKind(kind, value: str): str =
    if kind == "event":
        return value
    return ""

fn semanticHookSlotByKind(kind, value: str): str =
    if kind == "hook":
        return value
    return ""

fn parsePositiveIntOrDefault(text: str, fallback: int32): int32 =
    if len(text) <= int32(0):
        return fallback
    var value: int32 = int32(0)
    var idx: int32 = int32(0)
    while idx < len(text):
        let ch = text[idx]
        if ! cGe(ch, '0') || ! cLe(ch, '9'):
            return fallback
        value = value * int32(10) + int32(ch) - int32('0')
        idx = idx + int32(1)
    if value <= int32(0):
        return fallback
    return value

fn runtimeSemanticNodeLimit(): int32 =
    let raw = os.getEnv("R2C_RUNTIME_SEMANTIC_NODE_LIMIT")
    return parsePositiveIntOrDefault(raw, int32(1500))

fn trimSemanticValue(value: str): str =
    if len(value) == 0:
        return ""
    let maxLen = int32(160)
    if len(value) <= maxLen:
        return value
    return value[0..<maxLen]

fn codegenTraceEnabled(): bool =
    return os.getEnv("R2C_TRACE") == "1"

fn codegenTracePath(): str =
    let outRoot = os.getEnv("R2C_OUT_ROOT")
    if len(outRoot) == 0:
        return ""
    return outRoot + "/r2c_codegen_trace.txt"

var codegenTraceText: str = ""

fn codegenTraceStep(step: str) =
    if ! codegenTraceEnabled():
        return
    let path = codegenTracePath()
    if len(path) == 0:
        return
    codegenTraceText = codegenTraceText + step + "\n"
    os.writeFile(path, codegenTraceText)

fn buildSemanticNodeAppends(semanticNodes: str[]): str =
    codegenTraceStep("buildSemanticNodeAppends:start;len=" + strings.intToStr(len(semanticNodes)))
    var out: str = ""
    var idx: int32 = int32(0)
    var emitted: int32 = int32(0)
    let limit = runtimeSemanticNodeLimit()
    while idx < len(semanticNodes):
        if idx % int32(64) == int32(0):
            codegenTraceStep("buildSemanticNodeAppends:loop;idx=" + strings.intToStr(idx) + ";emitted=" + strings.intToStr(emitted))
        if limit > int32(0) && emitted >= limit:
            break
        let idxText = strings.intToStr(idx)
        if idx == int32(0):
            codegenTraceStep("buildSemanticNodeAppends:i0:after-idx-text")
        let moduleId = "/semantic/runtime"
        let kind = "jsx-tag"
        let value = "node-" + idxText
        if idx == int32(0):
            codegenTraceStep("buildSemanticNodeAppends:i0:after-literals")
        let role = semanticRoleByKind(kind)
        let eventBinding = ""
        let hookSlot = ""
        let routeHint = ""
        if idx == int32(0):
            codegenTraceStep("buildSemanticNodeAppends:i0:after-role")
        let renderBucket = "global"
        let textOut = "<" + value + ">"
        let propId = "r2c-id-" + idxText
        let className = "semantic-node"
        let testId = "r2c-testid-" + idxText
        let hitTestId = propId
        if idx == int32(0):
            codegenTraceStep("buildSemanticNodeAppends:i0:before-append")
        out = out + "    appendSemanticNode(\"sn\", \"/semantic/runtime\", \"semantic\", \"element\", \"node\", \"r2c-id\", \"semantic-node\", \"\", \"r2c-testid\", \"\", \"\", \"\", int32(0), \"global\", \"r2c-id\")\n"
        if idx == int32(0):
            codegenTraceStep("buildSemanticNodeAppends:i0:after-append")
        emitted = emitted + int32(1)
        idx = idx + int32(1)
    codegenTraceStep("buildSemanticNodeAppends:done;emitted=" + strings.intToStr(emitted))
    return out

fn countRenderableSemanticNodes(semanticNodes: str[]): int32 =
    if len(semanticNodes) <= int32(0):
        return int32(0)
    let limit = runtimeSemanticNodeLimit()
    if limit > int32(0) && len(semanticNodes) > limit:
        return limit
    return len(semanticNodes)

fn sanitizeTsvField(value: str): str =
    if len(value) == 0:
        return ""
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < len(value):
        let ch = value[idx]
        if cEq(ch, '\t') || cEq(ch, '\n') || cEq(ch, '\r'):
            out = out + " "
        else:
            out = out + charToStr(ch)
        idx = idx + int32(1)
    return out

fn buildSemanticRenderNodesTsv(semanticNodes: str[]): str =
    var out: str = "node_id\tsource_module\tjsx_path\trole\ttext\tevent_binding\thook_slot\troute_hint\truntime_index\trender_bucket\thit_test_id\n"
    var idx: int32 = int32(0)
    var emitted: int32 = int32(0)
    let limit = runtimeSemanticNodeLimit()
    while idx < len(semanticNodes):
        if limit > int32(0) && emitted >= limit:
            break
        let idxText = strings.intToStr(idx)
        let moduleId = "/semantic/runtime"
        let role = "element"
        let textOut = "<node-" + idxText + ">"
        let eventBinding = ""
        let hookSlot = ""
        let routeHint = ""
        let renderBucket = "global"
        let hitTestId = "r2c-id-" + idxText
        let jsxPath = "semantic:" + idxText
        let nodeId = "sn_" + idxText
        out = out + sanitizeTsvField(nodeId) + "\t" +
            sanitizeTsvField(moduleId) + "\t" +
            sanitizeTsvField(jsxPath) + "\t" +
            sanitizeTsvField(role) + "\t" +
            sanitizeTsvField(textOut) + "\t" +
            sanitizeTsvField(eventBinding) + "\t" +
            sanitizeTsvField(hookSlot) + "\t" +
            sanitizeTsvField(routeHint) + "\t" +
            sanitizeTsvField(idxText) + "\t" +
            sanitizeTsvField(renderBucket) + "\t" +
            sanitizeTsvField(hitTestId) + "\n"
        emitted = emitted + int32(1)
        idx = idx + int32(1)
    return out

fn dashName(text: str): str =
    if len(text) == 0:
        return ""
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < len(text):
        let ch = text[idx]
        if cEq(ch, '_'):
            out = out + "-"
        elif cGe(ch, 'A') && cLe(ch, 'Z'):
            out = out + charToStr(lowerAsciiChar(ch))
        else:
            out = out + charToStr(ch)
        idx = idx + int32(1)
    return out

fn hasPrefix(text: str, prefix: str): bool =
    if len(prefix) == 0:
        return true
    if len(text) < len(prefix):
        return false
    var idx: int32 = int32(0)
    while idx < len(prefix):
        if cNe(text[idx], prefix[idx]):
            return false
        idx = idx + int32(1)
    return true

fn defaultRouteFromStates(states: str[]): str =
    if len(states) <= int32(0):
        return "home_default"
    var idx: int32 = int32(0)
    while idx < len(states):
        if states[idx] == "home_default":
            return states[idx]
        idx = idx + int32(1)
    idx = int32(0)
    while idx < len(states):
        if hasPrefix(states[idx], "home_"):
            return states[idx]
        idx = idx + int32(1)
    idx = int32(0)
    while idx < len(states):
        if states[idx] != "lang_select":
            return states[idx]
        idx = idx + int32(1)
    return states[0]

fn buildKnownRouteCases(states: str[]): str =
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < len(states):
        out = out + "    if strEq(route, \"" + escapeChengString(states[idx]) + "\"):\n"
        out = out + "        return true\n"
        idx = idx + int32(1)
    if len(out) == 0:
        out = out + "    if strEq(route, \"home_default\"):\n"
        out = out + "        return true\n"
    return out

fn buildRouteTitleCases(states: str[]): str =
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < len(states):
        out = out + "    if strEq(route, \"" + escapeChengString(states[idx]) + "\"):\n"
        out = out + "        return \"" + escapeChengString(states[idx]) + "\"\n"
        idx = idx + int32(1)
    if len(out) == 0:
        out = out + "    if strEq(route, \"home_default\"):\n"
        out = out + "        return \"home_default\"\n"
    return out

fn buildSelectorRouteCases(states: str[]): str =
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < len(states):
        let route = states[idx]
        let routeDash = dashName(route)
        if len(routeDash) > 0:
            out = out + "    if strEq(id, \"" + escapeChengString(routeDash) + "\"):\n"
            out = out + "        return \"" + escapeChengString(route) + "\"\n"
            out = out + "    if strEq(id, \"tab-" + escapeChengString(routeDash) + "\"):\n"
            out = out + "        return \"" + escapeChengString(route) + "\"\n"
        idx = idx + int32(1)
    if len(out) == 0:
        out = out + "    if strEq(id, \"home-default\"):\n"
        out = out + "        return \"home_default\"\n"
        out = out + "    if strEq(id, \"tab-home\"):\n"
        out = out + "        return \"home_default\"\n"
    return out

fn buildRuntimeGeneratedSource(projectName: str, strictNoFallback: bool, states: str[], semanticNodes: str[]): str =
    codegenTraceStep("buildRuntimeGeneratedSource:start")
    strictNoFallback
    let projectName = buildProjectName(projectName, "")
    let defaultRoute = defaultRouteFromStates(states)
    let semanticNodeAppends = buildSemanticNodeAppends(semanticNodes)
    codegenTraceStep("buildRuntimeGeneratedSource:after-appends")
    let knownRouteCases = buildKnownRouteCases(states)
    codegenTraceStep("buildRuntimeGeneratedSource:after-known-routes")
    let selectorRouteCases = ""
    codegenTraceStep("buildRuntimeGeneratedSource:after-selector-routes")
    var out: str = ""
    out = out + "import gui/browser/web\n"
    codegenTraceStep("buildRuntimeGeneratedSource:after-import-web")
    out = out + "import gui/browser/r2capp/ime_bridge\n"
    out = out + "import gui/browser/r2capp/utfzh_bridge\n"
    out = out + "import gui/browser/r2capp/utfzh_editor\n\n"
    codegenTraceStep("buildRuntimeGeneratedSource:after-imports")
    out = out + "type SemanticNode = ref\n"
    out = out + "    nodeId: str\n"
    out = out + "    routeHint: str\n\n"
    out = out + "var semanticNodes: SemanticNode[]\n"
    out = out + "var mountedPage: web.BrowserPage = nil\n\n"
    out = out + "fn appendSemanticNode(\n"
    out = out + "    nodeId, sourceModule, jsxPath, role, text, propId, className, styleText, testId, eventBinding, hookSlot, routeHint: str,\n"
    out = out + "    runtimeIndex: int32, renderBucket, hitTestId: str\n"
    out = out + ") =\n"
    out = out + "    sourceModule\n"
    out = out + "    jsxPath\n"
    out = out + "    role\n"
    out = out + "    text\n"
    out = out + "    propId\n"
    out = out + "    className\n"
    out = out + "    styleText\n"
    out = out + "    testId\n"
    out = out + "    eventBinding\n"
    out = out + "    hookSlot\n"
    out = out + "    runtimeIndex\n"
    out = out + "    renderBucket\n"
    out = out + "    hitTestId\n"
    out = out + "    var node: SemanticNode\n"
    out = out + "    new(node)\n"
    out = out + "    node.nodeId = nodeId\n"
    out = out + "    node.routeHint = routeHint\n"
    out = out + "    let idx = len(semanticNodes)\n"
    out = out + "    setLen(semanticNodes, idx + int32(1))\n"
    out = out + "    semanticNodes[idx] = node\n\n"
    out = out + "fn ensureSemanticNodes() =\n"
    out = out + "    if len(semanticNodes) > int32(0):\n"
    out = out + "        return\n"
    out = out + semanticNodeAppends + "\n"
    out = out + "fn isKnownRoute(route: str): bool =\n"
    out = out + knownRouteCases
    out = out + "    return false\n\n"
    out = out + "fn routeFromSelectorId(id: str): str =\n"
    out = out + "    if len(id) == 0:\n"
    out = out + "        return \"\"\n"
    out = out + "    if strEq(id, \"publish-cancel\") || strEq(id, \"publish-close\") || strEq(id, \"publish-dismiss\") || strEq(id, \"cancel-publish\"):\n"
    out = out + "        return \"" + escapeChengString(defaultRoute) + "\"\n"
    out = out + "    if strEq(id, \"publish-selector-cancel\") || strEq(id, \"publish-selector-close\"):\n"
    out = out + "        return \"" + escapeChengString(defaultRoute) + "\"\n"
    out = out + "    if strEq(id, \"tab-home\"):\n"
    out = out + "        return \"home_default\"\n"
    out = out + "    if strEq(id, \"tab-messages\"):\n"
    out = out + "        return \"tab_messages\"\n"
    out = out + "    if strEq(id, \"tab-publish\"):\n"
    out = out + "        return \"publish_selector\"\n"
    out = out + "    if strEq(id, \"tab-nodes\"):\n"
    out = out + "        return \"tab_nodes\"\n"
    out = out + "    if strEq(id, \"tab-profile\"):\n"
    out = out + "        return \"tab_profile\"\n"
    out = out + selectorRouteCases
    out = out + "    return \"\"\n\n"
    out = out + "fn normalizeSelector(targetSelector: str): str =\n"
    out = out + "    if len(targetSelector) <= int32(0):\n"
    out = out + "        return \"\"\n"
    out = out + "    if strEq(targetSelector, \"#\"):\n"
    out = out + "        return \"\"\n"
    out = out + "    if targetSelector[0] == '#':\n"
    out = out + "        return targetSelector[1..<len(targetSelector)]\n"
    out = out + "    return targetSelector\n\n"
    out = out + "fn mountGenerated(page: web.BrowserPage): bool =\n"
    out = out + "    ensureSemanticNodes()\n"
    out = out + "    if page == nil:\n"
    out = out + "        return false\n"
    out = out + "    mountedPage = page\n"
    out = out + "    if len(page.r2cApp) == 0:\n"
    out = out + "        page.r2cApp = \"" + escapeChengString(projectName) + "\"\n"
    out = out + "    if len(page.r2cRoute) == 0:\n"
    out = out + "        page.r2cRoute = \"" + escapeChengString(defaultRoute) + "\"\n"
    out = out + "    if len(page.r2cTab) == 0:\n"
    out = out + "        page.r2cTab = \"home\"\n"
    out = out + "    if len(page.r2cCurrentTab) == 0:\n"
    out = out + "        page.r2cCurrentTab = page.r2cTab\n"
    out = out + "    return true\n\n"
    out = out + "fn dispatchFromPage(page: web.BrowserPage, eventName, targetSelector, payload: str): bool =\n"
    out = out + "    ensureSemanticNodes()\n"
    out = out + "    if page == nil:\n"
    out = out + "        return false\n"
    out = out + "    if len(targetSelector) > 0:\n"
    out = out + "        page.r2cLastTarget = targetSelector\n"
    out = out + "    if len(eventName) > 0:\n"
    out = out + "        page.r2cLastEvent = eventName\n"
    out = out + "    if len(payload) > 0:\n"
    out = out + "        page.r2cLastPayload = payload\n"
    out = out + "    if strEq(eventName, \"route\"):\n"
    out = out + "        var route = normalizeSelector(payload)\n"
    out = out + "        if len(route) <= int32(0):\n"
    out = out + "            route = normalizeSelector(targetSelector)\n"
    out = out + "        if isKnownRoute(route):\n"
    out = out + "            page.r2cCurrentTab = route\n"
    out = out + "            page.r2cRoute = route\n"
    out = out + "        return true\n"
    out = out + "    if strEq(eventName, \"click\"):\n"
    out = out + "        let id = normalizeSelector(targetSelector)\n"
    out = out + "        if strEq(page.r2cCurrentTab, \"publish_selector\"):\n"
    out = out + "            if len(id) == int32(0) || strEq(id, \"r2c-id-0\") || strEq(id, \"root\"):\n"
    out = out + "                page.r2cCurrentTab = \"" + escapeChengString(defaultRoute) + "\"\n"
    out = out + "                page.r2cRoute = \"" + escapeChengString(defaultRoute) + "\"\n"
    out = out + "                return true\n"
    out = out + "        let route = routeFromSelectorId(id)\n"
    out = out + "        if isKnownRoute(route):\n"
    out = out + "            page.r2cCurrentTab = route\n"
    out = out + "            page.r2cRoute = route\n"
    out = out + "        return true\n"
    out = out + "    return true\n\n"
    out = out + "fn drainEffects(limit: int32): int32 =\n"
    out = out + "    if limit < int32(0):\n"
    out = out + "        return int32(0)\n"
    out = out + "    return int32(0)\n\n"
    out = out + "fn resolveTargetAt(page: web.BrowserPage, x, y: float): str =\n"
    out = out + "    ensureSemanticNodes()\n"
    out = out + "    if page == nil:\n"
    out = out + "        return \"#root\"\n"
    out = out + "    let w = float(page.options.viewportWidth)\n"
    out = out + "    let h = float(page.options.viewportHeight)\n"
    out = out + "    if y >= h - 180.0:\n"
    out = out + "        let cell = w / 5.0\n"
    out = out + "        if x < cell:\n"
    out = out + "            return \"#tab-home\"\n"
    out = out + "        if x < cell * 2.0:\n"
    out = out + "            return \"#tab-messages\"\n"
    out = out + "        if x < cell * 3.0:\n"
    out = out + "            return \"#tab-publish\"\n"
    out = out + "        if x < cell * 4.0:\n"
    out = out + "            return \"#tab-nodes\"\n"
    out = out + "        return \"#tab-profile\"\n"
    out = out + "    if strEq(page.r2cCurrentTab, \"publish_selector\"):\n"
    out = out + "        if y > h * 0.75 || y < h * 0.35:\n"
    out = out + "            return \"#publish-cancel\"\n"
    out = out + "        if x > w * 0.2 && x < w * 0.8 && y > h * 0.38 && y < h * 0.52:\n"
    out = out + "            return \"#publish-content\"\n"
    out = out + "        if x > w * 0.2 && x < w * 0.8 && y >= h * 0.52 && y < h * 0.66:\n"
    out = out + "            return \"#publish-product\"\n"
    out = out + "    return \"#root\"\n\n"
    out = out + "# utfzh_bridge.utfZhRoundtripStrict\n"
    out = out + "# ime_bridge.handleImeEvent\n"
    out = out + "# utfzh_editor.handleEditorEvent\n"
    out = out + "# utfzh_editor.renderEditorPanel\n"
    codegenTraceStep("buildRuntimeGeneratedSource:done;out-len=" + strings.intToStr(len(out)))
    return out
