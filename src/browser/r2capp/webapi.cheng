import cheng/gui/browser/engine/storage/store as storageStore
import std/strings

fn safeLen(text: str): int32 =
    if text == nil:
        return int32(0)
    return len(text)

fn cEq(a: char, b: char): bool =
    let va = int32(a)
    let vb = int32(b)
    if va < vb:
        return false
    if va > vb:
        return false
    return true

fn cNe(a: char, b: char): bool =
    return int32(a) != int32(b)

fn cGe(a: char, b: char): bool =
    return int32(a) >= int32(b)

fn cLe(a: char, b: char): bool =
    return int32(a) <= int32(b)

fn lowerAsciiChar(ch: char): char =
    if cGe(ch, 'A') && cLe(ch, 'Z'):
        return char(int32(ch) - int32('A') + int32('a'))
    return ch

fn r2cMatchAt(text, pattern: str, offset: int): bool =
    if offset < 0:
        return false
    if text == nil || pattern == nil:
        return false
    if offset + len(pattern) > len(text):
        return false
    for idx in 0..<len(pattern):
        if cNe(text[offset + idx], pattern[idx]):
            return false
    return true

fn r2cFind(text, pattern: str, start: int): int =
    if len(pattern) == 0:
        return start
    if text == nil:
        return -1
    var startIdx = start
    if startIdx < 0:
        startIdx = 0
    let stopExclusive = len(text) - len(pattern) + 1
    if stopExclusive <= startIdx:
        return -1
    for idx in startIdx..<stopExclusive:
        if r2cMatchAt(text, pattern, idx):
            return idx
    return -1

fn matchAtLower(text, pattern: str, offset: int): bool =
    if offset < 0:
        return false
    if text == nil || pattern == nil:
        return false
    if offset + len(pattern) > safeLen(text):
        return false
    for idx in 0..<len(pattern):
        if cNe(lowerAsciiChar(text[offset + idx]), lowerAsciiChar(pattern[idx])):
            return false
    return true

fn findLower(text, pattern: str, start: int): int =
    if len(pattern) == 0:
        return start
    var startIdx = start
    if startIdx < 0:
        startIdx = 0
    let stopExclusive = safeLen(text) - len(pattern) + 1
    if stopExclusive <= startIdx:
        return -1
    for idx in startIdx..<stopExclusive:
        if matchAtLower(text, pattern, idx):
            return idx
    return -1

fn findChar(text: str, ch: char, start: int): int =
    if text == nil:
        return -1
    var startIdx = start
    if startIdx < 0:
        startIdx = 0
    for idx in startIdx..<safeLen(text):
        if cEq(text[idx], ch):
            return idx
    return -1

fn skipSpaces(text: str, idx0: int): int =
    if text == nil:
        return idx0
    var idx = idx0
    while idx < safeLen(text):
        let ch = text[idx]
        if cEq(ch, ' ') || cEq(ch, '\n') || cEq(ch, '\r') || cEq(ch, '\t'):
            idx = idx + 1
        else:
            break
    return idx

fn parseInt32(text: str, idx0: int): tuple[value: int32, next: int, ok: bool] =
    if text == nil:
        return (value: int32(0), next: idx0, ok: false)
    var idx = idx0
    var value: int32 = int32(0)
    var saw = false
    while idx < safeLen(text):
        let ch = text[idx]
        if cGe(ch, '0') && cLe(ch, '9'):
            saw = true
            value = value * int32(10) + int32(int32(ch) - int32('0'))
            idx = idx + 1
        else:
            break
    return (value: value, next: idx, ok: saw)

# Minimal matchMedia support for AOT runtimes.
# Supports:
# - "(min-width: Npx)"
# - "(max-width: Npx)"
fn matchMedia(viewportWidth: float, query: str): bool =
    if len(query) == 0:
        return false
    # Prefer the simplest parsing possible for stability.
    let idxMin = r2cFind(query, "min-width", 0)
    let idxMax = r2cFind(query, "max-width", 0)
    var isMin = false
    var idx = -1
    if idxMin >= 0:
        isMin = true
        idx = idxMin + len("min-width")
    elif idxMax >= 0:
        isMin = false
        idx = idxMax + len("max-width")
    else:
        return false

    let colon = findChar(query, ':', idx)
    if colon < 0:
        return false
    idx = skipSpaces(query, colon + 1)
    let parsed = parseInt32(query, idx)
    if ! parsed.ok:
        return false
    let vw = int32(viewportWidth)
    if isMin:
        return vw >= parsed.value
    return vw <= parsed.value

fn debugMatchMedia(viewportWidth: float, query: str): str =
    var out: str = ""
    let vwInt = int(viewportWidth)
    let qLen = len(query)
    out = out + "vw=" + strings.intToStr(vwInt)
    out = out + " qlen=" + strings.intToStr(qLen)
    let idxMin = r2cFind(query, "min-width", 0)
    let idxMax = r2cFind(query, "max-width", 0)
    out = out + " idxMin=" + strings.intToStr(idxMin)
    out = out + " idxMax=" + strings.intToStr(idxMax)
    var idx = -1
    var isMin = false
    if idxMin >= 0:
        isMin = true
        idx = idxMin + len("min-width")
    elif idxMax >= 0:
        isMin = false
        idx = idxMax + len("max-width")
    else:
        out = out + " no-kind"
        return out
    var isMinText: str = "false"
    if isMin:
        isMinText = "true"
    out = out + " isMin=" + isMinText
    let colon = findChar(query, ':', idx)
    out = out + " colon=" + strings.intToStr(colon)
    if colon < 0:
        return out
    idx = skipSpaces(query, colon + 1)
    out = out + " numAt=" + strings.intToStr(idx)
    let parsed = parseInt32(query, idx)
    var okText: str = "false"
    if parsed.ok:
        okText = "true"
    out = out + " ok=" + okText
    out = out + " px=" + strings.intToStr(parsed.value)
    if ! parsed.ok:
        return out
    let vw = int32(viewportWidth)
    var result = false
    if isMin:
        result = vw >= parsed.value
    else:
        result = vw <= parsed.value
    var resText: str = "false"
    if result:
        resText = "true"
    out = out + " res=" + resText
    return out

fn localStorageGetItem(store: storageStore.StorageStore, key: str): str =
    return storageStore.getValue(store, key)

fn localStorageSetItem(store: storageStore.StorageStore, key, value: str) =
    storageStore.setValue(store, key, value)

fn localStorageRemoveItem(store: storageStore.StorageStore, key: str) =
    storageStore.setValue(store, key, "")

fn cookieGet(store: storageStore.StorageStore): str =
    return storageStore.getValue(store, "cookie")

fn cookieSet(store: storageStore.StorageStore, value: str) =
    storageStore.setValue(store, "cookie", value)

fn clipboardReadText(store: storageStore.StorageStore): str =
    return storageStore.getValue(store, "clipboard")

fn clipboardWriteText(store: storageStore.StorageStore, text: str) =
    storageStore.setValue(store, "clipboard", text)

fn geoGetCurrentPosition(store: storageStore.StorageStore): str =
    return storageStore.getValue(store, "geolocation")

fn geoSetCurrentPosition(store: storageStore.StorageStore, value: str) =
    storageStore.setValue(store, "geolocation", value)

fn base64Encode(text: str): str =
    if safeLen(text) == int32(0):
        return ""
    let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < safeLen(text):
        let b0 = int32(text[idx]) & int32(255)
        idx = idx + int32(1)
        var b1: int32 = int32(-1)
        var b2: int32 = int32(-1)
        if idx < safeLen(text):
            b1 = int32(text[idx]) & int32(255)
            idx = idx + int32(1)
        if idx < safeLen(text):
            b2 = int32(text[idx]) & int32(255)
            idx = idx + int32(1)

        let i0 = (b0 >> int32(2)) & int32(63)
        let i1 = ((b0 & int32(3)) << int32(4)) | (if b1 >= int32(0): (b1 >> int32(4)) & int32(15) else: int32(0))
        var i2: int32 = int32(64)
        var i3: int32 = int32(64)
        if b1 >= int32(0):
            i2 = ((b1 & int32(15)) << int32(2)) | (if b2 >= int32(0): (b2 >> int32(6)) & int32(3) else: int32(0))
        if b2 >= int32(0):
            i3 = b2 & int32(63)

        out = out + charToStr(alphabet[i0])
        out = out + charToStr(alphabet[i1])
        if i2 == int32(64):
            out = out + "="
        else:
            out = out + charToStr(alphabet[i2])
        if i3 == int32(64):
            out = out + "="
        else:
            out = out + charToStr(alphabet[i3])
    return out

fn fileReaderReadTextAsDataUrl(text: str, mime: str): str =
    var m = mime
    if safeLen(m) == int32(0):
        m = "text/plain"
    return "data:" + m + ";base64," + base64Encode(text)

type
    TimerKind = enum
        tkTimeout
        tkInterval

    TimerState = ref
        nowMs: int64
        nextId: int64
        ids: int64[]
        kinds: TimerKind[]
        dueMs: int64[]
        intervalMs: int32[]
        active: bool[]

fn newTimerState(): TimerState =
    var state: TimerState
    new(state)
    state.nowMs = int64(0)
    state.nextId = int64(1)
    setLen[int64](&state.ids, 0)
    setLen[TimerKind](&state.kinds, 0)
    setLen[int64](&state.dueMs, 0)
    setLen[int32](&state.intervalMs, 0)
    setLen[bool](&state.active, 0)
    return state

fn timerAppend(state: TimerState, kind: TimerKind, due: int64, interval: int32): int64 =
    if state == nil:
        return int64(0)
    let id = state.nextId
    state.nextId = state.nextId + int64(1)
    let idx = len(state.ids)
    setLen[int64](&state.ids, idx + 1)
    setLen[TimerKind](&state.kinds, idx + 1)
    setLen[int64](&state.dueMs, idx + 1)
    setLen[int32](&state.intervalMs, idx + 1)
    setLen[bool](&state.active, idx + 1)
    state.ids[idx] = id
    state.kinds[idx] = kind
    state.dueMs[idx] = due
    state.intervalMs[idx] = interval
    state.active[idx] = true
    return id

fn setTimeout(state: TimerState, delayMs: int32): int64 =
    if state == nil:
        return int64(0)
    let due = state.nowMs + int64(max(int32(0), delayMs))
    return timerAppend(state, tkTimeout, due, int32(0))

fn setInterval(state: TimerState, intervalMs: int32): int64 =
    if state == nil:
        return int64(0)
    let interval = max(int32(1), intervalMs)
    let due = state.nowMs + int64(interval)
    return timerAppend(state, tkInterval, due, interval)

fn clearTimer(state: TimerState, timerId: int64) =
    if state == nil || timerId == int64(0):
        return
    for idx in 0..<len(state.ids):
        if state.ids[idx] == timerId:
            state.active[idx] = false
            return

fn advanceTimers(state: TimerState, deltaMs: int32): int64[] =
    var fired: int64[]
    setLen[int64](&fired, 0)
    if state == nil:
        return fired
    state.nowMs = state.nowMs + int64(max(int32(0), deltaMs))
    for idx in 0..<len(state.ids):
        if state.active[idx] && state.dueMs[idx] <= state.nowMs:
            let outIdx = len(fired)
            setLen[int64](&fired, outIdx + 1)
            fired[outIdx] = state.ids[idx]
            if state.kinds[idx] == tkInterval:
                state.dueMs[idx] = state.dueMs[idx] + int64(state.intervalMs[idx])
            else:
                state.active[idx] = false
    return fired

fn sessionStorageKey(key: str): str =
    return "session::" + key

fn sessionStorageGetItem(store: storageStore.StorageStore, key: str): str =
    return storageStore.getValue(store, sessionStorageKey(key))

fn sessionStorageSetItem(store: storageStore.StorageStore, key, value: str) =
    storageStore.setValue(store, sessionStorageKey(key), value)

fn sessionStorageRemoveItem(store: storageStore.StorageStore, key: str) =
    storageStore.setValue(store, sessionStorageKey(key), "")

type
    MatchMediaState = ref
        queries: str[]
        matches: bool[]
        changedCount: int32

    ResizeObserverState = ref
        targets: str[]
        widths: int32[]
        heights: int32[]
        notifyCount: int32

    FullscreenState = ref
        active: bool
        targetId: str

fn newMatchMediaState(): MatchMediaState =
    var state: MatchMediaState
    new(state)
    setLen[str](&state.queries, 0)
    setLen[bool](&state.matches, 0)
    state.changedCount = int32(0)
    return state

fn matchMediaSubscribe(state: MatchMediaState, query: str, initial: bool): int32 =
    if state == nil:
        return int32(-1)
    let idx = len(state.queries)
    setLen[str](&state.queries, idx + 1)
    setLen[bool](&state.matches, idx + 1)
    state.queries[idx] = query
    state.matches[idx] = initial
    return int32(idx)

fn matchMediaNotify(state: MatchMediaState, viewportWidth: float): int32 =
    if state == nil:
        return int32(0)
    var changed: int32 = int32(0)
    for idx in 0..<len(state.queries):
        let next = matchMedia(viewportWidth, state.queries[idx])
        if state.matches[idx] != next:
            state.matches[idx] = next
            changed = changed + int32(1)
    state.changedCount = state.changedCount + changed
    return changed

fn newResizeObserverState(): ResizeObserverState =
    var state: ResizeObserverState
    new(state)
    setLen[str](&state.targets, 0)
    setLen[int32](&state.widths, 0)
    setLen[int32](&state.heights, 0)
    state.notifyCount = int32(0)
    return state

fn resizeObserve(state: ResizeObserverState, targetId: str, width, height: int32) =
    if state == nil:
        return
    for idx in 0..<len(state.targets):
        if state.targets[idx] == targetId:
            state.widths[idx] = width
            state.heights[idx] = height
            return
    let pos = len(state.targets)
    setLen[str](&state.targets, pos + 1)
    setLen[int32](&state.widths, pos + 1)
    setLen[int32](&state.heights, pos + 1)
    state.targets[pos] = targetId
    state.widths[pos] = width
    state.heights[pos] = height

fn resizeNotify(state: ResizeObserverState, targetId: str, width, height: int32): bool =
    if state == nil:
        return false
    for idx in 0..<len(state.targets):
        if state.targets[idx] == targetId:
            if state.widths[idx] != width || state.heights[idx] != height:
                state.widths[idx] = width
                state.heights[idx] = height
                state.notifyCount = state.notifyCount + int32(1)
                return true
            return false
    resizeObserve(state, targetId, width, height)
    state.notifyCount = state.notifyCount + int32(1)
    return true

fn newFullscreenState(): FullscreenState =
    var state: FullscreenState
    new(state)
    state.active = false
    state.targetId = ""
    return state

fn fullscreenRequest(state: FullscreenState, targetId: str): bool =
    if state == nil:
        return false
    state.active = true
    state.targetId = targetId
    return true

fn fullscreenExit(state: FullscreenState): bool =
    if state == nil:
        return false
    state.active = false
    state.targetId = ""
    return true

fn fullscreenIsActive(state: FullscreenState): bool =
    if state == nil:
        return false
    return state.active

fn fileReaderReadAsText(text: str): str =
    return text
