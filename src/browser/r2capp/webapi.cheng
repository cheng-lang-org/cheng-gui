import gui/browser/engine/storage/store as storageStore
import std/strings

fn safeLen(text: str): int32 =
    if text == nil:
        return int32(0)
    return len(text)

fn cEq(a: char, b: char): bool =
    let va = int32(a)
    let vb = int32(b)
    if va < vb:
        return false
    if va > vb:
        return false
    return true

fn cNe(a: char, b: char): bool =
    return int32(a) != int32(b)

fn cGe(a: char, b: char): bool =
    return int32(a) >= int32(b)

fn cLe(a: char, b: char): bool =
    return int32(a) <= int32(b)

fn lowerAsciiChar(ch: char): char =
    if cGe(ch, 'A') && cLe(ch, 'Z'):
        return char(int32(ch) - int32('A') + int32('a'))
    return ch

fn r2cMatchAt(text, pattern: str, offset: int): bool =
    if offset < 0:
        return false
    if text == nil || pattern == nil:
        return false
    if offset + len(pattern) > len(text):
        return false
    for idx in 0..<len(pattern):
        if cNe(text[offset + idx], pattern[idx]):
            return false
    return true

fn r2cFind(text, pattern: str, start: int): int =
    if len(pattern) == 0:
        return start
    if text == nil:
        return -1
    var startIdx = start
    if startIdx < 0:
        startIdx = 0
    let stopExclusive = len(text) - len(pattern) + 1
    if stopExclusive <= startIdx:
        return -1
    for idx in startIdx..<stopExclusive:
        if r2cMatchAt(text, pattern, idx):
            return idx
    return -1

fn matchAtLower(text, pattern: str, offset: int): bool =
    if offset < 0:
        return false
    if text == nil || pattern == nil:
        return false
    if offset + len(pattern) > safeLen(text):
        return false
    for idx in 0..<len(pattern):
        if cNe(lowerAsciiChar(text[offset + idx]), lowerAsciiChar(pattern[idx])):
            return false
    return true

fn findLower(text, pattern: str, start: int): int =
    if len(pattern) == 0:
        return start
    var startIdx = start
    if startIdx < 0:
        startIdx = 0
    let stopExclusive = safeLen(text) - len(pattern) + 1
    if stopExclusive <= startIdx:
        return -1
    for idx in startIdx..<stopExclusive:
        if matchAtLower(text, pattern, idx):
            return idx
    return -1

fn findChar(text: str, ch: char, start: int): int =
    if text == nil:
        return -1
    var startIdx = start
    if startIdx < 0:
        startIdx = 0
    for idx in startIdx..<safeLen(text):
        if cEq(text[idx], ch):
            return idx
    return -1

fn skipSpaces(text: str, idx0: int): int =
    if text == nil:
        return idx0
    var idx = idx0
    while idx < safeLen(text):
        let ch = text[idx]
        if cEq(ch, ' ') || cEq(ch, '\n') || cEq(ch, '\r') || cEq(ch, '\t'):
            idx = idx + 1
        else:
            break
    return idx

fn parseInt32(text: str, idx0: int): tuple[value: int32, next: int, ok: bool] =
    if text == nil:
        return (value: int32(0), next: idx0, ok: false)
    var idx = idx0
    var value: int32 = int32(0)
    var saw = false
    while idx < safeLen(text):
        let ch = text[idx]
        if cGe(ch, '0') && cLe(ch, '9'):
            saw = true
            value = value * int32(10) + int32(int32(ch) - int32('0'))
            idx = idx + 1
        else:
            break
    return (value: value, next: idx, ok: saw)

# Minimal matchMedia support for AOT runtimes.
# Supports:
# - "(min-width: Npx)"
# - "(max-width: Npx)"
fn matchMedia(viewportWidth: float, query: str): bool =
    if len(query) == 0:
        return false
    # Prefer the simplest parsing possible for stability.
    let idxMin = r2cFind(query, "min-width", 0)
    let idxMax = r2cFind(query, "max-width", 0)
    var isMin = false
    var idx = -1
    if idxMin >= 0:
        isMin = true
        idx = idxMin + len("min-width")
    elif idxMax >= 0:
        isMin = false
        idx = idxMax + len("max-width")
    else:
        return false

    let colon = findChar(query, ':', idx)
    if colon < 0:
        return false
    idx = skipSpaces(query, colon + 1)
    let parsed = parseInt32(query, idx)
    if ! parsed.ok:
        return false
    let vw = int32(viewportWidth)
    if isMin:
        return vw >= parsed.value
    return vw <= parsed.value

fn debugMatchMedia(viewportWidth: float, query: str): str =
    var out: str = ""
    let vwInt = int(viewportWidth)
    let qLen = len(query)
    out = out + "vw=" + strings.intToStr(vwInt)
    out = out + " qlen=" + strings.intToStr(qLen)
    let idxMin = r2cFind(query, "min-width", 0)
    let idxMax = r2cFind(query, "max-width", 0)
    out = out + " idxMin=" + strings.intToStr(idxMin)
    out = out + " idxMax=" + strings.intToStr(idxMax)
    var idx = -1
    var isMin = false
    if idxMin >= 0:
        isMin = true
        idx = idxMin + len("min-width")
    elif idxMax >= 0:
        isMin = false
        idx = idxMax + len("max-width")
    else:
        out = out + " no-kind"
        return out
    var isMinText: str = "false"
    if isMin:
        isMinText = "true"
    out = out + " isMin=" + isMinText
    let colon = findChar(query, ':', idx)
    out = out + " colon=" + strings.intToStr(colon)
    if colon < 0:
        return out
    idx = skipSpaces(query, colon + 1)
    out = out + " numAt=" + strings.intToStr(idx)
    let parsed = parseInt32(query, idx)
    var okText: str = "false"
    if parsed.ok:
        okText = "true"
    out = out + " ok=" + okText
    out = out + " px=" + strings.intToStr(parsed.value)
    if ! parsed.ok:
        return out
    let vw = int32(viewportWidth)
    var result = false
    if isMin:
        result = vw >= parsed.value
    else:
        result = vw <= parsed.value
    var resText: str = "false"
    if result:
        resText = "true"
    out = out + " res=" + resText
    return out

fn localStorageGetItem(store: storageStore.StorageStore, key: str): str =
    return storageStore.getValue(store, key)

fn localStorageSetItem(store: storageStore.StorageStore, key, value: str) =
    storageStore.setValue(store, key, value)

fn localStorageRemoveItem(store: storageStore.StorageStore, key: str) =
    storageStore.setValue(store, key, "")

fn cookieGet(store: storageStore.StorageStore): str =
    return storageStore.getValue(store, "cookie")

fn cookieSet(store: storageStore.StorageStore, value: str) =
    storageStore.setValue(store, "cookie", value)

fn clipboardReadText(store: storageStore.StorageStore): str =
    return storageStore.getValue(store, "clipboard")

fn clipboardWriteText(store: storageStore.StorageStore, text: str) =
    storageStore.setValue(store, "clipboard", text)

fn geoGetCurrentPosition(store: storageStore.StorageStore): str =
    return storageStore.getValue(store, "geolocation")

fn geoSetCurrentPosition(store: storageStore.StorageStore, value: str) =
    storageStore.setValue(store, "geolocation", value)

fn base64Encode(text: str): str =
    if safeLen(text) == int32(0):
        return ""
    let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var out: str = ""
    var idx: int32 = int32(0)
    while idx < safeLen(text):
        let b0 = int32(text[idx]) & int32(255)
        idx = idx + int32(1)
        var b1: int32 = int32(-1)
        var b2: int32 = int32(-1)
        if idx < safeLen(text):
            b1 = int32(text[idx]) & int32(255)
            idx = idx + int32(1)
        if idx < safeLen(text):
            b2 = int32(text[idx]) & int32(255)
            idx = idx + int32(1)

        let i0 = (b0 >> int32(2)) & int32(63)
        let i1 = ((b0 & int32(3)) << int32(4)) | (if b1 >= int32(0): (b1 >> int32(4)) & int32(15) else: int32(0))
        var i2: int32 = int32(64)
        var i3: int32 = int32(64)
        if b1 >= int32(0):
            i2 = ((b1 & int32(15)) << int32(2)) | (if b2 >= int32(0): (b2 >> int32(6)) & int32(3) else: int32(0))
        if b2 >= int32(0):
            i3 = b2 & int32(63)

        out = out + charToStr(alphabet[i0])
        out = out + charToStr(alphabet[i1])
        if i2 == int32(64):
            out = out + "="
        else:
            out = out + charToStr(alphabet[i2])
        if i3 == int32(64):
            out = out + "="
        else:
            out = out + charToStr(alphabet[i3])
    return out

fn fileReaderReadTextAsDataUrl(text: str, mime: str): str =
    var m = mime
    if safeLen(m) == int32(0):
        m = "text/plain"
    return "data:" + m + ";base64," + base64Encode(text)

type
    TimerKind = enum
        tkTimeout
        tkInterval

    TimerState = ref
        nowMs: int64
        nextId: int64
        ids: int64[]
        kinds: TimerKind[]
        dueMs: int64[]
        intervalMs: int32[]
        active: bool[]

fn newTimerState(): TimerState =
    var state: TimerState
    new(state)
    state.nowMs = int64(0)
    state.nextId = int64(1)
    setLen[int64](&state.ids, 0)
    setLen[TimerKind](&state.kinds, 0)
    setLen[int64](&state.dueMs, 0)
    setLen[int32](&state.intervalMs, 0)
    setLen[bool](&state.active, 0)
    return state

fn timerAppend(state: TimerState, kind: TimerKind, due: int64, interval: int32): int64 =
    if state == nil:
        return int64(0)
    let id = state.nextId
    state.nextId = state.nextId + int64(1)
    let idx = len(state.ids)
    setLen[int64](&state.ids, idx + 1)
    setLen[TimerKind](&state.kinds, idx + 1)
    setLen[int64](&state.dueMs, idx + 1)
    setLen[int32](&state.intervalMs, idx + 1)
    setLen[bool](&state.active, idx + 1)
    state.ids[idx] = id
    state.kinds[idx] = kind
    state.dueMs[idx] = due
    state.intervalMs[idx] = interval
    state.active[idx] = true
    return id

fn setTimeout(state: TimerState, delayMs: int32): int64 =
    if state == nil:
        return int64(0)
    let due = state.nowMs + int64(max(int32(0), delayMs))
    return timerAppend(state, tkTimeout, due, int32(0))

fn setInterval(state: TimerState, intervalMs: int32): int64 =
    if state == nil:
        return int64(0)
    let interval = max(int32(1), intervalMs)
    let due = state.nowMs + int64(interval)
    return timerAppend(state, tkInterval, due, interval)

fn clearTimer(state: TimerState, timerId: int64) =
    if state == nil || timerId == int64(0):
        return
    for idx in 0..<len(state.ids):
        if state.ids[idx] == timerId:
            state.active[idx] = false
            return

fn advanceTimers(state: TimerState, deltaMs: int32): int64[] =
    var fired: int64[]
    setLen[int64](&fired, 0)
    if state == nil:
        return fired
    state.nowMs = state.nowMs + int64(max(int32(0), deltaMs))
    for idx in 0..<len(state.ids):
        if state.active[idx] && state.dueMs[idx] <= state.nowMs:
            let outIdx = len(fired)
            setLen[int64](&fired, outIdx + 1)
            fired[outIdx] = state.ids[idx]
            if state.kinds[idx] == tkInterval:
                state.dueMs[idx] = state.dueMs[idx] + int64(state.intervalMs[idx])
            else:
                state.active[idx] = false
    return fired

fn sessionStorageKey(key: str): str =
    return "session::" + key

fn sessionStorageGetItem(store: storageStore.StorageStore, key: str): str =
    return storageStore.getValue(store, sessionStorageKey(key))

fn sessionStorageSetItem(store: storageStore.StorageStore, key, value: str) =
    storageStore.setValue(store, sessionStorageKey(key), value)

fn sessionStorageRemoveItem(store: storageStore.StorageStore, key: str) =
    storageStore.setValue(store, sessionStorageKey(key), "")

type
    MatchMediaState = ref
        queries: str[]
        matches: bool[]
        changedCount: int32

    ResizeObserverState = ref
        targets: str[]
        widths: int32[]
        heights: int32[]
        notifyCount: int32

    FullscreenState = ref
        active: bool
        targetId: str

fn newMatchMediaState(): MatchMediaState =
    var state: MatchMediaState
    new(state)
    setLen[str](&state.queries, 0)
    setLen[bool](&state.matches, 0)
    state.changedCount = int32(0)
    return state

fn matchMediaSubscribe(state: MatchMediaState, query: str, initial: bool): int32 =
    if state == nil:
        return int32(-1)
    let idx = len(state.queries)
    setLen[str](&state.queries, idx + 1)
    setLen[bool](&state.matches, idx + 1)
    state.queries[idx] = query
    state.matches[idx] = initial
    return int32(idx)

fn matchMediaNotify(state: MatchMediaState, viewportWidth: float): int32 =
    if state == nil:
        return int32(0)
    var changed: int32 = int32(0)
    for idx in 0..<len(state.queries):
        let next = matchMedia(viewportWidth, state.queries[idx])
        if state.matches[idx] != next:
            state.matches[idx] = next
            changed = changed + int32(1)
    state.changedCount = state.changedCount + changed
    return changed

fn newResizeObserverState(): ResizeObserverState =
    var state: ResizeObserverState
    new(state)
    setLen[str](&state.targets, 0)
    setLen[int32](&state.widths, 0)
    setLen[int32](&state.heights, 0)
    state.notifyCount = int32(0)
    return state

fn resizeObserve(state: ResizeObserverState, targetId: str, width, height: int32) =
    if state == nil:
        return
    for idx in 0..<len(state.targets):
        if state.targets[idx] == targetId:
            state.widths[idx] = width
            state.heights[idx] = height
            return
    let pos = len(state.targets)
    setLen[str](&state.targets, pos + 1)
    setLen[int32](&state.widths, pos + 1)
    setLen[int32](&state.heights, pos + 1)
    state.targets[pos] = targetId
    state.widths[pos] = width
    state.heights[pos] = height

fn resizeNotify(state: ResizeObserverState, targetId: str, width, height: int32): bool =
    if state == nil:
        return false
    for idx in 0..<len(state.targets):
        if state.targets[idx] == targetId:
            if state.widths[idx] != width || state.heights[idx] != height:
                state.widths[idx] = width
                state.heights[idx] = height
                state.notifyCount = state.notifyCount + int32(1)
                return true
            return false
    resizeObserve(state, targetId, width, height)
    state.notifyCount = state.notifyCount + int32(1)
    return true

fn newFullscreenState(): FullscreenState =
    var state: FullscreenState
    new(state)
    state.active = false
    state.targetId = ""
    return state

fn fullscreenRequest(state: FullscreenState, targetId: str): bool =
    if state == nil:
        return false
    state.active = true
    state.targetId = targetId
    return true

fn fullscreenExit(state: FullscreenState): bool =
    if state == nil:
        return false
    state.active = false
    state.targetId = ""
    return true

fn fullscreenIsActive(state: FullscreenState): bool =
    if state == nil:
        return false
    return state.active

fn fileReaderReadAsText(text: str): str =
    return text

type
    SideEffectItem = ref
        id: int64
        kind: str
        opcode: str
        payload: str
        idempotencyKey: str
        timeoutMs: int32
        canceled: bool

    SideEffectBridge = ref
        nextId: int64
        queue: SideEffectItem[]
        results: str[]
        completedIds: int64[]
        completedPayloads: str[]

fn newSideEffectBridge(): SideEffectBridge =
    var bridge: SideEffectBridge
    new(bridge)
    bridge.nextId = int64(1)
    setLen[SideEffectItem](&bridge.queue, 0)
    setLen[str](&bridge.results, 0)
    setLen[int64](&bridge.completedIds, 0)
    setLen[str](&bridge.completedPayloads, 0)
    return bridge

fn sideEffectPushEnvelope(
    bridge: SideEffectBridge,
    kind,
    opcode,
    payload,
    idempotencyKey: str,
    timeoutMs: int32
): int64 =
    if bridge == nil:
        return int64(0)
    var item: SideEffectItem
    new(item)
    item.id = bridge.nextId
    bridge.nextId = bridge.nextId + int64(1)
    item.kind = kind
    item.opcode = opcode
    item.payload = payload
    item.idempotencyKey = idempotencyKey
    item.timeoutMs = timeoutMs
    item.canceled = false
    let idx = len(bridge.queue)
    setLen[SideEffectItem](&bridge.queue, idx + 1)
    bridge.queue[idx] = item
    return item.id

fn sideEffectPush(bridge: SideEffectBridge, kind, payload: str): int64 =
    return sideEffectPushEnvelope(bridge, kind, kind, payload, "", int32(0))

fn sideEffectRequestStorage(bridge: SideEffectBridge, op, key, value: str): int64 =
    return sideEffectPushEnvelope(
        bridge,
        "storage",
        "storage." + op,
        "op=" + op + ";key=" + key + ";value=" + value,
        "storage:" + op + ":" + key,
        int32(0)
    )

fn sideEffectRequestTimer(bridge: SideEffectBridge, op: str, id: int64, ms: int32): int64 =
    return sideEffectPushEnvelope(
        bridge,
        "timer",
        "timer." + op,
        "op=" + op + ";id=" + $id + ";ms=" + $ms,
        "timer:" + op + ":" + $id,
        ms
    )

fn sideEffectRequestClipboard(bridge: SideEffectBridge, op, text: str): int64 =
    return sideEffectPushEnvelope(
        bridge,
        "clipboard",
        "clipboard." + op,
        "op=" + op + ";text=" + text,
        "clipboard:" + op,
        int32(0)
    )

fn sideEffectRequestGeolocation(bridge: SideEffectBridge, op: str): int64 =
    return sideEffectPushEnvelope(
        bridge,
        "geolocation",
        "geolocation." + op,
        "op=" + op,
        "geo:" + op,
        int32(10000)
    )

fn sideEffectRequestFile(bridge: SideEffectBridge, op, path, content: str): int64 =
    return sideEffectPushEnvelope(
        bridge,
        "file",
        "file." + op,
        "op=" + op + ";path=" + path + ";content=" + content,
        "file:" + op + ":" + path,
        int32(0)
    )

fn sideEffectRequestCrypto(bridge: SideEffectBridge, op, algo, text: str): int64 =
    return sideEffectPushEnvelope(
        bridge,
        "crypto",
        "crypto." + op,
        "op=" + op + ";algo=" + algo + ";text=" + text,
        "crypto:" + op + ":" + algo,
        int32(10000)
    )

fn sideEffectRequestNetwork(bridge: SideEffectBridge, method, url, body: str): int64 =
    return sideEffectPushEnvelope(
        bridge,
        "network",
        "network.request",
        "method=" + method + ";url=" + url + ";body=" + body,
        "network:" + method + ":" + url,
        int32(30000)
    )

fn sideEffectRequestMedia(bridge: SideEffectBridge, op, mediaType, arg: str): int64 =
    return sideEffectPushEnvelope(
        bridge,
        "media",
        "media." + op,
        "op=" + op + ";type=" + mediaType + ";arg=" + arg,
        "media:" + op + ":" + mediaType,
        int32(0)
    )

fn sideEffectRequestCancel(bridge: SideEffectBridge, requestId: int64): bool =
    if bridge == nil || requestId <= int64(0):
        return false
    for idx in 0..<len(bridge.queue):
        let item = bridge.queue[idx]
        if item != nil && item.id == requestId && ! item.canceled:
            item.canceled = true
            sideEffectPushResultById(bridge, requestId, "canceled=true")
            return true
    return false

fn sideEffectPendingCount(bridge: SideEffectBridge): int32 =
    if bridge == nil:
        return int32(0)
    var count: int32 = int32(0)
    for idx in 0..<len(bridge.queue):
        let item = bridge.queue[idx]
        if item != nil && ! item.canceled:
            count = count + int32(1)
    return count

fn sideEffectPull(bridge: SideEffectBridge): str =
    if bridge == nil:
        return ""
    while len(bridge.queue) > 0:
        let head = bridge.queue[0]
        var next: SideEffectItem[]
        setLen[SideEffectItem](&next, 0)
        for idx in 1..<len(bridge.queue):
            let pos = len(next)
            setLen[SideEffectItem](&next, pos + 1)
            next[pos] = bridge.queue[idx]
        bridge.queue = next
        if head == nil || head.canceled:
            continue
        return (
            "id=" + $head.id +
            ";kind=" + head.kind +
            ";opcode=" + head.opcode +
            ";timeout_ms=" + $head.timeoutMs +
            ";idempotency_key=" + head.idempotencyKey +
            ";payload=" + head.payload
        )
    return ""

fn sideEffectPushResultById(bridge: SideEffectBridge, requestId: int64, payload: str): bool =
    if bridge == nil || requestId <= int64(0):
        return false
    let idx = len(bridge.completedIds)
    setLen[int64](&bridge.completedIds, idx + 1)
    setLen[str](&bridge.completedPayloads, idx + 1)
    bridge.completedIds[idx] = requestId
    bridge.completedPayloads[idx] = payload
    let outIdx = len(bridge.results)
    setLen[str](&bridge.results, outIdx + 1)
    bridge.results[outIdx] = "id=" + $requestId + ";payload=" + payload
    return true

fn sideEffectPushResult(bridge: SideEffectBridge, resultEnvelope: str): bool =
    if bridge == nil:
        return false
    let idx = len(bridge.results)
    setLen[str](&bridge.results, idx + 1)
    bridge.results[idx] = resultEnvelope
    return true

fn sideEffectDrainResults(bridge: SideEffectBridge): str[] =
    var out: str[]
    setLen[str](&out, 0)
    if bridge == nil:
        return out
    out = bridge.results
    setLen[str](&bridge.results, 0)
    return out
