import std/os
import cheng/gui/platform/types_v1
import cheng/gui/platform/native_sys_impl as sysplat
import cheng/gui/render/drawlist_ir as drawir
import cheng/gui/render/text_bitmap
import cheng/gui/render/text_native

fn envIs(name: str, expected: str): bool =
    return os.getEnv(name) == expected

fn strictRuntimeEnabled(): bool =
    return envIs("CHENG_R2C_STRICT_RUNTIME", "1")

fn nativeCjkDisabled(): bool =
    return envIs("CHENG_R2C_DISABLE_NATIVE_CJK_TEXT", "1")

type
    PixelBuffer =
        ptr: uint32*
        width: int
        height: int
        strideBytes: int

fn clampInt(value, lower, upper: int): int =
    if value < lower:
        return lower
    if value > upper:
        return upper
    return value

fn maxInt(a, b: int): int =
    if a >= b:
        return a
    return b

fn minInt(a, b: int): int =
    if a <= b:
        return a
    return b

fn minFloat(a, b: float): float =
    if a <= b:
        return a
    return b

fn absInt(value: int): int =
    if value < 0:
        return -value
    return value

fn absFloat(value: float): float =
    if value < 0.0:
        return -value
    return value

fn signInt(value: int): int =
    if value < 0:
        return -1
    if value > 0:
        return 1
    return 0

fn resolvePixelSize(info: SurfaceFrameInfo): GuiSize =
    var size = info.pixelSize
    if ! (size.width >= 16.0) || ! (size.height >= 16.0):
        size = info.logicalSize
    if ! (size.width >= 16.0):
        size.width = 960.0
    if ! (size.height >= 16.0):
        size.height = 540.0
    return size

fn floatToPositiveInt(value: float, fallback: int): int =
    if ! (value >= 1.0):
        return fallback
    var out = 0
    var remain = value
    while remain >= 1.0 && out < 8192:
        out = out + 1
        remain = remain - 1.0
    if out < 1:
        return fallback
    return out

fn allocBuffer(info: SurfaceFrameInfo): PixelBuffer =
    var buffer: PixelBuffer
    let size = resolvePixelSize(info)
    buffer.width = floatToPositiveInt(size.width, 960)
    buffer.height = floatToPositiveInt(size.height, 540)
    if buffer.width < 320:
        buffer.width = 960
    if buffer.height < 240:
        buffer.height = 540
    buffer.strideBytes = buffer.width * 4
    let totalBytes = buffer.strideBytes * buffer.height
    buffer.ptr = uint32*(alloc(totalBytes))
    return buffer

fn freeBuffer(buffer: var PixelBuffer) =
    if buffer.ptr != nil:
        dealloc(buffer.ptr)
        buffer.ptr = nil

fn pixelOffset(buffer: PixelBuffer, x, y: int): int =
    return y * buffer.width + x

fn writePixel(buffer: PixelBuffer, x, y: int, color: uint32) =
    if x < 0 || y < 0 || x >= buffer.width || y >= buffer.height:
        return
    let offset = pixelOffset(buffer, x, y)
    let p: uint32* = uint32*(ptr_add(buffer.ptr, offset * 4))
    *p = color

fn readPixel(buffer: PixelBuffer, x, y: int): uint32 =
    if buffer.ptr == nil || x < 0 || y < 0 || x >= buffer.width || y >= buffer.height:
        return uint32(0)
    let offset = pixelOffset(buffer, x, y)
    let p: uint32* = uint32*(ptr_add(buffer.ptr, offset * 4))
    return *p

fn fillRectI(buffer: PixelBuffer, x, y, w, h: int, color: uint32) =
    if buffer.ptr == nil || buffer.width <= 0 || buffer.height <= 0 || w <= 0 || h <= 0:
        return
    let x0 = clampInt(x, 0, buffer.width)
    let y0 = clampInt(y, 0, buffer.height)
    let x1 = clampInt(x + w, 0, buffer.width)
    let y1 = clampInt(y + h, 0, buffer.height)
    if x1 <= x0 || y1 <= y0:
        return
    for py in y0..<y1:
        for px in x0..<x1:
            writePixel(buffer, px, py, color)

fn clearBuffer(buffer: PixelBuffer, color: uint32) =
    if buffer.ptr == nil:
        return
    let total = buffer.width * buffer.height
    for idx in 0..<total:
        let p: uint32* = uint32*(ptr_add(buffer.ptr, idx * 4))
        *p = color

fn drawRect(buffer: PixelBuffer, rect: GuiRect, color: uint32) =
    if buffer.ptr == nil:
        return
    let x0 = rect.origin.x
    let y0 = rect.origin.y
    let x1 = rect.origin.x + rect.size.width
    let y1 = rect.origin.y + rect.size.height
    if x1 <= x0 || y1 <= y0:
        return
    for y in 0..<buffer.height:
        let py = float(y) + 0.5
        if py < y0 || py >= y1:
            continue
        for x in 0..<buffer.width:
            let px = float(x) + 0.5
            if px >= x0 && px < x1:
                writePixel(buffer, x, y, color)

fn drawTextFallback(buffer: PixelBuffer, rect: GuiRect, color: uint32) =
    # Pure-Cheng fallback: text is represented as a thin accent band.
    var band = rect
    band.size.height = minFloat(rect.size.height, 4.0)
    drawRect(buffer, band, color)

fn utf8Byte(ch: char): int32 =
    var code = int32(ch)
    if code < 0:
        code = code + 256
    return code

fn utf8Trail(b: int32): bool =
    return b >= int32(0x80) && b <= int32(0xBF)

fn utf8StepAt(text: str, offset: int32): int32 =
    if offset < int32(0) || offset >= len(text):
        return int32(1)
    let b0 = utf8Byte(text[offset])
    if b0 < int32(0x80):
        return int32(1)
    if b0 >= int32(0xC2) && b0 <= int32(0xDF):
        if offset + int32(1) >= len(text):
            return int32(1)
        let b1 = utf8Byte(text[offset + int32(1)])
        if ! utf8Trail(b1):
            return int32(1)
        return int32(2)
    if b0 >= int32(0xE0) && b0 <= int32(0xEF):
        if offset + int32(2) >= len(text):
            return int32(1)
        let b1 = utf8Byte(text[offset + int32(1)])
        let b2 = utf8Byte(text[offset + int32(2)])
        if ! utf8Trail(b1) || ! utf8Trail(b2):
            return int32(1)
        return int32(3)
    if b0 >= int32(0xF0) && b0 <= int32(0xF4):
        if offset + int32(3) >= len(text):
            return int32(1)
        let b1 = utf8Byte(text[offset + int32(1)])
        let b2 = utf8Byte(text[offset + int32(2)])
        let b3 = utf8Byte(text[offset + int32(3)])
        if ! utf8Trail(b1) || ! utf8Trail(b2) || ! utf8Trail(b3):
            return int32(1)
        return int32(4)
    return int32(1)

fn utf8CodepointAt(text: str, offset: int32): int32 =
    if offset < int32(0) || offset >= len(text):
        return int32(0xFFFD)
    let b0 = utf8Byte(text[offset])
    if b0 < int32(0x80):
        return b0
    if b0 >= int32(0xC2) && b0 <= int32(0xDF):
        if offset + int32(1) >= len(text):
            return int32(0xFFFD)
        let b1 = utf8Byte(text[offset + int32(1)])
        if ! utf8Trail(b1):
            return int32(0xFFFD)
        return ((b0 & int32(0x1F)) * int32(64)) + (b1 & int32(0x3F))
    if b0 >= int32(0xE0) && b0 <= int32(0xEF):
        if offset + int32(2) >= len(text):
            return int32(0xFFFD)
        let b1 = utf8Byte(text[offset + int32(1)])
        let b2 = utf8Byte(text[offset + int32(2)])
        if ! utf8Trail(b1) || ! utf8Trail(b2):
            return int32(0xFFFD)
        return ((b0 & int32(0x0F)) * int32(4096)) + ((b1 & int32(0x3F)) * int32(64)) + (b2 & int32(0x3F))
    if b0 >= int32(0xF0) && b0 <= int32(0xF4):
        if offset + int32(3) >= len(text):
            return int32(0xFFFD)
        let b1 = utf8Byte(text[offset + int32(1)])
        let b2 = utf8Byte(text[offset + int32(2)])
        let b3 = utf8Byte(text[offset + int32(3)])
        if ! utf8Trail(b1) || ! utf8Trail(b2) || ! utf8Trail(b3):
            return int32(0xFFFD)
        return ((b0 & int32(0x07)) * int32(262144)) + ((b1 & int32(0x3F)) * int32(4096)) + ((b2 & int32(0x3F)) * int32(64)) + (b3 & int32(0x3F))
    return int32(0xFFFD)

fn isCjkCodepoint(cp: int32): bool =
    if cp >= int32(0x3000) && cp <= int32(0x303F):
        return true
    if cp >= int32(0x3400) && cp <= int32(0x4DBF):
        return true
    if cp >= int32(0x4E00) && cp <= int32(0x9FFF):
        return true
    if cp >= int32(0xF900) && cp <= int32(0xFAFF):
        return true
    if cp >= int32(0x2E80) && cp <= int32(0x2FDF):
        return true
    if cp >= int32(0x31C0) && cp <= int32(0x31EF):
        return true
    if cp >= int32(0x20000) && cp <= int32(0x2EBEF):
        return true
    return false

fn textHasCjk(text: str): bool =
    var idx = int32(0)
    while idx < len(text):
        let cp = utf8CodepointAt(text, idx)
        if isCjkCodepoint(cp):
            return true
        var step = utf8StepAt(text, idx)
        if step < int32(1):
            step = int32(1)
        idx = idx + step
    return false

fn drawLine(buffer: PixelBuffer, x0, y0, x1, y1: float, color: uint32, strokeWidth: float) =
    if buffer.ptr == nil:
        return
    var thickness = strokeWidth
    if thickness < 1.0:
        thickness = 1.0
    let half = thickness / 2.0
    let dx = x1 - x0
    let dy = y1 - y0
    var steps = floatToPositiveInt(absFloat(dx), 1)
    let ySteps = floatToPositiveInt(absFloat(dy), 1)
    if ySteps > steps:
        steps = ySteps
    if steps < 1:
        steps = 1
    for idx in 0..steps:
        let t = float(idx) / float(steps)
        let px = x0 + (dx * t)
        let py = y0 + (dy * t)
        drawRect(buffer, makeRect(px - half, py - half, thickness, thickness), color)

fn drawBrowserSurface(buffer: PixelBuffer, rect: GuiRect, color: uint32) =
    drawRect(buffer, rect, color)
    var band = rect
    band.origin.y = rect.origin.y + 4.0
    band.size.height = 3.0
    drawRect(buffer, band, uint32(0xFFFFFFFF))

fn drawCommandRectI(buffer: PixelBuffer, cmd: drawir.DrawCommand, color: uint32) =
    var x = int(cmd.rectX)
    var y = int(cmd.rectY)
    var w = int(cmd.rectW)
    var h = int(cmd.rectH)
    if w <= 0 || h <= 0:
        x = floatToPositiveInt(cmd.rect.origin.x, 0)
        y = floatToPositiveInt(cmd.rect.origin.y, 0)
        w = floatToPositiveInt(cmd.rect.size.width, 0)
        h = floatToPositiveInt(cmd.rect.size.height, 0)
    if w <= 0 || h <= 0:
        return
    fillRectI(buffer, x, y, w, h, color)

fn drawCommandLineI(buffer: PixelBuffer, cmd: drawir.DrawCommand) =
    drawLine(buffer, float(cmd.p0x), float(cmd.p0y), float(cmd.p1x), float(cmd.p1y), cmd.color, cmd.strokeWidth)

fn drawCommandText(buffer: PixelBuffer, cmd: drawir.DrawCommand, color: uint32): bool =
    var x = int(cmd.rectX)
    var y = int(cmd.rectY)
    var w = int(cmd.rectW)
    var h = int(cmd.rectH)
    if w <= 0 || h <= 0:
        x = floatToPositiveInt(cmd.rect.origin.x, 0)
        y = floatToPositiveInt(cmd.rect.origin.y, 0)
        w = floatToPositiveInt(cmd.rect.size.width, 0)
        h = floatToPositiveInt(cmd.rect.size.height, 0)
    if h <= 0:
        h = 18
    if w <= 0:
        w = 160
    let rect = makeRect(float(x), float(y), float(w), float(h))
    let hasCjk = textHasCjk(cmd.text)
    if hasCjk && nativeCjkDisabled():
        if ! envIs("CHENG_GUI_DISABLE_BITMAP_TEXT", "1"):
            if text_bitmap.drawTextBitmap(
                buffer.ptr,
                int32(buffer.width),
                int32(buffer.height),
                int32(buffer.strideBytes),
                int32(x),
                int32(y),
                int32(w),
                int32(h),
                color,
                cmd.fontSize,
                cmd.text
            ):
                return true
        drawTextFallback(buffer, rect, color)
        return true
    if hasCjk:
        if text_native.DrawTextBgra(buffer.ptr, buffer.width, buffer.height, buffer.strideBytes, rect, color, cmd.fontSize, cmd.text):
            return true
        if strictRuntimeEnabled():
            # Strict mode forbids CJK fallback-to-'?': keep a visible failure marker.
            drawRect(buffer, rect, uint32(0xFFFFE4E6))
            return false
    if ! envIs("CHENG_GUI_DISABLE_BITMAP_TEXT", "1"):
        if text_bitmap.drawTextBitmap(
            buffer.ptr,
            int32(buffer.width),
            int32(buffer.height),
            int32(buffer.strideBytes),
            int32(x),
            int32(y),
            int32(w),
            int32(h),
            color,
            cmd.fontSize,
            cmd.text
        ):
            return true
    if text_native.DrawTextBgra(buffer.ptr, buffer.width, buffer.height, buffer.strideBytes, rect, color, cmd.fontSize, cmd.text):
        return true
    drawTextFallback(buffer, rect, color)
    return true

fn submitDrawList(buffer: PixelBuffer, list: drawir.DrawList): bool =
    if list == nil:
        return true
    var ok = true
    for idx in 0..<len(list.commands):
        let cmd = list.commands[idx]
        if cmd.kind == drawir.dcRect:
            drawCommandRectI(buffer, cmd, cmd.color)
        elif cmd.kind == drawir.dcLine:
            drawCommandLineI(buffer, cmd)
        elif cmd.kind == drawir.dcText:
            if ! drawCommandText(buffer, cmd, cmd.color):
                ok = false
        elif cmd.kind == drawir.dcImage:
            drawCommandRectI(buffer, cmd, uint32(0xFF2B303B))
        elif cmd.kind == drawir.dcWebSurface:
            drawCommandRectI(buffer, cmd, uint32(0xFF1D2733))
            if ! drawCommandText(buffer, cmd, uint32(0xFFEAF0F6)):
                ok = false
        elif cmd.kind == drawir.dcPdfPage:
            drawCommandRectI(buffer, cmd, uint32(0xFF2A2430))
            if ! drawCommandText(buffer, cmd, uint32(0xFFEADFFC)):
                ok = false
        elif cmd.kind == drawir.dcMediaFrame:
            drawCommandRectI(buffer, cmd, uint32(0xFF1A2D24))
            if ! drawCommandText(buffer, cmd, uint32(0xFFD5FFE9)):
                ok = false
    return ok

fn drawFallbackTextBands(buffer: PixelBuffer, row: int, text: str, color: uint32) =
    text
    let y = 76 + row * 24
    if y >= buffer.height - 8:
        return
    var width = 192
    let maxWidth = maxInt(24, buffer.width - 32)
    if width > maxWidth:
        width = maxWidth
    fillRectI(buffer, 16, y, width, 4, color)
    fillRectI(buffer, 16, y + 7, maxInt(20, width / 2), 3, uint32(0xAA3A3A3A))

fn drawFallbackFromList(buffer: PixelBuffer, list: drawir.DrawList) =
    fillRectI(buffer, 0, 0, buffer.width, buffer.height, uint32(0xFFF6F8FB))
    if list == nil:
        return
    var textRow = 0
    var rectRow = 0
    var lineRow = 0
    for idx in 0..<len(list.commands):
        let cmd = list.commands[idx]
        if cmd.kind == drawir.dcRect:
            if idx == 0:
                fillRectI(buffer, 0, 0, buffer.width, buffer.height, cmd.color)
            elif idx == 1:
                fillRectI(buffer, 0, 0, buffer.width, minInt(56, buffer.height), cmd.color)
            else:
                let y = 132 + rectRow * 30
                if y < buffer.height - 18:
                    fillRectI(buffer, 20, y, maxInt(16, buffer.width - 40), 18, cmd.color)
                rectRow = rectRow + 1
        elif cmd.kind == drawir.dcLine:
            let y = 120 + lineRow * 18
            if y < buffer.height - 2:
                fillRectI(buffer, 16, y, maxInt(8, buffer.width - 32), 2, cmd.color)
            lineRow = lineRow + 1
        elif cmd.kind == drawir.dcText:
            drawFallbackTextBands(buffer, textRow, cmd.text, cmd.color)
            textRow = textRow + 1
        elif cmd.kind == drawir.dcImage:
            fillRectI(buffer, 24, 180, maxInt(40, buffer.width - 48), maxInt(30, buffer.height / 6), uint32(0xFF2B303B))
        elif cmd.kind == drawir.dcWebSurface:
            fillRectI(buffer, 24, 180, maxInt(40, buffer.width - 48), maxInt(32, buffer.height - 216), uint32(0xFF1D2733))
            fillRectI(buffer, 24, 184, maxInt(20, buffer.width / 3), 4, uint32(0xFFEAF0F6))
        elif cmd.kind == drawir.dcPdfPage:
            fillRectI(buffer, 24, 180, maxInt(40, buffer.width - 48), maxInt(32, buffer.height - 216), uint32(0xFF2A2430))
            fillRectI(buffer, 24, 184, maxInt(20, buffer.width / 3), 4, uint32(0xFFEADFFC))
        elif cmd.kind == drawir.dcMediaFrame:
            fillRectI(buffer, 24, 180, maxInt(40, buffer.width - 48), maxInt(32, buffer.height - 216), uint32(0xFF1A2D24))
            fillRectI(buffer, 24, 184, maxInt(20, buffer.width / 3), 4, uint32(0xFFD5FFE9))

fn defaultFrameInfo(): SurfaceFrameInfo =
    var info: SurfaceFrameInfo
    info.logicalSize = makeSize(960.0, 540.0)
    info.pixelSize = makeSize(960.0, 540.0)
    info.dpiScale = 1.0
    info.colorSpace = "sRGB"
    return info

fn renderDrawList(surface: SurfaceHandle, info: SurfaceFrameInfo, list: drawir.DrawList) =
    if surface == nil:
        return
    var buffer = allocBuffer(info)
    if buffer.width < 320 || buffer.height < 240:
        freeBuffer(buffer)
        buffer = allocBuffer(defaultFrameInfo())
    if buffer.ptr == nil:
        return
    clearBuffer(buffer, uint32(0xFF101216))
    let beforeP0 = readPixel(buffer, 0, 0)
    let submitOk = submitDrawList(buffer, list)
    let afterP0 = readPixel(buffer, 0, 0)
    if submitOk && list != nil && len(list.commands) > 0 && afterP0 == beforeP0:
        drawFallbackFromList(buffer, list)
    if strictRuntimeEnabled() && ! submitOk:
        sysplat.presentPixels(surface, buffer.ptr, buffer.width, buffer.height, buffer.strideBytes)
        freeBuffer(buffer)
        return
    sysplat.presentPixels(surface, buffer.ptr, buffer.width, buffer.height, buffer.strideBytes)
    freeBuffer(buffer)

fn renderDrawList(surface: SurfaceHandle, list: drawir.DrawList) =
    renderDrawList(surface, defaultFrameInfo(), list)

fn shutdownCompatBridge() =
    return
