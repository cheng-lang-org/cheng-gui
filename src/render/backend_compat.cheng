import std/os
import gui/platform/types_v1
import gui/platform/native_sys_impl as sysplat
import gui/render/drawlist_ir as drawir
import gui/render/text_bitmap
import gui/render/text_native

fn envIs(name: str, expected: str): bool =
    return os.getEnv(name) == expected

fn strictRuntimeEnabled(): bool =
    if envIs("R2C_STRICT_RUNTIME", "1"):
        return true
    return envIs("CHENG_R2C_STRICT_RUNTIME", "1")

fn nativeCjkDisabled(): bool =
    if envIs("R2C_DISABLE_NATIVE_CJK_TEXT", "1"):
        return true
    return envIs("CHENG_R2C_DISABLE_NATIVE_CJK_TEXT", "1")

type
    PixelBuffer =
        ptr: uint32*
        width: int
        height: int
        strideBytes: int

fn clampInt(value, lower, upper: int): int =
    if value < lower:
        return lower
    if value > upper:
        return upper
    return value

fn maxInt(a, b: int): int =
    if a >= b:
        return a
    return b

fn minInt(a, b: int): int =
    if a <= b:
        return a
    return b

fn minFloat(a, b: float): float =
    if a <= b:
        return a
    return b

fn absInt(value: int): int =
    if value < 0:
        return -value
    return value

fn absFloat(value: float): float =
    if value < 0.0:
        return -value
    return value

fn signInt(value: int): int =
    if value < 0:
        return -1
    if value > 0:
        return 1
    return 0

fn resolvePixelSize(info: SurfaceFrameInfo): GuiSize =
    var size = info.pixelSize
    if ! (size.width >= 16.0) || ! (size.height >= 16.0):
        size = info.logicalSize
    if ! (size.width >= 16.0):
        size.width = 960.0
    if ! (size.height >= 16.0):
        size.height = 540.0
    return size

fn floatToPositiveInt(value: float, fallback: int): int =
    if ! (value >= 1.0):
        return fallback
    var out = 0
    var remain = value
    while remain >= 1.0 && out < 8192:
        out = out + 1
        remain = remain - 1.0
    if out < 1:
        return fallback
    return out

fn allocBuffer(info: SurfaceFrameInfo): PixelBuffer =
    var buffer: PixelBuffer
    let size = resolvePixelSize(info)
    buffer.width = floatToPositiveInt(size.width, 960)
    buffer.height = floatToPositiveInt(size.height, 540)
    if buffer.width < 320:
        buffer.width = 960
    if buffer.height < 240:
        buffer.height = 540
    buffer.strideBytes = buffer.width * 4
    let totalBytes = buffer.strideBytes * buffer.height
    buffer.ptr = uint32*(alloc(totalBytes))
    return buffer

fn freeBuffer(buffer: var PixelBuffer) =
    if buffer.ptr != nil:
        dealloc(buffer.ptr)
        buffer.ptr = nil

fn pixelOffset(buffer: PixelBuffer, x, y: int): int =
    return y * buffer.width + x

fn writePixel(buffer: PixelBuffer, x, y: int, color: uint32) =
    if x < 0 || y < 0 || x >= buffer.width || y >= buffer.height:
        return
    let offset = pixelOffset(buffer, x, y)
    let p: uint32* = uint32*(ptr_add(buffer.ptr, offset * 4))
    *p = color

fn readPixel(buffer: PixelBuffer, x, y: int): uint32 =
    if buffer.ptr == nil || x < 0 || y < 0 || x >= buffer.width || y >= buffer.height:
        return uint32(0)
    let offset = pixelOffset(buffer, x, y)
    let p: uint32* = uint32*(ptr_add(buffer.ptr, offset * 4))
    return *p

fn fillRectI(buffer: PixelBuffer, x, y, w, h: int, color: uint32) =
    if buffer.ptr == nil || buffer.width <= 0 || buffer.height <= 0 || w <= 0 || h <= 0:
        return
    let x0 = clampInt(x, 0, buffer.width)
    let y0 = clampInt(y, 0, buffer.height)
    let x1 = clampInt(x + w, 0, buffer.width)
    let y1 = clampInt(y + h, 0, buffer.height)
    if x1 <= x0 || y1 <= y0:
        return
    for py in y0..<y1:
        for px in x0..<x1:
            writePixel(buffer, px, py, color)

fn clearBuffer(buffer: PixelBuffer, color: uint32) =
    if buffer.ptr == nil:
        return
    let total = buffer.width * buffer.height
    for idx in 0..<total:
        let p: uint32* = uint32*(ptr_add(buffer.ptr, idx * 4))
        *p = color

fn drawRect(buffer: PixelBuffer, rect: GuiRect, color: uint32) =
    if buffer.ptr == nil:
        return
    let x0 = rect.origin.x
    let y0 = rect.origin.y
    let x1 = rect.origin.x + rect.size.width
    let y1 = rect.origin.y + rect.size.height
    if x1 <= x0 || y1 <= y0:
        return
    for y in 0..<buffer.height:
        let py = float(y) + 0.5
        if py < y0 || py >= y1:
            continue
        for x in 0..<buffer.width:
            let px = float(x) + 0.5
            if px >= x0 && px < x1:
                writePixel(buffer, x, y, color)

fn drawTextFallback(buffer: PixelBuffer, rect: GuiRect, color: uint32) =
    # Pure-Cheng fallback: paint a deterministic text band directly with int
    # raster writes so it still appears when native text drawing is unavailable.
    let x = floatToPositiveInt(rect.origin.x, 0)
    let y = floatToPositiveInt(rect.origin.y, 0)
    var w = floatToPositiveInt(rect.size.width, 0)
    var h = floatToPositiveInt(rect.size.height, 0)
    if h <= 0:
        h = 16
    if w <= 0:
        w = 160
    var bandH = h
    if bandH > 4:
        bandH = 4
    if bandH < 1:
        bandH = 1
    fillRectI(buffer, x, y, w, bandH, color)

fn drawTextFallbackI(buffer: PixelBuffer, x, y, w, h: int32, color: uint32) =
    var bx = int(x)
    var by = int(y)
    var bw = int(w)
    var bh = int(h)
    if bx < 0:
        bx = 0
    if by < 0:
        by = 0
    if bw <= 0:
        bw = 160
    if bh <= 0:
        bh = 16
    var bandH = bh
    if bandH > 4:
        bandH = 4
    if bandH < 1:
        bandH = 1
    fillRectI(buffer, bx, by, bw, bandH, color)

fn drawBitmapTextChecked(buffer: PixelBuffer, x, y, w, h: int32, color: uint32, fontSize: float, text: str): bool =
    let xi = int(x)
    let yi = int(y)
    var sx = xi
    var sy = yi
    if sx < 0:
        sx = 0
    if sy < 0:
        sy = 0
    if sx >= buffer.width:
        sx = buffer.width - 1
    if sy >= buffer.height:
        sy = buffer.height - 1
    var sx2 = sx + 1
    if sx2 >= buffer.width:
        sx2 = sx
    var sy2 = sy + 1
    if sy2 >= buffer.height:
        sy2 = sy
    let beforeA = readPixel(buffer, sx, sy)
    let beforeB = readPixel(buffer, sx2, sy2)
    if ! text_bitmap.drawTextBitmap(
        buffer.ptr,
        int32(buffer.width),
        int32(buffer.height),
        int32(buffer.strideBytes),
        x,
        y,
        w,
        h,
        color,
        fontSize,
        text
    ):
        return false
    let afterA = readPixel(buffer, sx, sy)
    let afterB = readPixel(buffer, sx2, sy2)
    if beforeA != afterA || beforeB != afterB:
        return true
    return false

fn utf8Byte(ch: char): int32 =
    var code = int32(ch)
    if code < 0:
        code = code + 256
    return code

fn utf8Trail(b: int32): bool =
    return b >= int32(0x80) && b <= int32(0xBF)

fn utf8StepAt(text: str, offset: int32): int32 =
    if offset < int32(0) || offset >= len(text):
        return int32(1)
    let b0 = utf8Byte(text[offset])
    if b0 < int32(0x80):
        return int32(1)
    if b0 >= int32(0xC2) && b0 <= int32(0xDF):
        if offset + int32(1) >= len(text):
            return int32(1)
        let b1 = utf8Byte(text[offset + int32(1)])
        if ! utf8Trail(b1):
            return int32(1)
        return int32(2)
    if b0 >= int32(0xE0) && b0 <= int32(0xEF):
        if offset + int32(2) >= len(text):
            return int32(1)
        let b1 = utf8Byte(text[offset + int32(1)])
        let b2 = utf8Byte(text[offset + int32(2)])
        if ! utf8Trail(b1) || ! utf8Trail(b2):
            return int32(1)
        return int32(3)
    if b0 >= int32(0xF0) && b0 <= int32(0xF4):
        if offset + int32(3) >= len(text):
            return int32(1)
        let b1 = utf8Byte(text[offset + int32(1)])
        let b2 = utf8Byte(text[offset + int32(2)])
        let b3 = utf8Byte(text[offset + int32(3)])
        if ! utf8Trail(b1) || ! utf8Trail(b2) || ! utf8Trail(b3):
            return int32(1)
        return int32(4)
    return int32(1)

fn utf8CodepointAt(text: str, offset: int32): int32 =
    if offset < int32(0) || offset >= len(text):
        return int32(0xFFFD)
    let b0 = utf8Byte(text[offset])
    if b0 < int32(0x80):
        return b0
    if b0 >= int32(0xC2) && b0 <= int32(0xDF):
        if offset + int32(1) >= len(text):
            return int32(0xFFFD)
        let b1 = utf8Byte(text[offset + int32(1)])
        if ! utf8Trail(b1):
            return int32(0xFFFD)
        return ((b0 & int32(0x1F)) * int32(64)) + (b1 & int32(0x3F))
    if b0 >= int32(0xE0) && b0 <= int32(0xEF):
        if offset + int32(2) >= len(text):
            return int32(0xFFFD)
        let b1 = utf8Byte(text[offset + int32(1)])
        let b2 = utf8Byte(text[offset + int32(2)])
        if ! utf8Trail(b1) || ! utf8Trail(b2):
            return int32(0xFFFD)
        return ((b0 & int32(0x0F)) * int32(4096)) + ((b1 & int32(0x3F)) * int32(64)) + (b2 & int32(0x3F))
    if b0 >= int32(0xF0) && b0 <= int32(0xF4):
        if offset + int32(3) >= len(text):
            return int32(0xFFFD)
        let b1 = utf8Byte(text[offset + int32(1)])
        let b2 = utf8Byte(text[offset + int32(2)])
        let b3 = utf8Byte(text[offset + int32(3)])
        if ! utf8Trail(b1) || ! utf8Trail(b2) || ! utf8Trail(b3):
            return int32(0xFFFD)
        return ((b0 & int32(0x07)) * int32(262144)) + ((b1 & int32(0x3F)) * int32(4096)) + ((b2 & int32(0x3F)) * int32(64)) + (b3 & int32(0x3F))
    return int32(0xFFFD)

fn isCjkCodepoint(cp: int32): bool =
    if cp >= int32(0x3000) && cp <= int32(0x303F):
        return true
    if cp >= int32(0x3400) && cp <= int32(0x4DBF):
        return true
    if cp >= int32(0x4E00) && cp <= int32(0x9FFF):
        return true
    if cp >= int32(0xF900) && cp <= int32(0xFAFF):
        return true
    if cp >= int32(0x2E80) && cp <= int32(0x2FDF):
        return true
    if cp >= int32(0x31C0) && cp <= int32(0x31EF):
        return true
    if cp >= int32(0x20000) && cp <= int32(0x2EBEF):
        return true
    return false

fn textHasCjk(text: str): bool =
    var idx = int32(0)
    while idx < len(text):
        let cp = utf8CodepointAt(text, idx)
        if isCjkCodepoint(cp):
            return true
        var step = utf8StepAt(text, idx)
        if step < int32(1):
            step = int32(1)
        idx = idx + step
    return false

fn textHasNonAscii(text: str): bool =
    var idx = int32(0)
    while idx < len(text):
        if utf8Byte(text[idx]) >= int32(0x80):
            return true
        idx = idx + int32(1)
    return false

fn strictBitmapText(text: str): str =
    return text

fn fontSizeToX100(fontSize: float): int32 =
    if ! (fontSize >= 1.0):
        return int32(1400)
    var whole: int32 = int32(0)
    var remain = fontSize
    while remain >= 1.0 && whole < int32(200):
        remain = remain - 1.0
        whole = whole + int32(1)
    if whole <= int32(0):
        return int32(1400)
    return whole * int32(100)

fn drawLine(buffer: PixelBuffer, x0, y0, x1, y1: float, color: uint32, strokeWidth: float) =
    if buffer.ptr == nil:
        return
    var thickness = strokeWidth
    if thickness < 1.0:
        thickness = 1.0
    let half = thickness / 2.0
    let dx = x1 - x0
    let dy = y1 - y0
    var steps = floatToPositiveInt(absFloat(dx), 1)
    let ySteps = floatToPositiveInt(absFloat(dy), 1)
    if ySteps > steps:
        steps = ySteps
    if steps < 1:
        steps = 1
    for idx in 0..steps:
        let t = float(idx) / float(steps)
        let px = x0 + (dx * t)
        let py = y0 + (dy * t)
        drawRect(buffer, makeRect(px - half, py - half, thickness, thickness), color)

fn drawBrowserSurface(buffer: PixelBuffer, rect: GuiRect, color: uint32) =
    drawRect(buffer, rect, color)
    var band = rect
    band.origin.y = rect.origin.y + 4.0
    band.size.height = 3.0
    drawRect(buffer, band, uint32(0xFFFFFFFF))

fn drawCommandRectI(buffer: PixelBuffer, cmd: drawir.DrawCommand, color: uint32) =
    var x = int(cmd.rectX)
    var y = int(cmd.rectY)
    var w = int(cmd.rectW)
    var h = int(cmd.rectH)
    if w <= 0 || h <= 0:
        x = floatToPositiveInt(cmd.rect.origin.x, 0)
        y = floatToPositiveInt(cmd.rect.origin.y, 0)
        w = floatToPositiveInt(cmd.rect.size.width, 0)
        h = floatToPositiveInt(cmd.rect.size.height, 0)
    if w <= 0 || h <= 0:
        return
    fillRectI(buffer, x, y, w, h, color)

fn drawCommandLineI(buffer: PixelBuffer, cmd: drawir.DrawCommand) =
    drawLine(buffer, float(cmd.p0x), float(cmd.p0y), float(cmd.p1x), float(cmd.p1y), cmd.color, cmd.strokeWidth)

fn drawTextFields(buffer: PixelBuffer,
    rectX, rectY, rectW, rectH: int32,
    p0x, p0y, p1x, p1y: int32,
    rect: GuiRect,
    text: str,
    color: uint32,
    fontSize: float): bool =
    var x = int(rectX)
    var y = int(rectY)
    var w = int(rectW)
    var h = int(rectH)
    # Text commands may carry safer geometry in cmd.rect even when mirrored int
    # fields degrade (backend regression path). Prefer rect geometry when present.
    let rectXv = floatToPositiveInt(rect.origin.x, x)
    let rectYv = floatToPositiveInt(rect.origin.y, y)
    let rectWv = floatToPositiveInt(rect.size.width, w)
    let rectHv = floatToPositiveInt(rect.size.height, h)
    if rect.size.width >= 1.0 && rect.size.height >= 1.0:
        x = rectXv
        y = rectYv
        w = rectWv
        h = rectHv
    elif w <= 0 || h <= 0:
        x = rectXv
        y = rectYv
        w = rectWv
        h = rectHv
    # Secondary recovery path: text commands also mirror geometry to p0/p1.
    if ((w <= 0 || h <= 0) || (x == 0 && y == 0)) && p1x > p0x && p1y > p0y:
        x = int(p0x)
        y = int(p0y)
        w = int(p1x - p0x)
        h = int(p1y - p0y)
    if h <= 0:
        h = 18
    if w <= 0:
        w = 160
    let textRect = makeRect(float(x), float(y), float(w), float(h))
    let needsNativeText = textHasCjk(text) || textHasNonAscii(text)
    # Strict runtime: prefer deterministic bitmap glyphs and avoid unstable
    # native text calls in batch/fullroute validation.
    if strictRuntimeEnabled():
        # CJK/non-ASCII must prefer native text in strict mode; bitmap path is
        # ASCII-oriented and can degrade into '?' placeholders.
        let strictNativeFirst = envIs("GUI_DISABLE_BITMAP_TEXT", "1") || needsNativeText
        let strictFontX100 = fontSizeToX100(fontSize)
        let strictRequireNative = needsNativeText
        if strictNativeFirst:
            if ! nativeCjkDisabled():
                if text_native.DrawTextBgraI(
                    buffer.ptr,
                    buffer.width,
                    buffer.height,
                    buffer.strideBytes,
                    int32(x),
                    int32(y),
                    int32(w),
                    int32(h),
                    color,
                    strictFontX100,
                    text
                ):
                    return true
            if strictRequireNative:
                return false
            return false
        if ! strictRequireNative:
            if drawBitmapTextChecked(buffer, int32(x), int32(y), int32(w), int32(h), color, fontSize, strictBitmapText(text)):
                return true
        if ! nativeCjkDisabled():
            if text_native.DrawTextBgraI(
                buffer.ptr,
                buffer.width,
                buffer.height,
                buffer.strideBytes,
                int32(x),
                int32(y),
                int32(w),
                int32(h),
                color,
                strictFontX100,
                text
            ):
                return true
        if strictRequireNative:
            return false
        drawTextFallbackI(buffer, int32(x), int32(y), int32(w), int32(h), color)
        return false
    if needsNativeText:
        # Native CJK text path is currently unstable on strict fullroute runs.
        # Keep strict execution deterministic and crash-free by forcing software
        # fallback for non-ASCII labels.
        if ! nativeCjkDisabled():
            if text_native.DrawTextBgra(buffer.ptr, buffer.width, buffer.height, buffer.strideBytes, textRect, color, fontSize, text):
                return true
        drawTextFallback(buffer, textRect, color)
        return true
    if ! envIs("GUI_DISABLE_BITMAP_TEXT", "1"):
        if drawBitmapTextChecked(buffer, int32(x), int32(y), int32(w), int32(h), color, fontSize, text):
            return true
    if text_native.DrawTextBgra(buffer.ptr, buffer.width, buffer.height, buffer.strideBytes, textRect, color, fontSize, text):
        return true
    drawTextFallback(buffer, textRect, color)
    return true

fn submitDrawList(buffer: PixelBuffer, list: drawir.DrawList): bool =
    if list == nil:
        return true
    var ok = true
    for idx in 0..<len(list.commands):
        let cmd = list.commands[idx]
        if cmd.kind == drawir.dcRect:
            drawCommandRectI(buffer, cmd, cmd.color)
        elif cmd.kind == drawir.dcLine:
            drawCommandLineI(buffer, cmd)
        elif cmd.kind == drawir.dcText:
            if strictRuntimeEnabled():
                var tx = int(cmd.rectX)
                var ty = int(cmd.rectY)
                var tw = int(cmd.rectW)
                var th = int(cmd.rectH)
                if tw <= 0 || th <= 0:
                    tx = floatToPositiveInt(cmd.rect.origin.x, tx)
                    ty = floatToPositiveInt(cmd.rect.origin.y, ty)
                    tw = floatToPositiveInt(cmd.rect.size.width, tw)
                    th = floatToPositiveInt(cmd.rect.size.height, th)
                if ((tw <= 0 || th <= 0) || (tx == 0 && ty == 0)) && cmd.p1x > cmd.p0x && cmd.p1y > cmd.p0y:
                    tx = int(cmd.p0x)
                    ty = int(cmd.p0y)
                    tw = int(cmd.p1x - cmd.p0x)
                    th = int(cmd.p1y - cmd.p0y)
                if th <= 0:
                    th = 16
                if tw <= 0:
                    tw = 160
                let strictNativeFirst = envIs("GUI_DISABLE_BITMAP_TEXT", "1")
                let strictFontX100 = fontSizeToX100(cmd.fontSize)
                let strictNeedsNative = textHasCjk(cmd.text) || textHasNonAscii(cmd.text)
                let strictNativeFirstEffective = strictNativeFirst || strictNeedsNative
                var drew = false
                if strictNativeFirstEffective:
                    if ! nativeCjkDisabled():
                        drew = text_native.DrawTextBgraI(
                            buffer.ptr,
                            buffer.width,
                            buffer.height,
                            buffer.strideBytes,
                            int32(tx),
                            int32(ty),
                            int32(tw),
                            int32(th),
                            cmd.color,
                            strictFontX100,
                            cmd.text
                        )
                    if ! drew && strictNeedsNative:
                        ok = false
                else:
                    drew = text_bitmap.drawTextBitmap(
                        buffer.ptr,
                        int32(buffer.width),
                        int32(buffer.height),
                        int32(buffer.strideBytes),
                        int32(tx),
                        int32(ty),
                        int32(tw),
                        int32(th),
                        cmd.color,
                        cmd.fontSize,
                        strictBitmapText(cmd.text)
                    )
                    if ! drew && ! nativeCjkDisabled():
                        drew = text_native.DrawTextBgraI(
                            buffer.ptr,
                            buffer.width,
                            buffer.height,
                            buffer.strideBytes,
                            int32(tx),
                            int32(ty),
                            int32(tw),
                            int32(th),
                            cmd.color,
                            strictFontX100,
                            cmd.text
                        )
                if ! drew:
                    if ! strictNeedsNative:
                        drawTextFallbackI(buffer, int32(tx), int32(ty), int32(tw), int32(th), cmd.color)
                    ok = false
            else:
                if ! drawTextFields(
                    buffer,
                    cmd.rectX, cmd.rectY, cmd.rectW, cmd.rectH,
                    cmd.p0x, cmd.p0y, cmd.p1x, cmd.p1y,
                    cmd.rect,
                    cmd.text,
                    cmd.color,
                    cmd.fontSize
                ):
                    ok = false
        elif cmd.kind == drawir.dcImage:
            drawCommandRectI(buffer, cmd, uint32(0xFF2B303B))
        elif cmd.kind == drawir.dcWebSurface:
            drawCommandRectI(buffer, cmd, uint32(0xFF1D2733))
            if ! drawTextFields(
                buffer,
                cmd.rectX, cmd.rectY, cmd.rectW, cmd.rectH,
                cmd.p0x, cmd.p0y, cmd.p1x, cmd.p1y,
                cmd.rect,
                cmd.text,
                uint32(0xFFEAF0F6),
                cmd.fontSize
            ):
                ok = false
        elif cmd.kind == drawir.dcPdfPage:
            drawCommandRectI(buffer, cmd, uint32(0xFF2A2430))
            if ! drawTextFields(
                buffer,
                cmd.rectX, cmd.rectY, cmd.rectW, cmd.rectH,
                cmd.p0x, cmd.p0y, cmd.p1x, cmd.p1y,
                cmd.rect,
                cmd.text,
                uint32(0xFFEADFFC),
                cmd.fontSize
            ):
                ok = false
        elif cmd.kind == drawir.dcMediaFrame:
            drawCommandRectI(buffer, cmd, uint32(0xFF1A2D24))
            if ! drawTextFields(
                buffer,
                cmd.rectX, cmd.rectY, cmd.rectW, cmd.rectH,
                cmd.p0x, cmd.p0y, cmd.p1x, cmd.p1y,
                cmd.rect,
                cmd.text,
                uint32(0xFFD5FFE9),
                cmd.fontSize
            ):
                ok = false
    return ok

fn drawFallbackTextBands(buffer: PixelBuffer, row: int, text: str, color: uint32) =
    text
    let y = 76 + row * 24
    if y >= buffer.height - 8:
        return
    var width = 192
    let maxWidth = maxInt(24, buffer.width - 32)
    if width > maxWidth:
        width = maxWidth
    fillRectI(buffer, 16, y, width, 4, color)
    fillRectI(buffer, 16, y + 7, maxInt(20, width / 2), 3, uint32(0xAA3A3A3A))

fn drawFallbackFromList(buffer: PixelBuffer, list: drawir.DrawList) =
    fillRectI(buffer, 0, 0, buffer.width, buffer.height, uint32(0xFFF6F8FB))
    if list == nil:
        return
    var textRow = 0
    var rectRow = 0
    var lineRow = 0
    for idx in 0..<len(list.commands):
        let cmd = list.commands[idx]
        if cmd.kind == drawir.dcRect:
            if idx == 0:
                fillRectI(buffer, 0, 0, buffer.width, buffer.height, cmd.color)
            elif idx == 1:
                fillRectI(buffer, 0, 0, buffer.width, minInt(56, buffer.height), cmd.color)
            else:
                let y = 132 + rectRow * 30
                if y < buffer.height - 18:
                    fillRectI(buffer, 20, y, maxInt(16, buffer.width - 40), 18, cmd.color)
                rectRow = rectRow + 1
        elif cmd.kind == drawir.dcLine:
            let y = 120 + lineRow * 18
            if y < buffer.height - 2:
                fillRectI(buffer, 16, y, maxInt(8, buffer.width - 32), 2, cmd.color)
            lineRow = lineRow + 1
        elif cmd.kind == drawir.dcText:
            drawFallbackTextBands(buffer, textRow, cmd.text, cmd.color)
            textRow = textRow + 1
        elif cmd.kind == drawir.dcImage:
            fillRectI(buffer, 24, 180, maxInt(40, buffer.width - 48), maxInt(30, buffer.height / 6), uint32(0xFF2B303B))
        elif cmd.kind == drawir.dcWebSurface:
            fillRectI(buffer, 24, 180, maxInt(40, buffer.width - 48), maxInt(32, buffer.height - 216), uint32(0xFF1D2733))
            fillRectI(buffer, 24, 184, maxInt(20, buffer.width / 3), 4, uint32(0xFFEAF0F6))
        elif cmd.kind == drawir.dcPdfPage:
            fillRectI(buffer, 24, 180, maxInt(40, buffer.width - 48), maxInt(32, buffer.height - 216), uint32(0xFF2A2430))
            fillRectI(buffer, 24, 184, maxInt(20, buffer.width / 3), 4, uint32(0xFFEADFFC))
        elif cmd.kind == drawir.dcMediaFrame:
            fillRectI(buffer, 24, 180, maxInt(40, buffer.width - 48), maxInt(32, buffer.height - 216), uint32(0xFF1A2D24))
            fillRectI(buffer, 24, 184, maxInt(20, buffer.width / 3), 4, uint32(0xFFD5FFE9))

fn defaultFrameInfo(): SurfaceFrameInfo =
    var info: SurfaceFrameInfo
    info.logicalSize = makeSize(960.0, 540.0)
    info.pixelSize = makeSize(960.0, 540.0)
    info.dpiScale = 1.0
    info.colorSpace = "sRGB"
    return info

fn renderDrawList(surface: SurfaceHandle, info: SurfaceFrameInfo, list: drawir.DrawList) =
    if surface == nil:
        return
    var buffer = allocBuffer(info)
    if buffer.width < 320 || buffer.height < 240:
        freeBuffer(buffer)
        buffer = allocBuffer(defaultFrameInfo())
    if buffer.ptr == nil:
        return
    clearBuffer(buffer, uint32(0xFF101216))
    let submitOk = submitDrawList(buffer, list)
    if strictRuntimeEnabled() && ! submitOk:
        sysplat.presentPixels(surface, buffer.ptr, buffer.width, buffer.height, buffer.strideBytes)
        freeBuffer(buffer)
        return
    # Non-strict compatibility path: only synthesize fallback bands when
    # command submission itself failed.
    if ! strictRuntimeEnabled() && ! submitOk && list != nil && len(list.commands) > 0:
        drawFallbackFromList(buffer, list)
    sysplat.presentPixels(surface, buffer.ptr, buffer.width, buffer.height, buffer.strideBytes)
    freeBuffer(buffer)

fn renderDrawList(surface: SurfaceHandle, list: drawir.DrawList) =
    renderDrawList(surface, defaultFrameInfo(), list)

fn shutdownCompatBridge() =
    return
