import std/os
import std/times
import tables
import cheng/decentralized/json_parse as jparse
import cheng/runtime/json_ast as json
import ide/textutils
import cheng/gui/services/syntax as syntax
import cheng/gui/services/diagnostics as diag
import cheng/gui/services/p2p_bridge as p2p_bridge

type
    HeadlessMode = enum
        hmDefault
        hmDesktop
        hmMobile
        hmWeb

type
    HeadlessOptions =
        mode: HeadlessMode
        enableRemote: bool
        remoteTransport: str
        remoteLatencyBudgetMs: float
        remoteBandwidthMbps: float
        remoteJitterBudgetMs: float
        remoteDropRatePercent: float

type
    GuiBuildResult =
        ok: bool
        summary: str

type
    FocusKind = enum
        fkEditor
        fkExplorer
        fkTerminal
        fkCodex

type
    ResizeDragKind = enum
        rdNone
        rdLeft
        rdRight
        rdBottom

type
    LeftPaneTab = enum
        lpExplorer
        lpSearch
        lpVcs
        lpRun
        lpExtensions
        lpCodex

type
    RightPaneTab = enum
        rpOutline
        rpDiagnostics
        rpDebugger
        rpVcs
        rpTasks
        rpCodex

type
    BottomPaneTab = enum
        bpTerminal
        bpProblems
        bpOutput
        bpDebug

type
    OverlayKind = enum
        okNone
        okOpen
        okSave
        okNewFile
        okNewFolder
        okSearch
        okGoto
        okReplace
        okSymbol
        okWorkspaceSymbol
        okCommand
        okCloseDirty

type
    OverlayState =
        kind: OverlayKind
        input: str
        prevFocus: FocusKind

type
    SearchState =
        query: str
        matchLine: int32
        matchCol: int32

fn defaultSearchState(): SearchState =
    var state: SearchState
    state.query = ""
    state.matchLine = -1
    state.matchCol = -1
    return state

type
    CompletionState =
        active: bool
        prefix: str
        items: str[]
        selected: int32

type
    ExplorerState =
        items: str[]
        allItems: str[]
        collapsed: str[]
        scroll: int32
        selected: int32

type
    SearchMatch =
        found: bool
        line: int32
        col: int32

type
    LineCol =
        ok: bool
        line: int32
        col: int32

type
    IdentMatch =
        ok: bool
        name: str
        col: int32

type
    CallContext =
        ok: bool
        name: str
        fullName: str
        openCol: int32
        argIndex: int32

type
    ParamListInfo =
        ok: bool
        text: str
        count: int32
        endIdx: int32

type
    SignatureInfo =
        ok: bool
        text: str
        paramCount: int32

type
    CursorPos =
        line: int32
        col: int32

type
    CursorList =
        len: int32
        cap: int32
        buffer: void*

type
    CursorCollection =
        positions: CursorList
        primaryIdx: int32

type
    PathLineCol =
        path: str
        hasLine: bool
        hasCol: bool
        line: int32
        col: int32

type
    ReplaceResult =
        text: str
        count: int32

type
    ReplaceLinesResult =
        lines: str[]
        count: int32
        changed: bool

type
    TaskInput =
        filePath: str
        optionArgs: str[]
        runArgs: str[]
        hasFile: bool

type
    RenameResult =
        lines: str[]
        count: int32

type
    FormatResult =
        lines: str[]
        changed: bool

type
    EditorState =
        lines: str[]
        cursorLine: int32
        cursorCol: int32
        desiredCol: int32
        scrollLine: int32
        splitActive: bool
        splitPane: int32
        splitScrollLine: int32
        filePath: str
        bufferId: int32
        bufferVersion: int32
        dirty: bool
        largeFile: bool
        largeFileLines: int32
        largeFileBytes: int32
        selectionActive: bool
        selectionAnchorLine: int32
        selectionAnchorCol: int32
        multiCursors: CursorList
        undoStack: str[]
        redoStack: str[]
        selectionHistory: str[]
        foldedRanges: str[]
        semanticReady: bool
        semanticEntries: str[]
        semanticScanActive: bool
        semanticScanLine: int32
        semanticScanVersion: int32
        semanticScanBuildIdx: int32
        semanticScanRaw: str[]
        semanticScanEntries: str[]
        semanticScanBlockKind: str
        semanticScanBlockIndent: int32
        semanticScanBlockChildIndent: int32
        outlineReady: bool
        outlineEntries: str[]
        outlineScanActive: bool
        outlineScanLine: int32
        outlineScanVersion: int32
        outlineScanEntries: str[]

type
    SyntaxTokenCacheEntry =
        line: int32
        hash: int32
        stamp: int32
        tokens: syntax.SyntaxToken[]

type
    TerminalMode = enum
        tmCommand
        tmPty

type
    TerminalState =
        label: str
        input: str
        lines: str[]
        mode: TerminalMode
        ptyActive: bool
        ptyFd: int32
        ptyPid: int64
        ptyRemainder: str
        ptyAnsiRemainder: str

type
    TerminalSessionList =
        len: int32
        cap: int32
        buffer: void*

type
    DebuggerState =
        status: str
        reason: str
        breakpoints: str[]
        frames: str[]
        variables: str[]
        watches: str[]
        sourcePath: str

type
    CodexApprovalKind = enum
        cakNone
        cakCommand
        cakFile

type
    CodexApproval =
        active: bool
        kind: CodexApprovalKind
        requestId: str
        requestIdIsString: bool
        threadId: str
        turnId: str
        itemId: str
        reason: str

type
    CodexFeedbackStep = enum
        cfsNone
        cfsCategory
        cfsConsent
        cfsNote

type
    CodexState =
        status: str
        authStatus: str
        authPending: bool
        authCheckNextMs: int64
        authStartMs: int64
        initialized: bool
        initPending: bool
        initStartMs: int64
        connectWarnNextMs: int64
        sendQueue: str[]
        sendQueueNextMs: int64
        sendQueueFailures: int32
        loginQueued: bool
        loginToken: str
        loginQueuedAtMs: int64
        loginStartMs: int64
        loginAwaitUrl: bool
        loginFallbackUsed: bool
        pendingRpcId: int32
        pendingRpcKind: str
        pendingRpcIds: int32[]
        pendingRpcKinds: str[]
        threadId: str
        turnId: str
        lastDiff: str
        contextItems: str[]
        lines: str[]
        scroll: int32
        selected: int32
        input: str
        inputHistory: str[]
        inputHistoryIndex: int32
        inputHistoryStash: str
        queue: str[]
        overlayActive: bool
        overlayScroll: int32
        draftActive: bool
        draftPath: str
        draftPrevFocus: FocusKind
        draftPrevBuffer: int32
        feedbackStep: CodexFeedbackStep
        feedbackCategory: str
        feedbackIncludeLogs: bool
        tokenTotal: int32
        tokenInput: int32
        tokenOutput: int32
        tokenLastTotal: int32
        tokenLastInput: int32
        tokenLastOutput: int32
        tokenContextWindow: int32
        quitArmed: bool
        quitArmedKey: str
        quitArmedUntilMs: int64
        approval: CodexApproval
        pipeMode: bool
        ptyActive: bool
        ptyFd: int32
        ptyWriteFd: int32
        ptyPid: int64
        ptyRemainder: str
        ptyAnsiRemainder: str
        rpcId: int32

type
    TaskKind = enum
        tkCommand
        tkDiagnostics
        tkCodexExec
        tkCodexApply

type
    TaskJob =
        kind: TaskKind
        label: str
        command: str
        workDir: str
        filePath: str
        patchPath: str

type
    TaskRunner =
        active: bool
        job: TaskJob
        ptyFd: int32
        ptyPid: int64
        ptyRemainder: str
        ptyAnsiRemainder: str
        rawOutput: str
        queue: TaskJob[]
        queueHead: int32

fn defaultDebuggerState(): DebuggerState =
    var state: DebuggerState
    state.status = "idle"
    state.reason = ""
    state.breakpoints = default[str[]]
    state.frames = default[str[]]
    state.variables = default[str[]]
    state.watches = default[str[]]
    state.sourcePath = ""
    return state

fn defaultCodexState(): CodexState =
    var state: CodexState
    state.status = "idle"
    state.authStatus = ""
    state.authPending = false
    state.authCheckNextMs = 0
    state.authStartMs = 0
    state.initialized = false
    state.initPending = false
    state.initStartMs = 0
    state.connectWarnNextMs = 0
    state.sendQueue = default[str[]]
    state.sendQueueNextMs = 0
    state.sendQueueFailures = 0
    state.loginQueued = false
    state.loginToken = ""
    state.loginQueuedAtMs = 0
    state.loginStartMs = 0
    state.loginAwaitUrl = false
    state.loginFallbackUsed = false
    state.pendingRpcId = 0
    state.pendingRpcKind = ""
    state.pendingRpcIds = default[int32[]]
    state.pendingRpcKinds = default[str[]]
    state.threadId = ""
    state.turnId = ""
    state.lastDiff = ""
    state.contextItems = default[str[]]
    state.lines = default[str[]]
    state.scroll = 0
    state.selected = -1
    state.input = ""
    state.inputHistory = default[str[]]
    state.inputHistoryIndex = -1
    state.inputHistoryStash = ""
    state.queue = default[str[]]
    state.overlayActive = false
    state.overlayScroll = 0
    state.draftActive = false
    state.draftPath = ""
    state.draftPrevFocus = fkEditor
    state.draftPrevBuffer = -1
    state.feedbackStep = cfsNone
    state.feedbackCategory = ""
    state.feedbackIncludeLogs = false
    state.tokenTotal = 0
    state.tokenInput = 0
    state.tokenOutput = 0
    state.tokenLastTotal = 0
    state.tokenLastInput = 0
    state.tokenLastOutput = 0
    state.tokenContextWindow = 0
    state.quitArmed = false
    state.quitArmedKey = ""
    state.quitArmedUntilMs = 0
    state.approval.active = false
    state.approval.kind = cakNone
    state.approval.requestId = ""
    state.approval.requestIdIsString = false
    state.approval.threadId = ""
    state.approval.turnId = ""
    state.approval.itemId = ""
    state.approval.reason = ""
    state.pipeMode = false
    state.ptyActive = false
    state.ptyFd = -1
    state.ptyWriteFd = -1
    state.ptyPid = 0
    state.ptyRemainder = ""
    state.ptyAnsiRemainder = ""
    state.rpcId = 0
    return state

fn defaultTaskRunner(): TaskRunner =
    var runner: TaskRunner
    runner.active = false
    runner.ptyFd = -1
    runner.ptyPid = 0
    runner.ptyRemainder = ""
    runner.ptyAnsiRemainder = ""
    runner.rawOutput = ""
    runner.queue = default[TaskJob[]]
    runner.queueHead = 0
    return runner

fn defaultOverlayState(): OverlayState =
    var state: OverlayState
    state.kind = okNone
    state.input = ""
    state.prevFocus = fkEditor
    return state

type
    CodexMessageKind = enum
        ckUser
        ckAssistant
        ckTool
        ckSystem

type
    CodexAction =
        label: str
        cmd: str
        enabled: bool

type
    CodexActionRect =
        action: CodexAction
        x: float64
        y: float64
        w: float64
        h: float64

type
    SelectionRange =
        active: bool
        startLine: int32
        startCol: int32
        endLine: int32
        endCol: int32

type
    LineRange =
        active: bool
        startLine: int32
        endLine: int32

type
    ClipboardResult =
        ok: bool
        text: str

type
    MoveArgs =
        src: str
        dst: str

type
    VcsCommand =
        cmd: str
        workDir: str

type
    VcsTarget =
        target: str
        workDir: str

type
    TripleQuoteState =
        active: bool
        quote: char
        found: bool

type
    BufferList =
        len: int32
        cap: int32
        buffer: void*

type
    GuiLayout =
        topH: int32
        statusH: int32
        leftW: int32
        rightW: int32
        bottomH: int32
        contentY: int32
        contentH: int32
        editorX: int32
        editorY: int32
        editorW: int32
        editorH: int32
        bottomY: int32
        gutterW: int32
        lineHeight: float64
        fontSize: float64
        smallFont: float64
        headerFont: float64
        advance: float64
        codeX: float64
        codeY: float64
        scale: float64

type
    EditorPaneMetrics =
        y: int32
        h: int32
        codeY: float64

type
    GuiTheme =
        name: str
        background: uint32
        panel: uint32
        panelAlt: uint32
        tabActive: uint32
        tabInactive: uint32
        activityBar: uint32
        editor: uint32
        header: uint32
        status: uint32
        border: uint32
        text: uint32
        subText: uint32
        accent: uint32
        selection: uint32
        find: uint32
        keyword: uint32
        typeColor: uint32
        stringColor: uint32
        number: uint32
        comment: uint32
        lineHighlight: uint32
        indentGuide: uint32
        diagError: uint32
        diagWarning: uint32
        diagInfo: uint32
        statusBarFg: uint32

type
    FileIconDef =
        name: str
        glyph: str
        color: uint32
        hasColor: bool

type
    FileIconEntry =
        key: str
        glyph: str
        color: uint32
        hasColor: bool

type
    IconMask =
        w: int32
        h: int32
        data: int32[]

type
    ProjectSymbolCacheEntry =
        path: str
        stamp: str
        symbols: str[]

type
    GuiPerfTrace =
        enabled: bool
        logEveryMs: int32
        slowFrameMs: int32
        lastLogMs: int64
        frameMs: int32
        pollMs: int32
        eventsMs: int32
        ptyMs: int32
        taskMs: int32
        codexMs: int32
        diagMs: int32
        renderMs: int32
        presentMs: int32
        slowFrames: int32

type
    GuiState =
        lastEvent: str
        statusMsg: str
        focus: FocusKind
        textInputSeen: bool
        imeActive: bool
        imeText: str
        imeAnchorLine: int32
        imeAnchorCol: int32
        resizeDrag: ResizeDragKind
        leftPaneVisible: bool
        leftPaneWidth: int32
        rightPaneWidth: int32
        leftPaneTab: LeftPaneTab
        rightPaneVisible: bool
        rightPaneTab: RightPaneTab
        bottomPaneVisible: bool
        bottomPaneTab: BottomPaneTab
        bottomPaneHeight: int32
        bottomProblemsScroll: int32
        bottomOutputScroll: int32
        bottomProblemsSelected: int32
        bottomOutputSelected: int32
        editor: EditorState
        terminal: TerminalState
        terminalSessions: TerminalSessionList
        terminalSessionActive: int32
        terminalSessionCounter: int32
        overlay: OverlayState
        search: SearchState
        searchProject: bool
        searchResults: str[]
        searchTotal: int32
        searchTruncated: bool
        searchScroll: int32
        completion: CompletionState
        hoverActive: bool
        hoverText: str
        hoverLine: int32
        hoverCol: int32
        hoverX: float64
        hoverY: float64
        hoverTab: int32
        hoverTabClose: bool
        hoverTabControl: int32
        hoverExplorerAction: int32
        hoverSearchAction: int32
        hoverVcsAction: int32
        hoverLeftPaneTab: int32
        hoverLeftPaneRow: int32
        hoverRightPaneRow: int32
        hoverBottomPaneRow: int32
        hoverRightPaneTab: int32
        hoverBottomPaneTab: int32
        hoverActivityBottom: int32
        signatureActive: bool
        signatureText: str
        diagnostics: diag.seq_GuiDiagnostic
        diagnosticsDirty: bool
        langDiagnostics: diag.seq_GuiDiagnostic
        diagLineSev: diag.GuiDiagSeverity[]
        diagScanActive: bool
        diagScanLine: int32
        diagScanVersion: int32
        diagScanStack: diag.seq_GuiDiagStackEntry
        diagScanDiags: diag.seq_GuiDiagnostic
        diagChunkLines: int32
        outlineChunkLines: int32
        semanticChunkLines: int32
        explorer: ExplorerState
        taskLog: str[]
        taskRunner: TaskRunner
        perf: GuiPerfTrace
        renderLite: bool
        renderLiteForced: bool
        renderLiteThresholdMs: int32
        renderLiteHoldFrames: int32
        renderLiteHoldMax: int32
        renderLastMs: int32
        renderDirty: bool
        renderNextMs: int64
        renderMinIntervalMs: int32
        renderIdlePollMs: int32
        backgroundTickNextMs: int64
        backgroundTickIntervalMs: int32
        backgroundInteractiveDelayMs: int32
        backgroundBudgetMs: int32
        desktopCommandPollMs: int32
        desktopCommandNextMs: int64
        desktopCommandLastId: str
        lastInputMs: int64
        codex: CodexState
        debugger: DebuggerState
        vcsSummary: str
        vcsLines: str[]
        vcsRoot: str
        clipboard: str
        draggingEditor: bool
        dragButton: int32
        dragMulti: bool
        dragAnchorLine: int32
        dragAnchorCol: int32
        dragPane: int32
        blockSelectActive: bool
        blockAnchorLine: int32
        blockAnchorCol: int32
        lineSelectActive: bool
        lineSelectAnchorLine: int32
        tabScrollX: float64
        pendingQuit: bool
        quitRequested: bool
        diagAuto: bool
        diagPending: bool
        diagCooldown: int32
        autoSave: bool
        autoSavePending: bool
        autoSaveCooldown: int32
        formatOnSave: bool
        recoveryEnabled: bool
        recoveryPending: bool
        recoveryCooldown: int32
        workspaceRoots: str[]
        projectRoot: str
        projectSymbols: str[]
        projectSymbolCache: ProjectSymbolCacheEntry[]
        projectIndexReady: bool
        projectScanActive: bool
        projectScanIndex: int32
        projectScanFiles: str[]
        projectScanSymbols: str[]
        projectChunkFiles: int32
        buffers: BufferList
        activeBuffer: int32
        layout: GuiLayout
        layoutKey: int64
        themeName: str
        theme: GuiTheme

type
    VcsRunResult =
        state: GuiState
        exitCode: int32

type
    TabHover =
        idx: int32
        onClose: bool

type
    RecoveryLoad =
        editor: EditorState
        recovered: bool

type
    WorkspaceState =
        activePath: str
        openFiles: str[]
        collapsed: str[]
        terminalLabels: str[]
        terminalActive: int32
        themeName: str
        autoSave: int32
        formatOnSave: int32
        splitActive: int32
        splitPane: int32
        leftPaneWidth: int32
        rightPaneWidth: int32
        leftPaneVisible: int32
        leftPaneTab: int32
        rightPaneVisible: int32
        rightPaneTab: int32
        bottomPaneVisible: int32
        bottomPaneTab: int32
        bottomPaneHeight: int32

fn defaultWorkspaceState(): WorkspaceState =
    var state: WorkspaceState
    state.activePath = ""
    state.openFiles = default[str[]]
    state.collapsed = default[str[]]
    state.terminalLabels = default[str[]]
    state.terminalActive = -1
    state.themeName = ""
    state.autoSave = -1
    state.formatOnSave = -1
    state.splitActive = -1
    state.splitPane = -1
    state.leftPaneWidth = -1
    state.rightPaneWidth = -1
    state.leftPaneVisible = -1
    state.leftPaneTab = -1
    state.rightPaneVisible = -1
    state.rightPaneTab = -1
    state.bottomPaneVisible = -1
    state.bottomPaneTab = -1
    state.bottomPaneHeight = -1
    return state

type
    WorkspaceConfig =
        includeExts: str[]
        excludeDirs: str[]
        excludePaths: str[]

type
    DesktopCommand =
        id: str
        schema: str
        command: str
        path: str
        line: int32
        col: int32

const
    CodiconAdd: int32 = 0xEA60
    CodiconEdit: int32 = 0xEA73
    CodiconHistory: int32 = 0xEA82
    CodiconKey: int32 = 0xEB11
    CodiconSend: int32 = 0xEC0F
    CodiconFiles: int32 = 0xEAF0
    CodiconFile: int32 = 0xEA7B
    CodiconFolder: int32 = 0xEA83
    CodiconFolderOpened: int32 = 0xEAF7
    CodiconChevronLeft: int32 = 0xEAB5
    CodiconChevronRight: int32 = 0xEAB6
    CodiconChevronDown: int32 = 0xEAB4
    CodiconSearch: int32 = 0xEA6D
    CodiconSourceControl: int32 = 0xEA68
    CodiconRun: int32 = 0xEB2C
    CodiconTerminal: int32 = 0xEA85
    CodiconWarning: int32 = 0xEA6C
    CodiconError: int32 = 0xEA87
    CodiconInfo: int32 = 0xEA74
    CodiconOutput: int32 = 0xEB9D
    CodiconDebugConsole: int32 = 0xEB9B
    CodiconDebug: int32 = 0xEAD8
    CodiconTasklist: int32 = 0xEB67
    CodiconListTree: int32 = 0xEB86
    CodiconDiff: int32 = 0xEAE1
    CodiconDiffAdded: int32 = 0xEADC
    CodiconDiffModified: int32 = 0xEADE
    CodiconDiffRemoved: int32 = 0xEADF
    CodiconDiffRenamed: int32 = 0xEAE0
    CodiconNewFile: int32 = 0xEA7F
    CodiconNewFolder: int32 = 0xEA80
    CodiconRefresh: int32 = 0xEB37
    CodiconCollapseAll: int32 = 0xEAC5
    CodiconBeaker: int32 = 0xEA79
    CodiconTools: int32 = 0xEB6D
    CodiconPackage: int32 = 0xEB29
    CodiconClose: int32 = 0xEA76
    CodiconCloseDirty: int32 = 0xEA71
    CodiconBell: int32 = 0xEA81
    CodexAuthCheckIntervalMs: int32 = 400
    CodexAuthTimeoutMs: int32 = 15000
    CodexLoginFallbackMs: int32 = 1500
    CodexPendingMax: int32 = 32
    CodiconExtensions: int32 = 0xEAE6
    CodiconSettingsGear: int32 = 0xEB51
    CodiconAccount: int32 = 0xEB99
    CodiconCopilot: int32 = 0xEC1E
    CodiconCheck: int32 = 0xEAB2
    TabControlNone: int32 = 0
    TabControlLeft: int32 = 1
    TabControlRight: int32 = 2
    TabControlNew: int32 = 3
    ExplorerActionNone: int32 = 0
    ExplorerActionNewFile: int32 = 1
    ExplorerActionNewFolder: int32 = 2
    ExplorerActionRefresh: int32 = 3
    ExplorerActionCollapseAll: int32 = 4
    SearchActionNone: int32 = 0
    SearchActionFind: int32 = 1
    SearchActionClear: int32 = 2
    VcsActionNone: int32 = 0
    VcsActionRefresh: int32 = 1
    VcsActionStageAll: int32 = 2
    VcsActionUnstageAll: int32 = 3
    VcsActionCommit: int32 = 4
    ActivityBottomNone: int32 = -1
    ActivityBottomAccount: int32 = 0
    ActivityBottomSettings: int32 = 1
    CodiconCodex: int32 = 0xEA65

fn leftPaneTabCount(): int32 =
    return 6

fn leftPaneTabIndex(tab: LeftPaneTab): int32 =
    return int32(tab)

fn leftPaneTabFromIndex(idx: int32): LeftPaneTab =
    if idx == 1:
        return lpSearch
    if idx == 2:
        return lpVcs
    if idx == 3:
        return lpRun
    if idx == 4:
        return lpExtensions
    if idx == 5:
        return lpCodex
    return lpExplorer

fn leftPaneTabLabel(tab: LeftPaneTab): str =
    if tab == lpSearch:
        return "SEARCH"
    if tab == lpVcs:
        return "SCM"
    if tab == lpRun:
        return "RUN"
    if tab == lpExtensions:
        return "EXTENSIONS"
    if tab == lpCodex:
        return "Codex"
    return "EXPLORER"

fn iconMaskEmpty(): IconMask =
    var mask: IconMask
    mask.w = 0
    mask.h = 0
    mask.data = default[int32[]]
    return mask

fn iconMaskValid(mask: IconMask): bool =
    return mask.w > 0 && mask.h > 0 && len(mask.data) == mask.w * mask.h

fn iconMaskByte(text: str, idx: int32): int32 =
    if idx < 0 || idx >= len(text):
        return 0
    return int32(ord(text[idx]))

fn iconMaskLe16(text: str, idx: int32): int32 =
    if idx < 0 || idx + 1 >= len(text):
        return -1
    let b0 = iconMaskByte(text, idx)
    let b1 = iconMaskByte(text, idx + 1)
    return b0 || (b1 << 8)

fn iconMaskLe32(text: str, idx: int32): int32 =
    if idx < 0 || idx + 3 >= len(text):
        return -1
    let b0 = iconMaskByte(text, idx)
    let b1 = iconMaskByte(text, idx + 1)
    let b2 = iconMaskByte(text, idx + 2)
    let b3 = iconMaskByte(text, idx + 3)
    return b0 || (b1 << 8) || (b2 << 16) || (b3 << 24)

fn iconMaskLoadBmp(path: str): IconMask =
    if len(path) == 0 || ! fileExists(path):
        return iconMaskEmpty()
    let content = readFile(path)
    if len(content) < 54:
        return iconMaskEmpty()
    if content[0] != 'B' || content[1] != 'M':
        return iconMaskEmpty()
    let pixelOffset = iconMaskLe32(content, 10)
    let width = iconMaskLe32(content, 18)
    var height = iconMaskLe32(content, 22)
    let planes = iconMaskLe16(content, 26)
    let bpp = iconMaskLe16(content, 28)
    let compression = iconMaskLe32(content, 30)
    if width <= 0 || height == 0 || pixelOffset <= 0:
        return iconMaskEmpty()
    if planes != 1 || bpp != 32:
        return iconMaskEmpty()
    if compression != 0 && compression != 3:
        return iconMaskEmpty()
    var topDown: bool = false
    if height < 0:
        topDown = true
        height = 0 - height
    let rowStride = width * 4
    let needed = pixelOffset + rowStride * height
    if needed > len(content):
        return iconMaskEmpty()
    var mask: IconMask
    mask.w = width
    mask.h = height
    var maskData: int32[width * height]
    mask.data = maskData
    for y in 0..<height:
        let srcY = if topDown: y else: height - 1 - y
        for x in 0..<width:
            let px = pixelOffset + srcY * rowStride + x * 4
            let alpha = iconMaskByte(content, px + 3)
            mask.data[y * width + x] = alpha
    return mask

fn guiCodexAssetPath(filename: str): str =
    if len(filename) == 0:
        return ""
    let resourceRoot = getEnv("CHENG_IDE_RESOURCE_ROOT")
    if len(resourceRoot) > 0:
        let candidate = joinPath(resourceRoot, "codex/" + filename)
        if fileExists(candidate):
            return candidate
    let projectRoot = getEnv("CHENG_IDE_ROOT")
    if len(projectRoot) > 0:
        let candidate = joinPath(projectRoot, "resources/codex/" + filename)
        if fileExists(candidate):
            return candidate
        let legacy = joinPath(projectRoot, "ide/resources/codex/" + filename)
        if fileExists(legacy):
            return legacy
    let fallback = joinPath("resources/codex", filename)
    if fileExists(fallback):
        return fallback
    let legacyFallback = joinPath("ide/resources/codex", filename)
    if fileExists(legacyFallback):
        return legacyFallback
    return ""

fn guiCodexIconPath(): str =
    let override = getEnv("CHENG_IDE_CODEX_ICON")
    if len(override) > 0 && fileExists(override):
        return override
    return guiCodexAssetPath("blossom-24.bmp")

fn guiCodexEditIconPath(): str =
    let override = getEnv("CHENG_IDE_CODEX_EDIT_ICON")
    if len(override) > 0 && fileExists(override):
        return override
    return guiCodexAssetPath("edit-16.bmp")

fn guiCodexCloseIconPath(): str =
    let override = getEnv("CHENG_IDE_CODEX_CLOSE_ICON")
    if len(override) > 0 && fileExists(override):
        return override
    return guiCodexAssetPath("close-16.bmp")

fn ensureCodexIconMask(): bool =
    if ! codexIconChecked:
        codexIconChecked = true
        let path = guiCodexIconPath()
        if len(path) > 0:
            codexIconMask = iconMaskLoadBmp(path)
    return iconMaskValid(codexIconMask)

fn ensureCodexEditIconMask(): bool =
    if ! codexEditIconChecked:
        codexEditIconChecked = true
        let path = guiCodexEditIconPath()
        if len(path) > 0:
            codexEditIconMask = iconMaskLoadBmp(path)
    return iconMaskValid(codexEditIconMask)

fn ensureCodexCloseIconMask(): bool =
    if ! codexCloseIconChecked:
        codexCloseIconChecked = true
        let path = guiCodexCloseIconPath()
        if len(path) > 0:
            codexCloseIconMask = iconMaskLoadBmp(path)
    return iconMaskValid(codexCloseIconMask)

fn useCodicons(): bool =
    if chengGuiNativeTextAvailable() == 0 || chengGuiIconFontAvailable() == 0:
        return false
    if ! iconFontChecked:
        iconFontChecked = true
        iconFontReady = false
        let glyph = codiconGlyph(CodiconFiles)
        if len(glyph) > 0:
            iconFontReady = chengGuiIconGlyphAvailable(glyph) != 0
    return iconFontReady

fn codiconGlyph(codepoint: int32): str =
    return utf8FromCodepoint(codepoint)

fn codiconLabel(icon: int32, label: str): str =
    if ! useCodicons():
        return label
    let glyph = codiconGlyph(icon)
    if len(glyph) == 0:
        return label
    return glyph + " " + label

fn useFileIcons(): bool =
    if ! fileIconsReady || chengGuiNativeTextAvailable() == 0 || chengGuiFileIconFontAvailable() == 0:
        return false
    if len(fileIconDefault.glyph) == 0:
        return false
    if ! fileIconFontChecked:
        fileIconFontChecked = true
        fileIconFontReady = false
        fileIconFontReady = chengGuiFileIconGlyphAvailable(fileIconDefault.glyph) != 0
    return fileIconFontReady

fn iconDebugLabel(layout: GuiLayout): str =
    if ! envFlagEnabled(getEnv("CHENG_IDE_DEBUG_ICONS"), false):
        return ""
    let iconGlyph = codiconGlyph(CodiconFiles)
    let iconAvail = if chengGuiIconFontAvailable() != 0: "1" else: "0"
    let iconUse = if useCodicons(): "1" else: "0"
    let iconLen = intToStr(len(iconGlyph))
    let iconOk = if len(iconGlyph) > 0 && chengGuiIconGlyphAvailable(iconGlyph) != 0: "1" else: "0"
    let iconW = if len(iconGlyph) > 0: intToStr(int32(chengGuiTextWidthIcon(iconGlyph, layout.smallFont))) else: "0"
    let fileGlyph = fileIconDefault.glyph
    let fileAvail = if chengGuiFileIconFontAvailable() != 0: "1" else: "0"
    let fileLen = intToStr(len(fileGlyph))
    let fileOk = if len(fileGlyph) > 0 && chengGuiFileIconGlyphAvailable(fileGlyph) != 0: "1" else: "0"
    let fileW = if len(fileGlyph) > 0: intToStr(int32(chengGuiTextWidthFileIcon(fileGlyph, layout.smallFont))) else: "0"
    let statusH = intToStr(layout.statusH)
    let scaleText = intToStr(int32(layout.scale * 10.0))
    return "icons cod=" + iconAvail + " use=" + iconUse + " ok=" + iconOk + " len=" + iconLen + " w=" + iconW + " file=" + fileAvail + " fok=" + fileOk + " flen=" + fileLen + " fw=" + fileW + " statusH=" + statusH + " s10=" + scaleText

fn fileIconEntryEmpty(): FileIconEntry =
    var entry: FileIconEntry
    entry.key = ""
    entry.glyph = ""
    entry.color = 0
    entry.hasColor = false
    return entry

fn fileIconDefIndex(defs: FileIconDef[], name: str): int32 =
    for idx in 0..<len(defs):
        if defs[idx].name == name:
            return idx
    return -1

fn fileIconEntryIndex(entries: FileIconEntry[], key: str): int32 =
    for idx in 0..<len(entries):
        if entries[idx].key == key:
            return idx
    return -1

fn setiHexDigit(ch: char): int32 =
    if ch >= '0' && ch <= '9':
        return int32(ord(ch) - ord('0'))
    if ch >= 'a' && ch <= 'f':
        return int32(ord(ch) - ord('a') + 10)
    if ch >= 'A' && ch <= 'F':
        return int32(ord(ch) - ord('A') + 10)
    return -1

fn setiHexByte(text: str, start: int32): int32 =
    if start < 0 || start + 1 >= len(text):
        return -1
    let hi = setiHexDigit(text[start])
    let lo = setiHexDigit(text[start + 1])
    if hi < 0 || lo < 0:
        return -1
    return hi * 16 + lo

fn setiParseHex(text: str): int32 =
    if len(text) == 0:
        return -1
    var value: int32 = 0
    for idx in 0..<len(text):
        let digit = setiHexDigit(text[idx])
        if digit < 0:
            return -1
        value = value * 16 + digit
    return value

fn setiParseColor(text: str, outColor: uint32*): bool =
    if text == nil || len(text) < 7:
        return false
    var start: int32 = 0
    if text[0] == '#':
        start = 1
    let hexLen: int32 = len(text) - start
    if hexLen != 6 && hexLen != 8:
        return false
    let r = setiHexByte(text, start)
    let g = setiHexByte(text, start + 2)
    let b = setiHexByte(text, start + 4)
    if r < 0 || g < 0 || b < 0:
        return false
    var a: int32 = 255
    if hexLen == 8:
        let aVal = setiHexByte(text, start + 6)
        if aVal >= 0:
            a = aVal
    *outColor = uint32((uint32(a) << 24) | (uint32(r) << 16) | (uint32(g) << 8) | uint32(b))
    return true

fn setiGlyphFromFontChar(text: str): str =
    if text == nil || len(text) == 0:
        return ""
    var start: int32 = 0
    if text[0] == '\\':
        start = 1
    if start >= len(text):
        return ""
    let hex = sliceRange(text, start, len(text) - 1)
    let codepoint: int32 = setiParseHex(hex)
    if codepoint <= 0:
        return ""
    return utf8FromCodepoint(codepoint)

fn resolveSetiThemePath(): str =
    let env = getEnv("CHENG_IDE_SETI_THEME")
    if len(env) > 0 && fileExists(env):
        return env
    let vscodeRoot = getEnv("CHENG_IDE_VSCODE_ROOT")
    if len(vscodeRoot) > 0:
        let candidate = joinPath(vscodeRoot, "extensions/theme-seti/icons/vs-seti-icon-theme.json")
        if fileExists(candidate):
            return candidate
    let defaultPath = "/Users/lbcheng/vscode/extensions/theme-seti/icons/vs-seti-icon-theme.json"
    if fileExists(defaultPath):
        return defaultPath
    return ""

fn fileIconEntryFromDef(key: str, def: FileIconDef): FileIconEntry =
    var entry: FileIconEntry
    entry.key = key
    entry.glyph = def.glyph
    entry.color = def.color
    entry.hasColor = def.hasColor
    return entry

fn addFileIconEntry(entries: FileIconEntry[]*, key: str, def: FileIconDef) =
    if len(key) == 0 || len(def.glyph) == 0:
        return
    if fileIconEntryIndex(*entries, key) >= 0:
        return
    entries->add(fileIconEntryFromDef(key, def))

fn loadSetiLanguageMappings(langIds: str[], langDefIdx: int32[]) =
    if len(langIds) == 0:
        return
    if ! loadSetiLanguageMapEnabled():
        return
    var vscodeRoot = getEnv("CHENG_IDE_VSCODE_ROOT")
    if len(vscodeRoot) == 0:
        vscodeRoot = "/Users/lbcheng/vscode"
    let extensionsDir = joinPath(vscodeRoot, "extensions")
    if ! dirExists(extensionsDir):
        return
    let items = walkDir(extensionsDir)
    for idx in 0..<items.len:
        let entry = get_WalkDirEntry(items, idx)
        let kind: PathComponent = entry[0]
        let path: str = entry[1]
        if kind == pcDir || kind == pcLinkToDir:
            let pkgPath = joinPath(path, "package.json")
            if fileExists(pkgPath):
                let content = readFile(pkgPath)
                if len(content) > 0:
                    let parsed: jparse.ParseResult = jparse.parseJsonSafe(content)
                    if parsed.ok:
                        let root = parsed.value
                        if root != nil && root.kind == json.JObject && root.hasKey("contributes"):
                            let contrib = root["contributes"]
                            if contrib != nil && contrib.kind == json.JObject && contrib.hasKey("languages"):
                                let langs = contrib["languages"]
                                if langs != nil && langs.kind == json.JArray:
                                    for lIdx in 0..<len(langs.a):
                                        let langNode = langs.a[lIdx]
                                        if langNode != nil && langNode.kind == json.JObject:
                                            let langId = jparse.getStringField(langNode, "id", "")
                                            if len(langId) > 0:
                                                for matchIdx in 0..<len(langIds):
                                                    if langIds[matchIdx] == langId:
                                                        defIdx = langDefIdx[matchIdx]
                                                        break
                                                if defIdx >= 0 && defIdx < len(fileIconDefs):
                                                    let def = fileIconDefs[defIdx]
                                                    if langNode.hasKey("extensions"):
                                                        let exts = langNode["extensions"]
                                                        if exts != nil && exts.kind == json.JArray:
                                                            for eIdx in 0..<len(exts.a):
                                                                let extNode = exts.a[eIdx]
                                                                if extNode != nil && extNode.kind == json.JString:
                                                                    var extText = textutils.toLowerAscii(extNode.getStr())
                                                                    if len(extText) > 0 && extText[0] == '.':
                                                                        extText = sliceFrom(extText, 1)
                                                                    addFileIconEntry(&fileIconExtEntries, extText, def)
                                                    if langNode.hasKey("filenames"):
                                                        let names = langNode["filenames"]
                                                        if names != nil && names.kind == json.JArray:
                                                            for nIdx in 0..<len(names.a):
                                                                let nameNode = names.a[nIdx]
                                                                if nameNode != nil && nameNode.kind == json.JString:
                                                                    let nameText = textutils.toLowerAscii(nameNode.getStr())
                                                                    addFileIconEntry(&fileIconNameEntries, nameText, def)

fn loadSetiIconTheme(themeName: str) =
    fileIconsLoaded = true
    fileIconsReady = false
    fileIconsThemeName = themeName
    fileIconDefs = default[FileIconDef[]]
    fileIconExtEntries = default[FileIconEntry[]]
    fileIconNameEntries = default[FileIconEntry[]]
    fileIconDefault = fileIconEntryEmpty()
    fileIconFontChecked = false
    fileIconFontReady = false
    fileIconCacheReady = false
    if chengGuiNativeTextAvailable() == 0 || chengGuiFileIconFontAvailable() == 0:
        return
    let path = resolveSetiThemePath()
    if len(path) == 0:
        return
    let content = readFile(path)
    if len(content) == 0:
        return
    let parsed: jparse.ParseResult = jparse.parseJsonSafe(content)
    if ! parsed.ok:
        return
    let root = parsed.value
    if root == nil || root.kind != json.JObject:
        return

    if root.hasKey("iconDefinitions"):
        let defsNode = root["iconDefinitions"]
        if defsNode != nil && defsNode.kind == json.JObject:
            for dIdx in 0..<len(defsNode.okeys):
                let defName = defsNode.okeys[dIdx]
                let defNode = defsNode.ovalues[dIdx]
                var glyph: str = ""
                var colorVal: uint32 = 0
                var hasColor: bool = false
                if defNode != nil && defNode.kind == json.JObject:
                    let fontChar = jparse.getStringField(defNode, "fontCharacter", "")
                    glyph = setiGlyphFromFontChar(fontChar)
                    let colorText = jparse.getStringField(defNode, "fontColor", "")
                    if setiParseColor(colorText, &colorVal):
                        hasColor = true
                if len(defName) > 0 && len(glyph) > 0:
                    var def: FileIconDef
                    def.name = defName
                    def.glyph = glyph
                    def.color = colorVal
                    def.hasColor = hasColor
                    fileIconDefs.add(def)

    var mappingNode = root
    if themeName == "light" && root.hasKey("light"):
        let lightNode = root["light"]
        if lightNode != nil && lightNode.kind == json.JObject:
            mappingNode = lightNode

    let defaultName = jparse.getStringField(mappingNode, "file", jparse.getStringField(root, "file", ""))
    if len(defaultName) > 0:
        var defIdx: int32 = fileIconDefIndex(fileIconDefs, defaultName)
        if defIdx < 0 && defaultName != "_default":
            defIdx = fileIconDefIndex(fileIconDefs, "_default")
        if defIdx >= 0:
            let def = fileIconDefs[defIdx]
            fileIconDefault = fileIconEntryFromDef("", def)

    if mappingNode.hasKey("fileExtensions"):
        let extNode = mappingNode["fileExtensions"]
        if extNode != nil && extNode.kind == json.JObject:
            for eIdx in 0..<len(extNode.okeys):
                let extKey = textutils.toLowerAscii(extNode.okeys[eIdx])
                let valueNode = extNode.ovalues[eIdx]
                if valueNode != nil && valueNode.kind == json.JString:
                    let defName = valueNode.getStr()
                    let defIdx = fileIconDefIndex(fileIconDefs, defName)
                    if defIdx >= 0:
                        addFileIconEntry(&fileIconExtEntries, extKey, fileIconDefs[defIdx])

    if mappingNode.hasKey("fileNames"):
        let nameNode = mappingNode["fileNames"]
        if nameNode != nil && nameNode.kind == json.JObject:
            for nIdx in 0..<len(nameNode.okeys):
                let nameKey = textutils.toLowerAscii(nameNode.okeys[nIdx])
                let valueNode = nameNode.ovalues[nIdx]
                if valueNode != nil && valueNode.kind == json.JString:
                    let defName = valueNode.getStr()
                    let defIdx = fileIconDefIndex(fileIconDefs, defName)
                    if defIdx >= 0:
                        addFileIconEntry(&fileIconNameEntries, nameKey, fileIconDefs[defIdx])

    var langIds: str[] = default[str[]]
    var langDefIdx: int32[] = default[int32[]]
    if mappingNode.hasKey("languageIds"):
        let langNode = mappingNode["languageIds"]
        if langNode != nil && langNode.kind == json.JObject:
            for lIdx in 0..<len(langNode.okeys):
                let langId = langNode.okeys[lIdx]
                let valueNode = langNode.ovalues[lIdx]
                if valueNode != nil && valueNode.kind == json.JString:
                    let defName = valueNode.getStr()
                    let defIdx = fileIconDefIndex(fileIconDefs, defName)
                    if defIdx >= 0:
                        langIds.add(langId)
                        langDefIdx.add(defIdx)
    if len(langIds) > 0 && loadSetiLanguageMapEnabled():
        loadSetiLanguageMappings(langIds, langDefIdx)

    let hasEntries: bool = len(fileIconDefault.glyph) > 0 || len(fileIconExtEntries) > 0 || len(fileIconNameEntries) > 0
    fileIconsReady = len(fileIconDefs) > 0 && hasEntries
    if fileIconsReady:
        fileIconCache = tables.TableInit[FileIconEntry](2048)
        fileIconCacheReady = true
        fileIconCacheTheme = themeName

fn ensureFileIconsLoaded(themeName: str) =
    if fileIconsLoaded && fileIconsThemeName == themeName:
        return
    loadSetiIconTheme(themeName)

fn fileIconEntryForName(name: str): FileIconEntry =
    if ! useFileIcons():
        return fileIconEntryEmpty()
    let lower = textutils.toLowerAscii(name)
    if fileIconCacheReady && fileIconsThemeName == fileIconCacheTheme:
        if tables.TableHas[FileIconEntry](fileIconCache, lower):
            return tables.TableGet[FileIconEntry](fileIconCache, lower)
    let directIdx = fileIconEntryIndex(fileIconNameEntries, lower)
    if directIdx >= 0:
        let entry = fileIconNameEntries[directIdx]
        if fileIconCacheReady:
            tables.TablePut[FileIconEntry](fileIconCache, lower, entry)
        return entry
    var best: FileIconEntry = fileIconEntryEmpty()
    var bestLen: int32 = -1
    for idx in 0..<len(fileIconExtEntries):
        let key: str = fileIconExtEntries[idx].key
        let keyLen: int32 = len(key)
        if keyLen > 0 && keyLen < len(lower):
            let start = len(lower) - keyLen
            if start > 0 && lower[start - 1] == '.':
                let tail = sliceRange(lower, start, len(lower) - 1)
                if tail == key && keyLen > bestLen:
                    best = fileIconExtEntries[idx]
                    bestLen = keyLen
    if len(best.glyph) > 0:
        if fileIconCacheReady:
            tables.TablePut[FileIconEntry](fileIconCache, lower, best)
        return best
    if len(fileIconDefault.glyph) > 0:
        if fileIconCacheReady:
            tables.TablePut[FileIconEntry](fileIconCache, lower, fileIconDefault)
        return fileIconDefault
    return fileIconEntryEmpty()

fn leftPaneTabGlyph(tab: LeftPaneTab): str =
    if useCodicons():
        if tab == lpSearch:
            return codiconGlyph(CodiconSearch)
        if tab == lpVcs:
            return codiconGlyph(CodiconSourceControl)
        if tab == lpRun:
            return codiconGlyph(CodiconRun)
        if tab == lpExtensions:
            return codiconGlyph(CodiconExtensions)
        if tab == lpCodex:
            return codiconGlyph(CodiconCodex)
        return codiconGlyph(CodiconFiles)
    if tab == lpSearch:
        return "S"
    if tab == lpVcs:
        return "G"
    if tab == lpRun:
        return "R"
    if tab == lpExtensions:
        return "X"
    if tab == lpCodex:
        return "C"
    return "E"

fn explorerChevronGlyph(isDir: bool, collapsed: bool): str =
    if ! isDir:
        return " "
    if useCodicons():
        if collapsed:
            return codiconGlyph(CodiconChevronRight)
        return codiconGlyph(CodiconChevronDown)
    if collapsed:
        return ">"
    return "v"

fn explorerItemGlyph(isDir: bool, collapsed: bool): str =
    if ! useCodicons():
        return ""
    if isDir:
        if collapsed:
            return codiconGlyph(CodiconFolder)
        return codiconGlyph(CodiconFolderOpened)
    return codiconGlyph(CodiconFile)

fn explorerHeaderActionCount(): int32 =
    return 4

fn explorerHeaderActionFromIndex(idx: int32): int32 =
    if idx == 0:
        return ExplorerActionNewFile
    if idx == 1:
        return ExplorerActionNewFolder
    if idx == 2:
        return ExplorerActionRefresh
    if idx == 3:
        return ExplorerActionCollapseAll
    return ExplorerActionNone

fn explorerHeaderActionName(kind: int32): str =
    if kind == ExplorerActionNewFile:
        return "new-file"
    if kind == ExplorerActionNewFolder:
        return "new-folder"
    if kind == ExplorerActionRefresh:
        return "refresh"
    if kind == ExplorerActionCollapseAll:
        return "collapse-all"
    return "none"

fn explorerHeaderActionGlyph(kind: int32): str =
    if useCodicons():
        if kind == ExplorerActionNewFile:
            return codiconGlyph(CodiconNewFile)
        if kind == ExplorerActionNewFolder:
            return codiconGlyph(CodiconNewFolder)
        if kind == ExplorerActionRefresh:
            return codiconGlyph(CodiconRefresh)
        if kind == ExplorerActionCollapseAll:
            return codiconGlyph(CodiconCollapseAll)
    if kind == ExplorerActionNewFile:
        return "+"
    if kind == ExplorerActionNewFolder:
        return "D"
    if kind == ExplorerActionRefresh:
        return "R"
    if kind == ExplorerActionCollapseAll:
        return "C"
    return ""

fn searchHeaderActionCount(): int32 =
    return 2

fn searchHeaderActionFromIndex(idx: int32): int32 =
    if idx == 0:
        return SearchActionFind
    if idx == 1:
        return SearchActionClear
    return SearchActionNone

fn searchHeaderActionName(kind: int32): str =
    if kind == SearchActionFind:
        return "find"
    if kind == SearchActionClear:
        return "clear"
    return "none"

fn searchHeaderActionGlyph(kind: int32): str =
    if useCodicons():
        if kind == SearchActionFind:
            return codiconGlyph(CodiconSearch)
        if kind == SearchActionClear:
            return codiconGlyph(CodiconClose)
    if kind == SearchActionFind:
        return "S"
    if kind == SearchActionClear:
        return "X"
    return ""

fn vcsHeaderActionCount(): int32 =
    return 4

fn vcsHeaderActionFromIndex(idx: int32): int32 =
    if idx == 0:
        return VcsActionRefresh
    if idx == 1:
        return VcsActionStageAll
    if idx == 2:
        return VcsActionUnstageAll
    if idx == 3:
        return VcsActionCommit
    return VcsActionNone

fn vcsHeaderActionName(kind: int32): str =
    if kind == VcsActionRefresh:
        return "refresh"
    if kind == VcsActionStageAll:
        return "stage-all"
    if kind == VcsActionUnstageAll:
        return "unstage-all"
    if kind == VcsActionCommit:
        return "commit"
    return "none"

fn vcsHeaderActionGlyph(kind: int32): str =
    if useCodicons():
        if kind == VcsActionRefresh:
            return codiconGlyph(CodiconRefresh)
        if kind == VcsActionStageAll:
            return codiconGlyph(CodiconDiffAdded)
        if kind == VcsActionUnstageAll:
            return codiconGlyph(CodiconDiffRemoved)
        if kind == VcsActionCommit:
            return codiconGlyph(CodiconCheck)
    if kind == VcsActionRefresh:
        return "R"
    if kind == VcsActionStageAll:
        return "+"
    if kind == VcsActionUnstageAll:
        return "-"
    if kind == VcsActionCommit:
        return "C"
    return ""

fn runActionCount(): int32 =
    return 5

fn runActionKind(idx: int32): str =
    if idx == 0:
        return "build"
    if idx == 1:
        return "run"
    if idx == 2:
        return "test"
    if idx == 3:
        return "package"
    return "diag"

fn runActionLabel(idx: int32): str =
    if idx == 0:
        return "Build Task"
    if idx == 1:
        return "Run Task"
    if idx == 2:
        return "Test Task"
    if idx == 3:
        return "Package"
    return "Diagnostics (Current File)"

fn runActionGlyph(idx: int32): str =
    if ! useCodicons():
        return ""
    if idx == 0:
        return codiconGlyph(CodiconTools)
    if idx == 1:
        return codiconGlyph(CodiconRun)
    if idx == 2:
        return codiconGlyph(CodiconBeaker)
    if idx == 3:
        return codiconGlyph(CodiconPackage)
    return codiconGlyph(CodiconWarning)

fn rightPaneTabCount(): int32 =
    return 6

fn rightPaneTabIndex(tab: RightPaneTab): int32 =
    return int32(tab)

fn rightPaneTabFromIndex(idx: int32): RightPaneTab =
    if idx == 1:
        return rpDiagnostics
    if idx == 2:
        return rpDebugger
    if idx == 3:
        return rpVcs
    if idx == 4:
        return rpTasks
    if idx == 5:
        return rpCodex
    return rpOutline

fn rightPaneTabLabel(tab: RightPaneTab): str =
    if tab == rpDiagnostics:
        return "PROBLEMS"
    if tab == rpDebugger:
        return "DEBUG"
    if tab == rpVcs:
        return "VCS"
    if tab == rpTasks:
        return "TASKS"
    if tab == rpCodex:
        return "Codex"
    return "OUTLINE"

fn rightPaneTabIcon(tab: RightPaneTab): str =
    if tab == rpDiagnostics:
        return codiconGlyph(CodiconWarning)
    if tab == rpDebugger:
        return codiconGlyph(CodiconDebug)
    if tab == rpVcs:
        return codiconGlyph(CodiconSourceControl)
    if tab == rpTasks:
        return codiconGlyph(CodiconTasklist)
    if tab == rpCodex:
        return codiconGlyph(CodiconOutput)
    return codiconGlyph(CodiconListTree)

fn rightPaneTabDisplay(tab: RightPaneTab): str =
    let label = rightPaneTabLabel(tab)
    if ! useCodicons():
        return label
    let icon = rightPaneTabIcon(tab)
    if len(icon) == 0:
        return label
    return icon + " " + label

fn bottomPaneTabCount(): int32 =
    return 4

fn bottomPaneTabIndex(tab: BottomPaneTab): int32 =
    return int32(tab)

fn bottomPaneTabFromIndex(idx: int32): BottomPaneTab =
    if idx == 1:
        return bpProblems
    if idx == 2:
        return bpOutput
    if idx == 3:
        return bpDebug
    return bpTerminal

fn bottomPaneTabLabel(tab: BottomPaneTab): str =
    if tab == bpProblems:
        return "PROBLEMS"
    if tab == bpOutput:
        return "OUTPUT"
    if tab == bpDebug:
        return "DEBUG CONSOLE"
    return "TERMINAL"

fn bottomPaneTabIcon(tab: BottomPaneTab): str =
    if tab == bpProblems:
        return codiconGlyph(CodiconWarning)
    if tab == bpOutput:
        return codiconGlyph(CodiconOutput)
    if tab == bpDebug:
        return codiconGlyph(CodiconDebugConsole)
    return codiconGlyph(CodiconTerminal)

fn bottomPaneTabDisplay(tab: BottomPaneTab): str =
    var icon: int32 = CodiconTerminal
    if tab == bpProblems:
        icon = CodiconWarning
    elif tab == bpOutput:
        icon = CodiconOutput
    elif tab == bpDebug:
        icon = CodiconDebugConsole
    return codiconLabel(icon, bottomPaneTabLabel(tab))

fn guiVcsPathFromLine(line: str): str =
    let raw = textutils.stripTrailing(line, {' ', '\t', '\r'})
    let trimmed = textutils.strip(raw)
    if len(raw) < 3:
        return ""
    if startsWithPrefix(trimmed, "## "):
        return ""
    if len(raw) <= 3:
        return ""
    var rest = sliceFrom(raw, 3)
    let arrowIdx: int32 = indexOfSubstr(rest, "->", 0)
    if arrowIdx >= 0:
        rest = sliceFrom(rest, arrowIdx + 2)
    return textutils.strip(rest)

fn guiVcsLineHasConflict(line: str): bool =
    if len(line) < 2:
        return false
    let c0: char = line[0]
    let c1: char = line[1]
    if c0 == '?' && c1 == '?':
        return false
    if c0 == 'U' || c1 == 'U':
        return true
    if (c0 == 'A' && c1 == 'A') || (c0 == 'D' && c1 == 'D'):
        return true
    return false

fn guiVcsDisplayLine(line: str): str =
    let path = guiVcsPathFromLine(line)
    if len(path) > 0:
        return path
    return textutils.strip(line)

fn guiVcsIconGlyph(line: str): str =
    if ! useCodicons():
        return ""
    if len(line) < 2:
        return ""
    let c0: char = line[0]
    let c1: char = line[1]
    if c0 == '?' && c1 == '?':
        return codiconGlyph(CodiconNewFile)
    if guiVcsLineHasConflict(line):
        return codiconGlyph(CodiconError)
    if c0 == 'A' || c1 == 'A':
        return codiconGlyph(CodiconDiffAdded)
    if c0 == 'D' || c1 == 'D':
        return codiconGlyph(CodiconDiffRemoved)
    if c0 == 'R' || c1 == 'R':
        return codiconGlyph(CodiconDiffRenamed)
    if c0 == 'M' || c1 == 'M':
        return codiconGlyph(CodiconDiffModified)
    return codiconGlyph(CodiconDiff)

fn guiVcsIconColor(line: str, theme: GuiTheme): uint32 =
    if len(line) < 2:
        return theme.subText
    let c0: char = line[0]
    let c1: char = line[1]
    if c0 == '?' && c1 == '?':
        return theme.diagInfo
    if guiVcsLineHasConflict(line):
        return theme.diagError
    if c0 == 'A' || c1 == 'A':
        return theme.diagInfo
    if c0 == 'D' || c1 == 'D':
        return theme.diagError
    if c0 == 'R' || c1 == 'R':
        return theme.diagInfo
    if c0 == 'M' || c1 == 'M':
        return theme.diagWarning
    return theme.subText

fn guiDiagIconGlyph(sev: diag.GuiDiagSeverity): str =
    if ! useCodicons():
        return ""
    if sev == diag.gdsError:
        return codiconGlyph(CodiconError)
    if sev == diag.gdsWarning:
        return codiconGlyph(CodiconWarning)
    return codiconGlyph(CodiconInfo)

fn statusDiagLabel(errors, warnings, infos: int32): str =
    if useCodicons():
        let errGlyph = codiconGlyph(CodiconError)
        let warnGlyph = codiconGlyph(CodiconWarning)
        let infoGlyph = codiconGlyph(CodiconInfo)
        return errGlyph + intToStr(errors) + " " + warnGlyph + intToStr(warnings) + " " + infoGlyph + intToStr(infos)
    return "E:" + intToStr(errors) + " W:" + intToStr(warnings) + " I:" + intToStr(infos)

fn statusVcsLabel(branch: str, count: int32): str =
    let base = if len(branch) > 0: branch else: "git"
    let label = base + " (" + intToStr(count) + ")"
    if useCodicons():
        let icon = codiconGlyph(CodiconSourceControl)
        if len(icon) > 0:
            return icon + " " + label
    return label

type
    VcsCounts =
        staged: int32
        unstaged: int32
        untracked: int32
        conflicts: int32

type
    NativeSurfaceInfo =
        logicalWidth: float64
        logicalHeight: float64
        pixelWidth: float64
        pixelHeight: float64
        scale: float64
        colorSpace: cstring

const
    defaultGuiWidth: int32 = 1280
    defaultGuiHeight: int32 = 800
    DefaultExplorerMax: int32 = 20000
    TabSize: int32 = 4
    ColorBackground: uint32 = 0xFF1E1E1E
    ColorPanel: uint32 = 0xFF252526
    ColorPanelAlt: uint32 = 0xFF2D2D2D
    ColorEditor: uint32 = 0xFF1E1E1E
    ColorHeader: uint32 = 0xFF3C3C3C
    ColorStatus: uint32 = 0xFF007ACC
    ColorBorder: uint32 = 0xFF303031
    ColorText: uint32 = 0xFFD4D4D4
    ColorSubText: uint32 = 0xFFA6A6A6
    ColorAccent: uint32 = 0xFF007ACC
    ColorSelection: uint32 = 0xFF264F78
    ColorFind: uint32 = 0xFF515C6A
    ColorKeyword: uint32 = 0xFFC586C0
    ColorType: uint32 = 0xFF4EC9B0
    ColorString: uint32 = 0xFFCE9178
    ColorNumber: uint32 = 0xFFB5CEA8
    ColorComment: uint32 = 0xFF6A9955
    ColorLineHighlight: uint32 = 0xFF2A2D2E
    ColorIndentGuide: uint32 = 0xFF404040
    ColorDiagError: uint32 = 0xFFF14C4C
    ColorDiagWarning: uint32 = 0xFFCCA700
    ColorDiagInfo: uint32 = 0xFF3794FF
    WorkspaceStateDir: str = "build/ide"
    WorkspaceStateFile: str = "workspace_state.txt"
    DesktopBridgeFile: str = "desktop_bridge.txt"
    DesktopCommandFile: str = "desktop_command.txt"
    DesktopCommandAckFile: str = "desktop_command_ack.txt"
    WorkspaceConfigFile: str = "workspace_config.txt"
    RecoveryDirName: str = "recovery"
    IdeBridgeSchemaVersion: str = "1"
    IdeCommandSchemaVersion: str = "1"
    IdeVersionDefault: str = "0.1.0"
    IdeBridgeCapabilities: str = "workspace,diagnostics,tasks,status,commands"
    MaxWorkspaceFiles: int32 = 32
    MaxWorkspaceCollapsed: int32 = 64
    MaxWorkspaceTerminals: int32 = 16
    MaxDesktopBridgeOpen: int32 = 12
    MaxDesktopBridgeTaskLine: int32 = 200
    MaxWorkspaceConfigEntries: int32 = 64
    MaxTerminalLines: int32 = 200
    MaxTaskLogLines: int32 = 120
    MaxVcsLines: int32 = 120
    MaxUndoEntries: int32 = 200
    MaxSelectionHistory: int32 = 32
    SyntaxTokenCacheMaxEntries: int32 = 4096
    AutoDiagCooldownFrames: int32 = 12
    AutoSaveCooldownFrames: int32 = 24
    RecoveryCooldownFrames: int32 = 60
    MaxRefOutput: int32 = 160
    MaxSearchOutput: int32 = 200
    LargeFileLineLimit: int32 = 20000
    LargeFileByteLimit: int32 = 2000000
    RecoveryMaxBytes: int32 = 2000000

var nextBufferId: int32 = 1
var syntaxTokenCacheBufferId: int32 = -1
var syntaxTokenCacheTick: int32 = 0
var syntaxTokenCache: SyntaxTokenCacheEntry[]
var visibleLineCacheBufferId: int32 = -1
var visibleLineCacheVersion: int32 = -1
var visibleLineCacheLines: int32[]
var visibleLineCacheRows: int32[]
var fileIconDefs: FileIconDef[]
var fileIconExtEntries: FileIconEntry[]
var fileIconNameEntries: FileIconEntry[]
var fileIconDefault: FileIconEntry
var fileIconsLoaded: bool = false
var fileIconsReady: bool = false
var fileIconsThemeName: str = ""
var iconFontChecked: bool = false
var iconFontReady: bool = false
var fileIconFontChecked: bool = false
var fileIconFontReady: bool = false
var fileIconCache: tables.Table[FileIconEntry] = tables.TableInit[FileIconEntry](2048)
var fileIconCacheReady: bool = false
var fileIconCacheTheme: str = ""
var codexIconChecked: bool = false
var codexIconMask: IconMask
var codexEditIconChecked: bool = false
var codexEditIconMask: IconMask
var codexCloseIconChecked: bool = false
var codexCloseIconMask: IconMask

fn defaultDarkTheme(): GuiTheme =
    var theme: GuiTheme
    theme.name = "dark"
    # VS Code Dark+ Colors (Hex ARGB)
    theme.background = 0xFF252526
    theme.panel = 0xFF252526      # Sidebar / Tab Bar
    theme.panelAlt = 0xFF2D2D2D   # Inactive Tabs / Panel Headers
    theme.tabActive = 0xFF1E1E1E  # tab.activeBackground
    theme.tabInactive = 0xFF2D2D2D
    theme.activityBar = 0xFF333333
    theme.editor = 0xFF1E1E1E
    theme.header = 0xFF3C3C3C     # Title Bar
    theme.status = 0xFF007ACC     # Status Bar (Blue)
    theme.statusBarFg = 0xFFFFFFFF
    theme.border = 0xFF303031     # Borders
    theme.text = 0xFFD4D4D4       # Foreground
    theme.subText = 0xFFBBBBBB    # Secondary text
    theme.accent = 0xFF007ACC     # Focus/Accent
    theme.selection = 0xFF264F78  # Selection (Blueish)
    theme.find = 0xFF515C6A
    theme.keyword = 0xFFC586C0    # Purple
    theme.typeColor = 0xFF4EC9B0  # Teal
    theme.stringColor = 0xFFCE9178 # Orange
    theme.number = 0xFFB5CEA8     # Green
    theme.comment = 0xFF6A9955    # Green
    theme.lineHighlight = 0xFF2A2D2E
    theme.indentGuide = 0xFF404040
    theme.diagError = 0xFFF14C4C
    theme.diagWarning = 0xFFCCA700
    theme.diagInfo = 0xFF3794FF

    return theme

fn defaultLightTheme(): GuiTheme =
    var theme: GuiTheme
    theme.name = "light"
    theme.background = 0xFFF5F5F5
    theme.panel = 0xFFE7E7E7
    theme.panelAlt = 0xFFF0F0F0
    theme.tabActive = 0xFFFFFFFF
    theme.tabInactive = 0xFFF0F0F0
    theme.activityBar = 0xFFE1E1E1
    theme.editor = 0xFFFFFFFF
    theme.header = 0xFFE1E1E1
    theme.status = 0xFF2D6CDF
    theme.statusBarFg = 0xFFFFFFFF
    theme.border = 0xFFD0D0D0
    theme.text = 0xFF1E1E1E
    theme.subText = 0xFF5A5A5A
    theme.accent = 0xFF2D6CDF
    theme.selection = 0x403D7BFF
    theme.find = 0x80609BFF
    theme.keyword = 0xFF0000B0
    theme.typeColor = 0xFF267F99
    theme.stringColor = 0xFFA31515
    theme.number = 0xFF098658
    theme.comment = 0xFF008000
    theme.lineHighlight = 0xFFF0F4FA
    theme.indentGuide = 0x40B5B5B5
    theme.diagError = 0xFFCC3333
    theme.diagWarning = 0xFFB8860B
    theme.diagInfo = 0xFF1E6BD6
    return theme

fn normalizeThemeName(name: str): str =
    let lowered = textutils.toLowerAscii(textutils.strip(name))
    if lowered == "light" || lowered == "day" || lowered == "light+" || lowered == "vscode-light" || lowered == "vscode light":
        return "light"
    if lowered == "dark+" || lowered == "darkplus" || lowered == "vscode" || lowered == "vscode-dark" || lowered == "vscode dark":
        return "dark"
    return "dark"

fn guiSetThemeInternal(state: GuiState, name: str, announce: bool): GuiState =
    let normalized = normalizeThemeName(name)
    state.themeName = normalized
    if normalized == "light":
        state.theme = defaultLightTheme()
    else:
        state.theme = defaultDarkTheme()
    if announce:
        state.statusMsg = "theme: " + normalized
    return state

fn guiSetTheme(state: GuiState, name: str): GuiState =
    return guiSetThemeInternal(state, name, true)

fn guiSetThemeSilent(state: GuiState, name: str): GuiState =
    return guiSetThemeInternal(state, name, false)

fn guiToggleTheme(state: GuiState): GuiState =
    let nextName = if compareStrings(state.themeName, "light") == 0: "dark" else: "light"
    return guiSetTheme(state, nextName)

fn guiSetAutoSave(state: GuiState, enabled: bool): GuiState =
    state.autoSave = enabled
    state.autoSavePending = false
    state.autoSaveCooldown = 0
    if enabled:
        state.recoveryPending = false
        state.recoveryCooldown = 0
    if enabled:
        state.statusMsg = "autosave: on"
    else:
        state.statusMsg = "autosave: off"
    return guiWorkspaceStateSave(state)

fn guiToggleAutoSave(state: GuiState): GuiState =
    return guiSetAutoSave(state, ! state.autoSave)

fn guiSetAutoSaveFromInput(state: GuiState, input: str): GuiState =
    let lowered = textutils.toLowerAscii(trimLine(input))
    if len(lowered) == 0:
        return guiToggleAutoSave(state)
    if lowered == "1" || lowered == "true" || lowered == "on" || lowered == "yes":
        return guiSetAutoSave(state, true)
    if lowered == "0" || lowered == "false" || lowered == "off" || lowered == "no":
        return guiSetAutoSave(state, false)
    state.statusMsg = "autosave: invalid"
    return state

fn guiSetFormatOnSave(state: GuiState, enabled: bool): GuiState =
    state.formatOnSave = enabled
    if enabled:
        state.statusMsg = "format-on-save: on"
    else:
        state.statusMsg = "format-on-save: off"
    return guiWorkspaceStateSave(state)

fn guiToggleFormatOnSave(state: GuiState): GuiState =
    return guiSetFormatOnSave(state, ! state.formatOnSave)

fn guiSetFormatOnSaveFromInput(state: GuiState, input: str): GuiState =
    let lowered = textutils.toLowerAscii(trimLine(input))
    if len(lowered) == 0:
        return guiToggleFormatOnSave(state)
    if lowered == "1" || lowered == "true" || lowered == "on" || lowered == "yes":
        return guiSetFormatOnSave(state, true)
    if lowered == "0" || lowered == "false" || lowered == "off" || lowered == "no":
        return guiSetFormatOnSave(state, false)
    state.statusMsg = "format-on-save: invalid"
    return state

fn guiToggleSplit(state: GuiState): GuiState =
    state.editor = toggleEditorSplit(state.editor)
    state.statusMsg = if state.editor.splitActive: "split: on" else: "split: off"
    return state

fn guiSetSplit(state: GuiState, enabled: bool): GuiState =
    if enabled:
        if ! state.editor.splitActive:
            return guiToggleSplit(state)
        state.statusMsg = "split: on"
        return state
    if state.editor.splitActive:
        return guiToggleSplit(state)
    state.statusMsg = "split: off"
    return state

fn guiSetSplitFromInput(state: GuiState, input: str): GuiState =
    let lowered = textutils.toLowerAscii(trimLine(input))
    if len(lowered) == 0:
        return guiToggleSplit(state)
    if lowered == "1" || lowered == "true" || lowered == "on" || lowered == "yes":
        return guiSetSplit(state, true)
    if lowered == "0" || lowered == "false" || lowered == "off" || lowered == "no":
        return guiSetSplit(state, false)
    if lowered == "toggle":
        return guiToggleSplit(state)
    state.statusMsg = "split: invalid"
    return state

fn guiClearHover(state: GuiState): GuiState =
    state.hoverActive = false
    state.hoverText = ""
    state.hoverLine = -1
    state.hoverCol = -1
    state.hoverTab = -1
    state.hoverTabClose = false
    state.hoverTabControl = TabControlNone
    state.hoverExplorerAction = ExplorerActionNone
    state.hoverSearchAction = SearchActionNone
    state.hoverVcsAction = VcsActionNone
    state.hoverLeftPaneTab = -1
    state.hoverLeftPaneRow = -1
    state.hoverRightPaneRow = -1
    state.hoverBottomPaneRow = -1
    state.hoverRightPaneTab = -1
    state.hoverBottomPaneTab = -1
    state.hoverActivityBottom = ActivityBottomNone
    return state

fn guiClearSignature(state: GuiState): GuiState =
    state.signatureActive = false
    state.signatureText = ""
    return state

fn guiPsQuote(text: str): str =
    var quoted: str = "'"
    for i in 0..<len(text):
        let ch: char = text[i]
        if ch == '\'':
            quoted = quoted + "''"
        else:
            quoted = quoted + $ ch
    return quoted + "'"

fn guiIsWindows(): bool =
    let defines = textutils.toLowerAscii(getEnv("CHENG_DEFINES"))
    if indexOfSubstr(defines, "windows", 0) >= 0:
        return true
    let osName = textutils.toLowerAscii(getEnv("OS"))
    if indexOfSubstr(osName, "windows", 0) >= 0:
        return true
    let ostype = textutils.toLowerAscii(getEnv("OSTYPE"))
    if indexOfSubstr(ostype, "msys", 0) >= 0 || indexOfSubstr(ostype, "cygwin", 0) >= 0:
        return true
    return false

fn guiIsMac(): bool =
    let defines = textutils.toLowerAscii(getEnv("CHENG_DEFINES"))
    if indexOfSubstr(defines, "macos", 0) >= 0 || indexOfSubstr(defines, "macosx", 0) >= 0:
        return true
    let ostype = textutils.toLowerAscii(getEnv("OSTYPE"))
    if indexOfSubstr(ostype, "darwin", 0) >= 0 || indexOfSubstr(ostype, "mac", 0) >= 0:
        return true
    return false

fn guiTempDir(): str =
    let tmpdir = getEnv("TMPDIR")
    if len(tmpdir) > 0:
        return tmpdir
    let temp = getEnv("TEMP")
    if len(temp) > 0:
        return temp
    let tmp = getEnv("TMP")
    if len(tmp) > 0:
        return tmp
    if guiIsWindows():
        let home = getEnv("USERPROFILE")
        if len(home) > 0:
            return home
        return "."
    return "/tmp"

fn guiClipboardTempPath(): str =
    let override = getEnv("CHENG_IDE_CLIPBOARD_TMP")
    if len(override) > 0:
        return override
    let tempDir = guiTempDir()
    if len(tempDir) > 0:
        return joinPath(tempDir, "cheng_ide_clipboard.txt")
    return ".cheng_ide_clipboard.txt"

fn guiClipboardWriteTemp(text: str): str =
    let path = guiClipboardTempPath()
    writeFile(path, text)
    return path

fn guiClipboardCleanupTemp(path: str) =
    if len(path) == 0:
        return
    if fileExists(path):
        removeFile(path)

fn guiClipboardCommandWithFile(tmpl: str, filePath: str): str =
    let quoted = guiShellQuote(filePath)
    if indexOfSubstr(tmpl, "{file}", 0) >= 0:
        return guiReplaceAllText(tmpl, "{file}", quoted)
    return tmpl + " " + quoted

fn guiClipboardTryCommand(cmd: str, workDir: str): bool =
    if len(cmd) == 0:
        return false
    let result: ExecCmdResult = execCmdEx(cmd, {poStdErrToStdOut}, workDir)
    return result.exitCode == 0

fn guiClipboardTryGet(cmd: str, workDir: str): ClipboardResult =
    var clip: ClipboardResult
    if len(cmd) == 0:
        return clip
    let result: ExecCmdResult = execCmdEx(cmd, {poStdErrToStdOut}, workDir)
    if result.exitCode == 0:
        clip.ok = true
        clip.text = result.output
    return clip

fn guiClipboardSetSystem(text: str): bool =
    let custom = getEnv("CHENG_IDE_CLIPBOARD_SET")
    let workDir = getCurrentDir()
    let tempPath = guiClipboardWriteTemp(text)
    var ok: bool = false
    if len(custom) > 0:
        let cmd = guiClipboardCommandWithFile(custom, tempPath)
        ok = guiClipboardTryCommand(cmd, workDir)
    else:
        if guiIsMac():
            let cmd = guiClipboardCommandWithFile("pbcopy < {file}", tempPath)
            ok = guiClipboardTryCommand(cmd, workDir)
        elif guiIsWindows():
            let cmd = "powershell -NoProfile -Command \"Set-Clipboard -Value (Get-Content -Raw -LiteralPath " + guiPsQuote(tempPath) + ")\""
            ok = guiClipboardTryCommand(cmd, workDir)
        else:
            let cmd1 = guiClipboardCommandWithFile("wl-copy < {file}", tempPath)
            ok = guiClipboardTryCommand(cmd1, workDir)
            if ! ok:
                let cmd2 = guiClipboardCommandWithFile("xclip -selection clipboard -i {file}", tempPath)
                ok = guiClipboardTryCommand(cmd2, workDir)
            if ! ok:
                let cmd3 = guiClipboardCommandWithFile("xsel --clipboard --input < {file}", tempPath)
                ok = guiClipboardTryCommand(cmd3, workDir)
    guiClipboardCleanupTemp(tempPath)
    return ok

fn guiClipboardGetSystem(): ClipboardResult =
    let custom = getEnv("CHENG_IDE_CLIPBOARD_GET")
    let workDir = getCurrentDir()
    if len(custom) > 0:
        var res: ClipboardResult = guiClipboardTryGet(custom, workDir)
        if res.ok:
            return res
    if guiIsMac():
        return guiClipboardTryGet("pbpaste", workDir)
    if guiIsWindows():
        return guiClipboardTryGet("powershell -NoProfile -Command \"Get-Clipboard\"", workDir)
    var res: ClipboardResult = guiClipboardTryGet("wl-paste -n", workDir)
    if res.ok:
        return res
    res = guiClipboardTryGet("xclip -selection clipboard -o", workDir)
    if res.ok:
        return res
    return guiClipboardTryGet("xsel --clipboard --output", workDir)

fn guiCopySelection(state: GuiState): GuiState =
    let text = selectionText(state.editor)
    if len(text) == 0:
        state.statusMsg = "copy: empty"
        return state
    state.clipboard = text
    let sysOk: bool = guiClipboardSetSystem(text)
    let suffix = if sysOk: "" else: " (internal)"
    state.statusMsg = "copy: " + intToStr(len(text)) + " chars" + suffix
    return state

fn guiCutSelection(state: GuiState): GuiState =
    let text = selectionText(state.editor)
    if len(text) == 0:
        state.statusMsg = "cut: empty"
        return state
    state.clipboard = text
    let sysOk: bool = guiClipboardSetSystem(text)
    state.editor = editorBackspace(state.editor)
    state = guiSetDiagnosticsDirty(state)
    let suffix = if sysOk: "" else: " (internal)"
    state.statusMsg = "cut: " + intToStr(len(text)) + " chars" + suffix
    return state

fn guiPasteClipboard(state: GuiState): GuiState =
    var text: str = state.clipboard
    let sysRes: ClipboardResult = guiClipboardGetSystem()
    let suffix = if sysRes.ok: "" else: " (internal)"
    if sysRes.ok:
        text = sysRes.text
        state.clipboard = text
    if len(text) == 0:
        state.statusMsg = "paste: empty"
        return state
    state.editor = editorInsertText(state.editor, text)
    state = guiSetDiagnosticsDirty(state)
    state.statusMsg = "paste: " + intToStr(len(text)) + " chars" + suffix
    return state

fn guiUndo(state: GuiState): GuiState =
    if seqLenString(state.editor.undoStack) == 0:
        state.statusMsg = "undo: empty"
        return state
    state.editor = undoEditor(state.editor)
    state = guiSetDiagnosticsDirty(state)
    state.statusMsg = "undo"
    return state

fn guiRedo(state: GuiState): GuiState =
    if seqLenString(state.editor.redoStack) == 0:
        state.statusMsg = "redo: empty"
        return state
    state.editor = redoEditor(state.editor)
    state = guiSetDiagnosticsDirty(state)
    state.statusMsg = "redo"
    return state

const demoFiles = "src/\n  main.cheng\n  cheng-gui/app.cheng\n  cheng-gui/runtime.cheng\n  cheng-gui/render/text_native.cheng\n  std/system.cheng\n  cheng/tooling/bootstrap_pure.sh\n"
const demoCode = "fn main() =\n  let msg = \"Hello Cheng\"\n  if msg.len > 0:\n    echo msg\n  else:\n    echo \"(empty)\"\n\nproc fib(n: int): int =\n  if n <= 1:\n    return n\n  return fib(n - 1) + fib(n - 2)\n"

const
    ModShiftMac: uint32 = 0x20000
    ModCtrlMac: uint32 = 0x40000
    ModAltMac: uint32 = 0x80000
    ModMetaMac: uint32 = 0x100000
    ModShiftWin: uint32 = 0x1
    ModCtrlWin: uint32 = 0x2
    ModAltWin: uint32 = 0x4
    ModMetaWin: uint32 = 0x8
    ModShiftX11: uint32 = 0x1
    ModCtrlX11: uint32 = 0x4
    ModAltX11: uint32 = 0x8
    ModMetaX11: uint32 = 0x40

fn defaultHeadlessOptions(): HeadlessOptions =
    var options: HeadlessOptions
    options.mode = hmDefault
    options.enableRemote = false
    options.remoteTransport = ""
    options.remoteLatencyBudgetMs = 0.0
    options.remoteBandwidthMbps = 0.0
    options.remoteJitterBudgetMs = 0.0
    options.remoteDropRatePercent = 0.0
    return options

fn parseHeadlessMode(value: str): HeadlessMode =
    let lowered = textutils.toLowerAscii(textutils.strip(value))
    if lowered == "desktop":
        return hmDesktop
    if lowered == "mobile":
        return hmMobile
    if lowered == "web":
        return hmWeb
    return hmDefault

fn describeGuiEnvironmentCandidate(candidate: str): str =
    let trimmed = textutils.strip(candidate)
    if len(trimmed) == 0:
        return "[gui] environment: unavailable (stub)\n"
    return "[gui] environment for " + trimmed + ": unavailable (stub)\n"

fn describeGuiEnvironment(): str =
    return describeGuiEnvironmentCandidate("")

fn runHeadlessDemo(steps: int, resourceRoot: str, metricsPath: str, commandPath: str, analysisView: str, options: HeadlessOptions): str =
    metricsPath
    commandPath
    analysisView
    options
    var count: int = steps
    if count <= 0:
        count = 1
    let root = if len(resourceRoot) == 0: "<empty>" else: resourceRoot
    return "[gui-headless] steps=" + intToStr(int32(count)) + " resource=" + root + " (stub)\n"

fn buildGuiBundleSimple(rawOutputDir: str, resourceRoot: str, frames: int, kind: str): GuiBuildResult =
    return buildGuiBundle(rawOutputDir, resourceRoot, frames, kind, "", "")

fn buildGuiBundleWithRelease(rawOutputDir: str, resourceRoot: str, frames: int, kind: str, releaseTag: str): GuiBuildResult =
    return buildGuiBundle(rawOutputDir, resourceRoot, frames, kind, releaseTag, "")

fn buildGuiBundle(rawOutputDir: str, resourceRoot: str, frames: int, kind: str, releaseTag: str, defaultOutputDir: str): GuiBuildResult =
    rawOutputDir
    resourceRoot
    frames
    kind
    releaseTag
    defaultOutputDir
    var result: GuiBuildResult
    result.ok = false
    result.summary = "[gui-bundle] not implemented (stub)\n"
    return result

fn minInt(a, b: int32): int32 =
    if a < b:
        return a
    return b

fn maxInt(a, b: int32): int32 =
    if a > b:
        return a
    return b

fn clampInt(value, minVal, maxVal: int32): int32 =
    if value < minVal:
        return minVal
    if value > maxVal:
        return maxVal
    return value

fn seqLenString(seqInst: str[]): int32 =
    let p: int32* = int32*(&seqInst)
    return *p

fn addPtr_string(seqInst: str[]*, val: str) =
    addPtr_str(seqInst, val)

fn get_string(seqInst: str[], idx: int32): str =
    return get_str(seqInst, idx)

fn seqGetString(seqInst: str[], idx: int32): str =
    return get_str(seqInst, idx)

fn seqSetString(seqInst: str[]*, idx: int32, val: str) =
    setStringAt(seqInst, idx, val)

fn seqInsertString(seqInst: str[]*, idx: int32, val: str) =
    insert(seqInst, val, idx)

fn seqDeleteString(seqInst: str[]*, idx: int32) =
    delete(seqInst, idx)

fn seqDeleteInt32(seqInst: int32[]*, idx: int32) =
    if idx < 0 || idx >= seqInst->len:
        return
    var j: int32 = idx
    while j + 1 < seqInst->len:
        (*seqInst)[j] = (*seqInst)[j + 1]
        j = j + 1
    seqInst->len = seqInst->len - 1

fn seqLenCursor(list: CursorList): int32 =
    return list.len

fn seqGetCursor(list: CursorList, idx: int32): CursorPos =
    var idx64: int64 = int64(idx)
    var offset64: int64 = idx64 * sizeof(CursorPos)
    var offset32: int32 = int32(offset64)
    let p: void* = ptr_add(list.buffer, offset32)
    let pt: CursorPos* = CursorPos*(p)
    return *pt

fn seqSetCursor(list: CursorList*, idx: int32, val: CursorPos) =
    var idx64: int64 = int64(idx)
    var offset64: int64 = idx64 * sizeof(CursorPos)
    var offset32: int32 = int32(offset64)
    let p: void* = ptr_add(list->buffer, offset32)
    let pt: CursorPos* = CursorPos*(p)
    *pt = val

fn addPtr_cursor(list: CursorList*, val: CursorPos) =
    if list->len >= list->cap:
        var newCap: int32 = 4
        if list->cap != 0:
            newCap = list->cap * 2
        list->cap = newCap
        var cap64: int64 = int64(newCap)
        var size64: int64 = int64(cap64 * sizeof(CursorPos))
        var size32: int32 = int32(size64)
        list->buffer = realloc(list->buffer, size32)
    var idx64: int64 = int64(list->len)
    var offset64: int64 = int64(idx64 * sizeof(CursorPos))
    var offset32: int32 = int32(offset64)
    let p: void* = ptr_add(list->buffer, offset32)
    let pt: CursorPos* = CursorPos*(p)
    *pt = val
    list->len = list->len + 1

fn seqDeleteCursor(list: CursorList*, idx: int32) =
    if idx < 0 || idx >= list->len:
        return
    var i: int32 = idx
    while i + 1 < list->len:
        let nextVal: CursorPos = seqGetCursor(*list, i + 1)
        seqSetCursor(list, i, nextVal)
        i = i + 1
    list->len = list->len - 1

fn newCursorList(): CursorList =
    var list: CursorList
    list.len = 0
    list.cap = 0
    list.buffer = nil
    return list

fn bufferLen(list: BufferList): int32 =
    return list.len

fn bufferGet(list: BufferList, idx: int32): EditorState =
    var idx64: int64 = int64(idx)
    var offset64: int64 = idx64 * sizeof(EditorState)
    var offset32: int32 = int32(offset64)
    let p: void* = ptr_add(list.buffer, offset32)
    let pt: EditorState* = EditorState*(p)
    return *pt

fn bufferSet(list: BufferList*, idx: int32, val: EditorState) =
    var idx64: int64 = int64(idx)
    var offset64: int64 = idx64 * sizeof(EditorState)
    var offset32: int32 = int32(offset64)
    let p: void* = ptr_add(list->buffer, offset32)
    let pt: EditorState* = EditorState*(p)
    *pt = val

fn bufferEnsureCap(list: BufferList*, need: int32) =
    if need <= list->cap:
        return
    var newCap: int32 = 4
    if list->cap > 0:
        newCap = list->cap * 2
    while newCap < need:
        newCap = newCap * 2
    list->cap = newCap
    var cap64: int64 = int64(newCap)
    var size64: int64 = int64(cap64 * sizeof(EditorState))
    var size32: int32 = int32(size64)
    if list->buffer == nil:
        list->buffer = alloc(size32)
    else:
        list->buffer = realloc(list->buffer, size32)

fn bufferInsert(list: BufferList*, idx: int32, val: EditorState) =
    var insertIdx: int32 = idx
    if insertIdx < 0:
        insertIdx = 0
    if insertIdx > list->len:
        insertIdx = list->len
    bufferEnsureCap(list, list->len + 1)
    var i: int32 = list->len
    while i > insertIdx:
        let prev: EditorState = bufferGet(*list, i - 1)
        bufferSet(list, i, prev)
        i = i - 1
    bufferSet(list, insertIdx, val)
    list->len = list->len + 1

fn bufferDelete(list: BufferList*, idx: int32) =
    if idx < 0 || idx >= list->len:
        return
    for i in idx..<list->len - 1:
        let nextVal: EditorState = bufferGet(*list, i + 1)
        bufferSet(list, i, nextVal)
    list->len = list->len - 1

fn newBufferList(): BufferList =
    var list: BufferList
    list.len = 0
    list.cap = 0
    list.buffer = nil
    return list

fn terminalSessionLen(list: TerminalSessionList): int32 =
    return list.len

fn terminalSessionGet(list: TerminalSessionList, idx: int32): TerminalState =
    var idx64: int64 = int64(idx)
    var offset64: int64 = idx64 * sizeof(TerminalState)
    var offset32: int32 = int32(offset64)
    let p: void* = ptr_add(list.buffer, offset32)
    let pt: TerminalState* = TerminalState*(p)
    return *pt

fn terminalSessionSet(list: TerminalSessionList*, idx: int32, val: TerminalState) =
    var idx64: int64 = int64(idx)
    var offset64: int64 = idx64 * sizeof(TerminalState)
    var offset32: int32 = int32(offset64)
    let p: void* = ptr_add(list->buffer, offset32)
    let pt: TerminalState* = TerminalState*(p)
    *pt = val

fn terminalSessionEnsureCap(list: TerminalSessionList*, need: int32) =
    if need <= list->cap:
        return
    var newCap: int32 = 4
    if list->cap > 0:
        newCap = list->cap * 2
    while newCap < need:
        newCap = newCap * 2
    list->cap = newCap
    var cap64: int64 = int64(newCap)
    var size64: int64 = int64(cap64 * sizeof(TerminalState))
    var size32: int32 = int32(size64)
    if list->buffer == nil:
        list->buffer = alloc(size32)
    else:
        list->buffer = realloc(list->buffer, size32)

fn terminalSessionInsert(list: TerminalSessionList*, idx: int32, val: TerminalState) =
    var insertIdx: int32 = idx
    if insertIdx < 0:
        insertIdx = 0
    if insertIdx > list->len:
        insertIdx = list->len
    terminalSessionEnsureCap(list, list->len + 1)
    var i: int32 = list->len
    while i > insertIdx:
        let prev: TerminalState = terminalSessionGet(*list, i - 1)
        terminalSessionSet(list, i, prev)
        i = i - 1
    terminalSessionSet(list, insertIdx, val)
    list->len = list->len + 1

fn terminalSessionDelete(list: TerminalSessionList*, idx: int32) =
    if idx < 0 || idx >= list->len:
        return
    for i in idx..<list->len - 1:
        let nextVal: TerminalState = terminalSessionGet(*list, i + 1)
        terminalSessionSet(list, i, nextVal)
    list->len = list->len - 1

fn newTerminalSessionList(): TerminalSessionList =
    var list: TerminalSessionList
    list.len = 0
    list.cap = 0
    list.buffer = nil
    return list

fn sliceRange(text: str, start, stop: int32): str =
    let length: int32 = len(text)
    if length <= 0:
        return ""
    var s: int32 = start
    if s < 0:
        s = 0
    if s >= length:
        return ""
    var e: int32 = stop
    if e < s:
        return ""
    if e >= length:
        e = length - 1
    let count: int32 = e - s + 1
    if count <= 0:
        return ""
    let p: void* = alloc(count + 1)
    let src: void* = ptr_add(void*(text), s)
    copyMem(p, src, count)
    let pEnd: void* = ptr_add(p, count)
    setMem(pEnd, 0, 1)
    return str(p)

fn slicePrefix(text: str, count: int32): str =
    if count <= 0:
        return ""
    return sliceRange(text, 0, count - 1)

fn sliceFrom(text: str, start: int32): str =
    let length: int32 = len(text)
    if start <= 0:
        return text
    if start >= length:
        return ""
    return sliceRange(text, start, length - 1)

fn sliceTo(text: str, endExclusive: int32): str =
    if endExclusive <= 0:
        return ""
    if endExclusive >= len(text):
        return text
    return sliceRange(text, 0, endExclusive - 1)

fn truncateMiddle(text: str, maxChars: int32): str =
    if maxChars <= 0:
        return ""
    if len(text) <= maxChars:
        return text
    if maxChars <= 3:
        return slicePrefix(text, maxChars)
    let keepLeft: int32 = (maxChars - 3) / 2
    let keepRight: int32 = maxChars - 3 - keepLeft
    let leftPart = if keepLeft > 0: sliceRange(text, 0, keepLeft - 1) else: ""
    let rightPart = if keepRight > 0: sliceRange(text, len(text) - keepRight, len(text) - 1) else: ""
    return leftPart + "..." + rightPart

fn splitLinesSimple(text: str): str[] =
    var lines: str[] = default[str[]]
    var start: int32 = 0
    for i in 0..<total:
        if text[i] == '\n':
            var endIdx: int32 = i
            if endIdx > start && text[endIdx - 1] == '\r':
                endIdx = endIdx - 1
            if endIdx >= start:
                addPtr_string(&lines, sliceRange(text, start, endIdx - 1))
            else:
                addPtr_string(&lines, "")
            start = i + 1
    if start <= total - 1:
        addPtr_string(&lines, sliceRange(text, start, total - 1))
    elif start == total:
        addPtr_string(&lines, "")
    return lines

fn clampIndex(value, limit: int32): int32 =
    if limit <= 0:
        return 0
    if value < 0:
        return 0
    if value >= limit:
        return limit - 1
    return value

fn replaceTabs(line: str, tabSize: int32): str =
    if len(line) == 0:
        return ""
    var resultStr: str = ""
    for idx in 0..<len(line):
        let ch: char = line[idx]
        if ch == '\t':
            for j in 0..<tabSize:
                resultStr = resultStr + " "
        else:
            resultStr = resultStr + $ ch
    return resultStr

fn normalizeLines(lines: str[]): str[] =
    var normalized: str[] = default[str[]]
    for idx in 0..<seqLenString(lines):
        let line: str = replaceTabs(seqGetString(lines, idx), TabSize)
        addPtr_string(&normalized, line)
    if seqLenString(normalized) == 0:
        addPtr_string(&normalized, "")
    return normalized

fn cloneLines(lines: str[]): str[] =
    var cloned: str[] = default[str[]]
    for idx in 0..<seqLenString(lines):
        addPtr_string(&cloned, seqGetString(lines, idx))
    if seqLenString(cloned) == 0:
        addPtr_string(&cloned, "")
    return cloned


fn startsWithPrefix(text: str, prefix: str): bool =
    let tLen: int32 = len(text)
    let pLen: int32 = len(prefix)
    if pLen <= 0:
        return true
    if tLen < pLen:
        return false
    for idx in 0..<pLen:
        if text[idx] != prefix[idx]:
            return false
    return true

fn containsString(items: str[], value: str): bool =
    for idx in 0..<seqLenString(items):
        if seqGetString(items, idx) == value:
            return true
    return false

fn addUniqueString(items: str[]*, value: str) =
    if len(value) == 0:
        return
    if ! containsString(*items, value):
        addPtr_string(items, value)

fn endsWithSuffix(text: str, suffix: str): bool =
    let tLen: int32 = len(text)
    let sLen: int32 = len(suffix)
    if sLen <= 0:
        return true
    if tLen < sLen:
        return false
    for idx in 0..<sLen:
        if text[tLen - sLen + idx] != suffix[idx]:
            return false
    return true

fn envFlagEnabled(value: str, defaultValue: bool): bool =
    if len(value) == 0:
        return defaultValue
    let lowered = textutils.toLowerAscii(textutils.strip(value))
    if lowered == "1" || lowered == "true" || lowered == "on" || lowered == "yes":
        return true
    if lowered == "0" || lowered == "false" || lowered == "off" || lowered == "no":
        return false
    return defaultValue

fn envIntValue(name: str, defaultValue: int32): int32 =
    let raw = getEnv(name)
    if len(raw) == 0:
        return defaultValue
    return parseInt32(raw, defaultValue)

fn envFloatValue(name: str, defaultValue: float64): float64 =
    let raw = getEnv(name)
    if len(raw) == 0:
        return defaultValue
    return float64(textutils.parseFloatAscii(raw))

@ importc("cheng_monotime_ns")
fn cheng_monotime_ns(): int64

fn guiNowMs(): int64 =
    let ns: int64 = cheng_monotime_ns()
    if ns > 0:
        return ns / 1000000
    return int64(epochTime() * 1000.0)

fn guiEpochMs(): int64 =
    return int64(epochTime() * 1000.0)

fn guiMsDiff(startMs: int64, endMs: int64): int32 =
    if endMs <= startMs:
        return 0
    let diff: int64 = endMs - startMs
    if diff > 2147483647:
        return 2147483647
    return int32(diff)

fn guiBudgetExpired(startMs: int64, budgetMs: int32): bool =
    if budgetMs <= 0:
        return false
    return guiMsDiff(startMs, guiNowMs()) >= budgetMs

fn computeInputScale(scale, logicalW, logicalH, pixelW, pixelH: float64): float64 =
    var resolved = scale
    var ratio: float64 = 0.0
    if logicalW > 0.0 && pixelW > 0.0:
        ratio = pixelW / logicalW
    if (ratio <= 0.0 || ratio > 8.0) && logicalH > 0.0 && pixelH > 0.0:
        ratio = pixelH / logicalH
    if ratio > 0.25 && ratio < 8.0:
        resolved = ratio
    if resolved <= 0.0:
        return 1.0
    return resolved

fn guiUpdateRenderLite(state: GuiState): GuiState =
    var next: GuiState = state
    if next.renderLiteForced:
        next.renderLite = true
        return next
    var lastRenderMs: int32 = next.renderLastMs
    if next.perf.enabled:
        let presentMs: int32 = next.perf.presentMs
        if presentMs > 0:
            lastRenderMs = next.perf.renderMs + presentMs
        else:
            lastRenderMs = next.perf.renderMs
    if lastRenderMs > 0 && lastRenderMs >= next.renderLiteThresholdMs:
        next.renderLite = true
        next.renderLiteHoldFrames = next.renderLiteHoldMax
        return next
    if next.renderLiteHoldFrames > 0:
        next.renderLiteHoldFrames = next.renderLiteHoldFrames - 1
        return next
    if next.renderLite && lastRenderMs > 0 && lastRenderMs <= (next.renderLiteThresholdMs / 2):
        next.renderLite = false
    return next

fn guiMarkRenderDirty(state: GuiState): GuiState =
    state.renderDirty = true
    return state

fn loadSetiLanguageMapEnabled(): bool =
    return envFlagEnabled(getEnv("CHENG_IDE_SETI_LANG_MAP"), false)


fn makeSymbolEntry(kind: str, name: str, line: int32, col: int32): str =
    return kind + "|" + name + "|" + intToStr(line) + "|" + intToStr(col)

fn makeProjectSymbolEntry(kind: str, name: str, line: int32, col: int32, path: str): str =
    return kind + "|" + name + "|" + intToStr(line) + "|" + intToStr(col) + "|" + path

fn symbolField(entry: str, fieldIndex: int32): str =
    let total: int32 = len(entry)
    for idx in 0..total:
        let isEnd: bool = idx == total
        if isEnd || entry[idx] == '|':
            if field == fieldIndex:
                if idx <= start:
                    return ""
                return sliceRange(entry, start, idx - 1)
            field = field + 1
            start = idx + 1
    return ""

fn symbolKind(entry: str): str =
    return symbolField(entry, 0)

fn symbolName(entry: str): str =
    return symbolField(entry, 1)

fn symbolLine(entry: str): int32 =
    let field = symbolField(entry, 2)
    return parseInt32(field, 0)

fn symbolCol(entry: str): int32 =
    let field = symbolField(entry, 3)
    return parseInt32(field, 0)

fn symbolPath(entry: str): str =
    return symbolField(entry, 4)

fn makeSemanticEntry(kind: str, name: str, line, col, indent: int32): str =
    return kind + "|" + name + "|" + intToStr(line) + "|" + intToStr(col) + "|" + intToStr(indent)

fn semanticKind(entry: str): str =
    return symbolField(entry, 0)

fn semanticName(entry: str): str =
    return symbolField(entry, 1)

fn semanticLine(entry: str): int32 =
    return parseInt32(symbolField(entry, 2), 0)

fn semanticCol(entry: str): int32 =
    return parseInt32(symbolField(entry, 3), 0)

fn semanticIndent(entry: str): int32 =
    return parseInt32(symbolField(entry, 4), 0)

fn semanticScopeStart(entry: str): int32 =
    return parseInt32(symbolField(entry, 5), -1)

fn semanticScopeEnd(entry: str): int32 =
    return parseInt32(symbolField(entry, 6), -1)

fn semanticScopeContains(entry: str, line: int32): bool =
    let startLine: int32 = semanticScopeStart(entry)
    let endLine: int32 = semanticScopeEnd(entry)
    if startLine < 0 || endLine < 0:
        return true
    return line >= startLine && line <= endLine

fn makeSemanticEntryWithScope(kind: str, name: str, line, col, indent, scopeStart, scopeEnd: int32): str =
    return makeSemanticEntry(kind, name, line, col, indent) + "|" + intToStr(scopeStart) + "|" + intToStr(scopeEnd)

fn trimLine(text: str): str =
    return textutils.strip(text)

fn isBlankLine(text: str): bool =
    return len(trimLine(text)) == 0

fn compareStringAscii(a: str, b: str): int32 =
    let lenA: int32 = len(a)
    let lenB: int32 = len(b)
    for idx in 0..<limit:
        let ca: int32 = ord(a[idx])
        let cb: int32 = ord(b[idx])
        if ca < cb:
            return -1
        if ca > cb:
            return 1
    if lenA < lenB:
        return -1
    if lenA > lenB:
        return 1
    return 0

fn isImportLine(lineText: str): bool =
    let trimmed = trimLine(lineText)
    if len(trimmed) == 0:
        return false
    if trimmed[0] == '#':
        return false
    return startsWithKeyword(trimmed, "import") || startsWithKeyword(trimmed, "from")

fn findImportBlock(lines: str[]): LineRange =
    var outVal: LineRange
    outVal.active = false
    let total: int32 = seqLenString(lines)
    for idx in 0..<total:
        let lineText = seqGetString(lines, idx)
        let trimmed = trimLine(lineText)
        if len(trimmed) == 0 || trimmed[0] == '#':
            continue
        if isImportLine(lineText):
            outVal.active = true
            outVal.startLine = idx
            var endIdx: int32 = idx
            while idx < total:
                let nextLine = seqGetString(lines, idx)
                if isImportLine(nextLine):
                    endIdx = idx
                    continue
                break
            outVal.endLine = endIdx
            return outVal
        return outVal
    return outVal

fn importSortKey(lineText: str): str =
    return textutils.toLowerAscii(trimLine(lineText))

fn importBlockUnsorted(lines: str[], blockRange: LineRange): bool =
    if ! blockRange.active || blockRange.endLine <= blockRange.startLine:
        return false
    var first: bool = true
    var lastKey: str = ""
    for idx in blockRange.startLine..blockRange.endLine:
        let key = importSortKey(seqGetString(lines, idx))
        if first:
            lastKey = key
            first = false
        else:
            if compareStringAscii(key, lastKey) < 0:
                return true
            lastKey = key
    return false

fn sortedImportLines(lines: str[], blockRange: LineRange): str[] =
    var outVal: str[] = default[str[]]
    var keys: str[] = default[str[]]
    for idx in blockRange.startLine..blockRange.endLine:
        let lineText = seqGetString(lines, idx)
        outVal.add(lineText)
        keys.add(importSortKey(lineText))
    for i in 0..<len(outVal):
        for j in i + 1..<len(outVal):
            if compareStringAscii(keys[j], keys[i]) < 0:
                let tmpLine = outVal[i]
                outVal[i] = outVal[j]
                outVal[j] = tmpLine
                let tmpKey = keys[i]
                keys[i] = keys[j]
                keys[j] = tmpKey
    return outVal

fn lineEndsWithSlash(text: str): bool =
    let trimmed = trimLine(text)
    if len(trimmed) == 0:
        return false
    let last: char = trimmed[len(trimmed) - 1]
    return last == '/' || last == '\\'

fn explorerItemSepIndex(item: str): int32 =
    return indexOfSubstr(item, "\t", 0)

fn explorerItemPathPart(item: str): str =
    let sep: int32 = explorerItemSepIndex(item)
    if sep < 0:
        return trimLine(item)
    if sep <= 0:
        return ""
    return sliceRange(item, 0, sep - 1)

fn explorerItemLabel(item: str): str =
    let sep: int32 = explorerItemSepIndex(item)
    if sep < 0:
        return item
    if sep + 1 > len(item) - 1:
        return ""
    return sliceFrom(item, sep + 1)

fn explorerItemPack(path: str, label: str): str =
    if len(label) == 0:
        return path
    return path + "\t" + label

fn explorerItemDepth(item: str): int32 =
    let label = explorerItemLabel(item)
    if len(trimLine(label)) > 0:
        var count: int32 = 0
        for idx in 0..<len(label):
            if label[idx] != ' ':
                break
            count = idx + 1
        return count / 2
    let rawPath = trimLine(explorerItemPathPart(item))
    if len(rawPath) == 0:
        return 0
    var normalized = textutils.toForwardSlashes(rawPath)
    while len(normalized) > 1 && (textutils.endsWith(normalized, "/") || textutils.endsWith(normalized, "\\")):
        normalized = slicePrefix(normalized, len(normalized) - 1)
    let parts: str[] = splitPathSegments(normalized)
    if seqLenString(parts) == 0:
        return 0
    return seqLenString(parts) - 1

fn explorerItemDisplayName(item: str): str =
    let label = trimLine(explorerItemLabel(item))
    if len(label) > 0:
        return label
    let rawPath = trimLine(explorerItemPathPart(item))
    if len(rawPath) == 0:
        return ""
    var cleaned = rawPath
    while len(cleaned) > 1 && (textutils.endsWith(cleaned, "/") || textutils.endsWith(cleaned, "\\")):
        cleaned = slicePrefix(cleaned, len(cleaned) - 1)
    let base = guiBaseNameFromPath(cleaned)
    if len(base) > 0:
        return base
    return cleaned

fn explorerItemIsDir(item: str): bool =
    let label = trimLine(explorerItemLabel(item))
    if len(label) > 0:
        return lineEndsWithSlash(label)
    let rawPath = trimLine(explorerItemPathPart(item))
    return lineEndsWithSlash(rawPath)

fn explorerItemKey(item: str): str =
    let depth: int32 = explorerItemDepth(item)
    let rawPath = trimLine(explorerItemPathPart(item))
    let base = if len(rawPath) > 0: textutils.toForwardSlashes(rawPath) else: explorerItemDisplayName(item)
    return base + "|" + intToStr(depth)

fn explorerNormalizeItem(item: str): str =
    let sep: int32 = explorerItemSepIndex(item)
    if sep < 0:
        return item
    let label = explorerItemLabel(item)
    if len(trimLine(label)) > 0:
        return item
    let rawPath = trimLine(explorerItemPathPart(item))
    if len(rawPath) == 0:
        return item
    var cleaned = textutils.toForwardSlashes(rawPath)
    let isDir: bool = lineEndsWithSlash(cleaned)
    while len(cleaned) > 1 && (textutils.endsWith(cleaned, "/") || textutils.endsWith(cleaned, "\\")):
        cleaned = slicePrefix(cleaned, len(cleaned) - 1)
    let parts: str[] = splitPathSegments(cleaned)
    if seqLenString(parts) == 0:
        return item
    let depth: int32 = seqLenString(parts) - 1
    let indent = makeIndent(depth)
    let name = seqGetString(parts, seqLenString(parts) - 1)
    if len(name) == 0:
        return item
    var rebuilt = indent + name
    if isDir:
        rebuilt = rebuilt + "/"
    return explorerItemPack(rawPath, rebuilt)

fn removeStringValue(items: str[]*, value: str) =
    for idx in 0..<seqLenString(*items):
        if seqGetString(*items, idx) == value:
            seqDeleteString(items, idx)
            return

fn explorerVisibleItems(allItems: str[], collapsed: str[]): str[] =
    var outVal: str[] = default[str[]]
    if seqLenString(allItems) == 0:
        addPtr_string(&outVal, "<empty>")
        return outVal
    if seqLenString(allItems) == 1:
        let single = seqGetString(allItems, 0)
        if trimLine(single) == "<empty>":
            addPtr_string(&outVal, single)
            return outVal
    var skipDepth: int32 = -1
    for idx in 0..<seqLenString(allItems):
        let item = seqGetString(allItems, idx)
        let depth: int32 = explorerItemDepth(item)
        if skipDepth >= 0:
            if depth > skipDepth:
                continue
            skipDepth = -1
        addPtr_string(&outVal, item)
        if explorerItemIsDir(item):
            let key = explorerItemKey(item)
            if containsString(collapsed, key):
                skipDepth = depth
    if seqLenString(outVal) == 0:
        addPtr_string(&outVal, "<empty>")
    return outVal

fn explorerIndexByKey(items: str[], key: str): int32 =
    for idx in 0..<seqLenString(items):
        if explorerItemKey(seqGetString(items, idx)) == key:
            return idx
    return -1

fn explorerSelectParent(state: ExplorerState, idx: int32): ExplorerState =
    if idx < 0 || idx >= seqLenString(state.items):
        return state
    let depth: int32 = explorerItemDepth(seqGetString(state.items, idx))
    let iBase = idx - 1
    if iBase >= 0:
        for iRev in 0..iBase:
            let i = iBase - iRev
            let item = seqGetString(state.items, i)
            if explorerItemDepth(item) < depth:
                state.selected = i
                return state
    return state

fn explorerToggleDir(state: ExplorerState, idx: int32, layout: GuiLayout): ExplorerState =
    if idx < 0 || idx >= seqLenString(state.items):
        return state
    let item = seqGetString(state.items, idx)
    if ! explorerItemIsDir(item):
        return state
    let key = explorerItemKey(item)
    if containsString(state.collapsed, key):
        removeStringValue(&state.collapsed, key)
    else:
        addPtr_string(&state.collapsed, key)
    state.items = explorerVisibleItems(state.allItems, state.collapsed)
    let nextIdx: int32 = explorerIndexByKey(state.items, key)
    if nextIdx >= 0:
        state.selected = nextIdx
    else:
        state.selected = clampInt(idx, 0, seqLenString(state.items) - 1)
    state = ensureExplorerVisible(state, layout)
    return state

fn explorerCollapseAll(state: ExplorerState): ExplorerState =
    state.collapsed = default[str[]]
    for idx in 0..<seqLenString(state.allItems):
        let item = seqGetString(state.allItems, idx)
        if explorerItemIsDir(item):
            addUniqueString(&state.collapsed, explorerItemKey(item))
    state.items = explorerVisibleItems(state.allItems, state.collapsed)
    state.scroll = clampInt(state.scroll, 0, maxInt(0, seqLenString(state.items) - 1))
    state.selected = clampInt(state.selected, 0, seqLenString(state.items) - 1)
    return state

fn explorerRevealPath(state: ExplorerState, roots: str[], root: str, path: str): ExplorerState =
    if len(path) == 0:
        return state
    var rel = workspaceEncodePathForRoots(path, roots)
    if len(rel) == 0:
        rel = pathRelativeToRoot(root, path)
    rel = textutils.toForwardSlashes(rel)
    let parts: str[] = splitPathSegments(rel)
    if seqLenString(parts) <= 1:
        return state
    for depth in 0..<seqLenString(parts) - 1:
        let dirPath = joinPathSegments(parts, depth) + "/"
        let key = dirPath + "|" + intToStr(depth)
        removeStringValue(&state.collapsed, key)
    state.items = explorerVisibleItems(state.allItems, state.collapsed)
    return state

fn explorerAllItems(state: ExplorerState): str[] =
    if seqLenString(state.allItems) > 0:
        return state.allItems
    return state.items

fn normalizeExplorerItems(text: str): str[] =
    var outVal: str[] = default[str[]]
    let lines: str[] = splitLinesSimple(text)
    for idx in 0..<seqLenString(lines):
        let rawLine = seqGetString(lines, idx)
        if ! isBlankLine(rawLine):
            addPtr_string(&outVal, explorerNormalizeItem(rawLine))
    if seqLenString(outVal) == 0:
        addPtr_string(&outVal, "<empty>")
    return outVal

fn splitDelimitedList(text: str, sep: char): str[] =
    var outVal: str[] = default[str[]]
    var start: int32 = 0
    for idx in 0..total:
        if idx == total || text[idx] == sep:
            if idx > start:
                let raw = trimLine(sliceRange(text, start, idx - 1))
                if len(raw) > 0:
                    addPtr_string(&outVal, raw)
            start = idx + 1
    return outVal

fn splitCommaList(text: str): str[] =
    return splitDelimitedList(text, ',')

fn splitSemicolonList(text: str): str[] =
    return splitDelimitedList(text, ';')

fn workspaceRootEntry(label: str, path: str): str =
    return label + "|" + path

fn workspaceRootLabel(entry: str): str =
    return symbolField(entry, 0)

fn workspaceRootPath(entry: str): str =
    return symbolField(entry, 1)

fn workspaceRootLabelExists(roots: str[], label: str): bool =
    for idx in 0..<seqLenString(roots):
        if workspaceRootLabel(seqGetString(roots, idx)) == label:
            return true
    return false

fn workspaceRootPathExists(roots: str[], path: str): bool =
    let norm = normalizeDirPath(path)
    for idx in 0..<seqLenString(roots):
        let candidate = workspaceRootPath(seqGetString(roots, idx))
        if normalizeDirPath(candidate) == norm:
            return true
    return false

fn workspaceRootLabelFromPath(path: str): str =
    var norm = textutils.toForwardSlashes(trimLine(path))
    while len(norm) > 1 && textutils.endsWith(norm, "/"):
        norm = slicePrefix(norm, len(norm) - 1)
    let name = extractFilename(norm)
    if len(name) > 0:
        return name
    if len(norm) > 0:
        return norm
    return "root"

fn workspaceRootUniqueLabel(roots: str[], label: str): str =
    var base = label
    if len(base) == 0:
        base = "root"
    var candidate = base
    var counter: int32 = 2
    while workspaceRootLabelExists(roots, candidate):
        candidate = base + "-" + intToStr(counter)
        counter = counter + 1
    return candidate

fn workspaceRootsFromEnv(baseRoot: str): str[] =
    var outVal: str[] = default[str[]]
    let envRoots = getEnv("CHENG_IDE_ROOTS")
    if len(envRoots) == 0:
        return outVal
    let parts: str[] = splitSemicolonList(envRoots)
    for idx in 0..<seqLenString(parts):
        let raw = trimLine(seqGetString(parts, idx))
        if len(raw) > 0:
            let resolved = resolvePath(baseRoot, raw)
            if dirExists(resolved):
                if ! workspaceRootPathExists(outVal, resolved):
                    let labelBase = workspaceRootLabelFromPath(resolved)
                    let label = workspaceRootUniqueLabel(outVal, labelBase)
                    addPtr_string(&outVal, workspaceRootEntry(label, resolved))
    return outVal

fn workspaceRootIndexByLabel(roots: str[], label: str): int32 =
    for idx in 0..<seqLenString(roots):
        if workspaceRootLabel(seqGetString(roots, idx)) == label:
            return idx
    return -1

fn workspaceRootIndexForPath(roots: str[], path: str): int32 =
    for idx in 0..<seqLenString(roots):
        let rootPath = workspaceRootPath(seqGetString(roots, idx))
        if pathIsUnderDir(rootPath, path):
            return idx
    return -1

fn workspaceEncodePathForRoots(path: str, roots: str[]): str =
    let trimmed = trimLine(path)
    if len(trimmed) == 0:
        return ""
    if isAbsolute(trimmed):
        let idx: int32 = workspaceRootIndexForPath(roots, trimmed)
        if idx < 0:
            return ""
        let rootPath = workspaceRootPath(seqGetString(roots, idx))
        let rootNorm = textutils.toForwardSlashes(rootPath)
        let pathNorm = textutils.toForwardSlashes(trimmed)
        var rel = relativePath(pathNorm, rootNorm)
        if len(rel) == 0:
            return workspaceRootLabel(seqGetString(roots, idx))
        return joinPath(workspaceRootLabel(seqGetString(roots, idx)), rel)
    let normalized = textutils.toForwardSlashes(trimmed)
    let sep: int32 = indexOfSubstr(normalized, "/", 0)
    let head = if sep >= 0: sliceRange(normalized, 0, sep - 1) else: normalized
    if workspaceRootIndexByLabel(roots, head) >= 0:
        return normalized
    if seqLenString(roots) > 0:
        let baseLabel = workspaceRootLabel(seqGetString(roots, 0))
        if len(baseLabel) > 0:
            return joinPath(baseLabel, normalized)
    return normalized

fn workspaceStripRootLabel(path: str, roots: str[]): str =
    let normalized = textutils.toForwardSlashes(path)
    let sep: int32 = indexOfSubstr(normalized, "/", 0)
    let head = if sep >= 0: sliceRange(normalized, 0, sep - 1) else: normalized
    if workspaceRootIndexByLabel(roots, head) >= 0:
        if sep >= 0:
            return sliceFrom(normalized, sep + 1)
        return ""
    return normalized

fn workspaceResolvePath(path: str, roots: str[], fallbackRoot: str): str =
    let trimmed = trimLine(path)
    if len(trimmed) == 0:
        return ""
    if isAbsolute(trimmed):
        return trimmed
    let normalized = textutils.toForwardSlashes(trimmed)
    let sep: int32 = indexOfSubstr(normalized, "/", 0)
    let head = if sep >= 0: sliceRange(normalized, 0, sep - 1) else: normalized
    let idx: int32 = workspaceRootIndexByLabel(roots, head)
    if idx >= 0:
        let rootPath = workspaceRootPath(seqGetString(roots, idx))
        if sep < 0:
            return rootPath
        let tail = sliceFrom(normalized, sep + 1)
        return joinPath(rootPath, tail)
    return resolvePath(fallbackRoot, trimmed)

fn workspaceNormalizeExt(text: str): str =
    var outVal = textutils.toLowerAscii(trimLine(text))
    if len(outVal) == 0:
        return ""
    if outVal == "*" || outVal == "all":
        return "*"
    if outVal[0] != '.':
        outVal = "." + outVal
    return outVal

fn workspaceNormalizePathToken(text: str): str =
    var outVal = textutils.toForwardSlashes(trimLine(text))
    outVal = textutils.toLowerAscii(outVal)
    return outVal

fn workspaceNormalizeDirToken(text: str): str =
    var outVal = textutils.toForwardSlashes(trimLine(text))
    outVal = textutils.toLowerAscii(outVal)
    while len(outVal) > 0 && outVal[0] == '/':
        outVal = sliceFrom(outVal, 1)
    while len(outVal) > 0 && textutils.endsWith(outVal, "/"):
        outVal = slicePrefix(outVal, len(outVal) - 1)
    return outVal

fn workspaceAddUnique(items: str[]*, value: str) =
    if len(value) == 0:
        return
    if seqLenString(*items) >= MaxWorkspaceConfigEntries:
        return
    if ! containsString(*items, value):
        addPtr_string(items, value)

fn workspacePathHasDirSegment(path: str, dirName: str): bool =
    let normPath = textutils.toLowerAscii(textutils.toForwardSlashes(path))
    var name = workspaceNormalizeDirToken(dirName)
    if len(name) == 0:
        return false
    let needle = "/" + name + "/"
    if indexOfSubstr(normPath, needle, 0) >= 0:
        return true
    if startsWithPrefix(normPath, name + "/"):
        return true
    if endsWithSuffix(normPath, "/" + name):
        return true
    return false

fn workspacePathExcluded(path: str, config: WorkspaceConfig): bool =
    let normPath = textutils.toLowerAscii(textutils.toForwardSlashes(path))
    if len(normPath) == 0:
        return true
    for idx in 0..<seqLenString(config.excludeDirs):
        if workspacePathHasDirSegment(normPath, seqGetString(config.excludeDirs, idx)):
            return true
    for idx in 0..<seqLenString(config.excludePaths):
        let needle = seqGetString(config.excludePaths, idx)
        if len(needle) > 0 && indexOfSubstr(normPath, needle, 0) >= 0:
            return true
    return false

fn workspacePathHasAllowedExt(normPath: str, config: WorkspaceConfig): bool =
    if seqLenString(config.includeExts) == 0:
        return endsWithSuffix(normPath, ".cheng")
    for idx in 0..<seqLenString(config.includeExts):
        let ext = seqGetString(config.includeExts, idx)
        if ext == "*":
            return true
        if endsWithSuffix(normPath, ext):
            return true
    return false

fn workspacePathAllowed(path: str, config: WorkspaceConfig): bool =
    let normPath = textutils.toLowerAscii(textutils.toForwardSlashes(path))
    if workspacePathExcluded(normPath, config):
        return false
    return workspacePathHasAllowedExt(normPath, config)

fn defaultWorkspaceConfig(): WorkspaceConfig =
    var config: WorkspaceConfig
    config.includeExts = default[str[]]
    config.excludeDirs = default[str[]]
    config.excludePaths = default[str[]]
    var defaultDirs: str[] = default[str[]]
    addPtr_string(&defaultDirs, ".git")
    addPtr_string(&defaultDirs, ".hg")
    addPtr_string(&defaultDirs, ".svn")
    addPtr_string(&defaultDirs, ".idea")
    addPtr_string(&defaultDirs, ".vscode")
    addPtr_string(&defaultDirs, "node_modules")
    addPtr_string(&defaultDirs, "chengcache")
    addPtr_string(&defaultDirs, "chengblecache")
    addPtr_string(&defaultDirs, "__pycache__")
    addPtr_string(&defaultDirs, "dist")
    addPtr_string(&defaultDirs, "build")
    addPtr_string(&defaultDirs, "out")
    addPtr_string(&defaultDirs, "target")
    addPtr_string(&defaultDirs, ".tmp_cheng_build")
    addPtr_string(&defaultDirs, "tmp_build")
    for idx in 0..<seqLenString(defaultDirs):
        let dirToken = workspaceNormalizeDirToken(seqGetString(defaultDirs, idx))
        workspaceAddUnique(&config.excludeDirs, dirToken)
    var defaultPaths: str[] = default[str[]]
    addPtr_string(&defaultPaths, ".ds_store")
    addPtr_string(&defaultPaths, ".tmp")
    for idx in 0..<seqLenString(defaultPaths):
        let token = workspaceNormalizePathToken(seqGetString(defaultPaths, idx))
        workspaceAddUnique(&config.excludePaths, token)
    return config

fn guiSetEnvIfMissing(key: str, value: str) =
    if len(value) == 0:
        return
    if len(getEnv(key)) == 0:
        putEnv(key, value)

fn putEnv(key: str, value: str) =
    if len(key) == 0:
        return
    cSetEnv(key, value, 1)

fn guiApplyEnvDefaults(projectRoot: str) =
    if len(projectRoot) == 0:
        return
    guiSetEnvIfMissing("CHENG_IDE_ROOT", projectRoot)
    if len(getEnv("CHENG_ROOT")) == 0:
        let parent = splitFile(projectRoot).dir
        let candidate = joinPath(parent, "cheng-lang")
        if dirExists(candidate):
            putEnv("CHENG_ROOT", candidate)
    let resourceRoot = joinPath(projectRoot, "resources")
    if dirExists(resourceRoot):
        guiSetEnvIfMissing("CHENG_IDE_RESOURCE_ROOT", resourceRoot)
    else:
        let fallbackRoot = joinPath(projectRoot, "ide/resources")
        if dirExists(fallbackRoot):
            guiSetEnvIfMissing("CHENG_IDE_RESOURCE_ROOT", fallbackRoot)
    var codiconPath = joinPath(projectRoot, "resources/fonts/codicon.ttf")
    if ! fileExists(codiconPath):
        codiconPath = joinPath(projectRoot, "ide/resources/fonts/codicon.ttf")
    if fileExists(codiconPath):
        guiSetEnvIfMissing("CHENG_IDE_ICON_FONT", codiconPath)
    var setiFontLocal = joinPath(projectRoot, "resources/fonts/seti.woff")
    if ! fileExists(setiFontLocal):
        setiFontLocal = joinPath(projectRoot, "ide/resources/fonts/seti.woff")
    if fileExists(setiFontLocal):
        guiSetEnvIfMissing("CHENG_IDE_FILE_ICON_FONT", setiFontLocal)
    var setiThemeLocal = joinPath(projectRoot, "resources/seti/vs-seti-icon-theme.json")
    if ! fileExists(setiThemeLocal):
        setiThemeLocal = joinPath(projectRoot, "ide/resources/seti/vs-seti-icon-theme.json")
    if fileExists(setiThemeLocal):
        guiSetEnvIfMissing("CHENG_IDE_SETI_THEME", setiThemeLocal)
    var vscodeRoot = getEnv("CHENG_IDE_VSCODE_ROOT")
    if len(vscodeRoot) == 0:
        let candidate = "/Users/lbcheng/vscode"
        if dirExists(candidate):
            putEnv("CHENG_IDE_VSCODE_ROOT", candidate)
            vscodeRoot = candidate
    p2p_bridge.guiP2PMaybeInit()
    if len(vscodeRoot) == 0:
        return
    let vscodeCodicon = joinPath(vscodeRoot, "src/vs/base/browser/ui/codicons/codicon/codicon.ttf")
    if fileExists(vscodeCodicon):
        guiSetEnvIfMissing("CHENG_IDE_ICON_FONT", vscodeCodicon)
    let setiFont = joinPath(vscodeRoot, "extensions/theme-seti/icons/seti.woff")
    if fileExists(setiFont):
        guiSetEnvIfMissing("CHENG_IDE_FILE_ICON_FONT", setiFont)
    let setiTheme = joinPath(vscodeRoot, "extensions/theme-seti/icons/vs-seti-icon-theme.json")
    if fileExists(setiTheme):
        guiSetEnvIfMissing("CHENG_IDE_SETI_THEME", setiTheme)
    var codexIcon = joinPath(projectRoot, "resources/codex/blossom-24.bmp")
    if ! fileExists(codexIcon):
        codexIcon = joinPath(projectRoot, "ide/resources/codex/blossom-24.bmp")
    if fileExists(codexIcon):
        guiSetEnvIfMissing("CHENG_IDE_CODEX_ICON", codexIcon)
    let codexEditIcon = joinPath(projectRoot, "resources/codex/edit-16.bmp")
    if fileExists(codexEditIcon):
        guiSetEnvIfMissing("CHENG_IDE_CODEX_EDIT_ICON", codexEditIcon)
    let codexEditIconLegacy = joinPath(projectRoot, "ide/resources/codex/edit-16.bmp")
    if fileExists(codexEditIconLegacy):
        guiSetEnvIfMissing("CHENG_IDE_CODEX_EDIT_ICON", codexEditIconLegacy)
    let codexCloseIcon = joinPath(projectRoot, "resources/codex/close-16.bmp")
    if fileExists(codexCloseIcon):
        guiSetEnvIfMissing("CHENG_IDE_CODEX_CLOSE_ICON", codexCloseIcon)
    let codexCloseIconLegacy = joinPath(projectRoot, "ide/resources/codex/close-16.bmp")
    if fileExists(codexCloseIconLegacy):
        guiSetEnvIfMissing("CHENG_IDE_CODEX_CLOSE_ICON", codexCloseIconLegacy)

    iconFontChecked = false
    fileIconFontChecked = false
    codexIconChecked = false
    codexEditIconChecked = false
    codexCloseIconChecked = false

fn guiWorkspaceConfigPath(root: str): str =
    let override = getEnv("CHENG_IDE_WORKSPACE_CONFIG")
    if len(override) > 0:
        if isAbsolute(override) || len(root) == 0:
            return override
        return joinPath(root, override)
    let base = if len(root) > 0: root else: getCurrentDir()
    return joinPath(joinPath(base, WorkspaceStateDir), WorkspaceConfigFile)

fn guiWorkspaceConfigLoad(root: str): WorkspaceConfig =
    var config: WorkspaceConfig = defaultWorkspaceConfig()
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return config
    let path = guiWorkspaceConfigPath(root)
    if ! fileExists(path):
        return config
    let lines: str[] = splitLinesSimple(readFile(path))
    for idx in 0..<seqLenString(lines):
        let raw = trimLine(seqGetString(lines, idx))
        if len(raw) == 0 || raw[0] == '#':
            continue
        let sep: int32 = indexOfSubstr(raw, "=", 0)
        if sep < 0:
            continue
        let key = if sep > 0: textutils.toLowerAscii(trimLine(sliceRange(raw, 0, sep - 1))) else: ""
        let value = if sep + 1 <= len(raw) - 1: sliceFrom(raw, sep + 1) else: ""
        if key == "include_ext" || key == "ext":
            let parts: str[] = splitCommaList(value)
            for pIdx in 0..<seqLenString(parts):
                let ext = workspaceNormalizeExt(seqGetString(parts, pIdx))
                workspaceAddUnique(&config.includeExts, ext)
        elif key == "exclude_dir" || key == "exclude_dirs":
            let parts: str[] = splitCommaList(value)
            for pIdx in 0..<seqLenString(parts):
                let dir = workspaceNormalizeDirToken(seqGetString(parts, pIdx))
                workspaceAddUnique(&config.excludeDirs, dir)
        elif key == "exclude_path" || key == "exclude":
            let parts: str[] = splitCommaList(value)
            for pIdx in 0..<seqLenString(parts):
                let token = workspaceNormalizePathToken(seqGetString(parts, pIdx))
                workspaceAddUnique(&config.excludePaths, token)
    return config

fn collectExplorerPathsFromText(text: str, roots: str[], config: WorkspaceConfig): str[] =
    var outVal: str[] = default[str[]]
    let lines: str[] = splitLinesSimple(text)
    for idx in 0..<seqLenString(lines):
        let rawLine = seqGetString(lines, idx)
        let trimmed = trimLine(rawLine)
        if len(trimmed) > 0 && ! lineEndsWithSlash(trimmed):
            let encoded = workspaceEncodePathForRoots(trimmed, roots)
            if len(encoded) == 0:
                continue
            let rel = workspaceStripRootLabel(encoded, roots)
            if workspacePathExcluded(rel, config):
                continue
            if seqLenString(config.includeExts) == 0:
                addPtr_string(&outVal, encoded)
            else:
                let lowered = textutils.toLowerAscii(rel)
                if workspacePathHasAllowedExt(lowered, config):
                    addPtr_string(&outVal, encoded)
    return outVal

fn collectExplorerPathsFromRoots(roots: str[], config: WorkspaceConfig): str[] =
    var outVal: str[] = default[str[]]
    if seqLenString(roots) == 0:
        return outVal
    let maxEnv = trimLine(getEnv("CHENG_IDE_EXPLORER_MAX"))
    var maxEntries: int32 = DefaultExplorerMax
    if len(maxEnv) > 0:
        maxEntries = parseInt32(maxEnv, DefaultExplorerMax)
    let limitEnabled: bool = maxEntries > 0
    var remaining: int32 = maxEntries
    var stopScan: bool = false
    for rIdx in 0..<seqLenString(roots):
        if ! (! stopScan):
            break
        let rootEntry = seqGetString(roots, rIdx)
        let rootPath = workspaceRootPath(rootEntry)
        if len(rootPath) == 0 || ! dirExists(rootPath):
            continue
        let rootNorm: str = textutils.toForwardSlashes(rootPath)
        var stack: str[] = default[str[]]
        addPtr_string(&stack, rootPath)
        while seqLenString(stack) > 0 && ! stopScan:
            let topIdx: int32 = seqLenString(stack) - 1
            let dirPath = seqGetString(stack, topIdx)
            seqDeleteString(&stack, topIdx)
            let items = walkDir(dirPath)
            for idx in 0..<items.len:
                if limitEnabled && remaining <= 0:
                    stopScan = true
                    break
                let entry = get_WalkDirEntry(items, idx)
                let kind: PathComponent = entry[0]
                let rawPath: str = entry[1]
                let pathNorm = textutils.toForwardSlashes(rawPath)
                var rel = relativePath(pathNorm, rootNorm)
                if len(rel) == 0:
                    rel = pathNorm
                if kind == pcDir:
                    if ! workspacePathExcluded(rel + "/", config):
                        addPtr_string(&stack, rawPath)
                    continue
                if kind == pcLinkToDir:
                    continue
                if workspacePathAllowed(rel, config):
                    let encoded = joinPath(workspaceRootLabel(rootEntry), rel)
                    addPtr_string(&outVal, encoded)
                    if limitEnabled:
                        remaining = remaining - 1
    return outVal

fn splitPathSegments(path: str): str[] =
    var outVal: str[] = default[str[]]
    var start: int32 = 0
    for i in 0..total:
        if i == total || path[i] == '/':
            if i > start:
                addPtr_string(&outVal, sliceRange(path, start, i - 1))
            start = i + 1
    return outVal

fn joinPathSegments(parts: str[], lastIdx: int32): str =
    var outVal: str = ""
    for idx in 0..<seqLenString(parts):
        if idx > lastIdx:
            break
        if idx > 0:
            outVal = outVal + "/"
        outVal = outVal + seqGetString(parts, idx)
    return outVal

fn makeIndent(depth: int32): str =
    var outVal: str = ""
    for i in 0..<depth:
        outVal = outVal + "  "
    return outVal

fn compareStrings(a, b: str): int32 =
    let aLen: int32 = len(a)
    let bLen: int32 = len(b)
    let limit: int32 = minInt(aLen, bLen)
    for i in 0..<limit:
        let ac: char = a[i]
        let bc: char = b[i]
        if ac < bc:
            return -1
        if ac > bc:
            return 1
    if aLen < bLen:
        return -1
    if aLen > bLen:
        return 1
    return 0

fn sortStringList(items: str[]*) =
    let count: int32 = seqLenString(*items)
    if count <= 1:
        return
    for i in 1..<count:
        let key = seqGetString(*items, i)
        var j: int32 = i
        while j > 0:
            let prev = seqGetString(*items, j - 1)
            if compareStrings(key, prev) >= 0:
                break
            seqSetString(items, j, prev)
            j = j - 1
        if j != i:
            seqSetString(items, j, key)

fn buildExplorerTreeItems(paths: str[]): str[] =
    var outVal: str[] = default[str[]]
    if seqLenString(paths) == 0:
        addPtr_string(&outVal, "<empty>")
        return outVal
    var work: str[] = default[str[]]
    for idx in 0..<seqLenString(paths):
        let p = seqGetString(paths, idx)
        if len(p) > 0:
            addPtr_string(&work, p)
    if seqLenString(work) == 0:
        addPtr_string(&outVal, "<empty>")
        return outVal
    sortStringList(&work)
    var prevDirs: str[] = default[str[]]
    var lastPath: str = ""
    for idx in 0..<seqLenString(work):
        let path = seqGetString(work, idx)
        if path == lastPath:
            continue
        lastPath = path
        let parts: str[] = splitPathSegments(path)
        let depth: int32 = seqLenString(parts)
        if depth <= 0:
            continue
        for d in 0..<depth - 1:
            let dirName = seqGetString(parts, d)
            var same = false
            if d < seqLenString(prevDirs):
                if seqGetString(prevDirs, d) == dirName:
                    same = true
            if ! same:
                while seqLenString(prevDirs) > d:
                    seqDeleteString(&prevDirs, seqLenString(prevDirs) - 1)
                addPtr_string(&prevDirs, dirName)
                let indent = makeIndent(d)
                let dirPath = joinPathSegments(parts, d) + "/"
                let label = indent + dirName + "/"
                addPtr_string(&outVal, explorerNormalizeItem(explorerItemPack(dirPath, label)))
        let fileName = seqGetString(parts, depth - 1)
        let fileIndent = makeIndent(depth - 1)
        let fileLabel = fileIndent + fileName
        addPtr_string(&outVal, explorerNormalizeItem(explorerItemPack(path, fileLabel)))
    if seqLenString(outVal) == 0:
        addPtr_string(&outVal, "<empty>")
    return outVal

fn explorerDebugDump(roots: str[], paths: str[], items: str[], useDefault: bool) =
    if ! envFlagEnabled(getEnv("CHENG_IDE_DEBUG_EXPLORER"), false):
        return
    let verbose: bool = envFlagEnabled(getEnv("CHENG_IDE_DEBUG_EXPLORER_VERBOSE"), false)
    if verbose:
        textutils.print("[explorer-debug] start\n")
    var lines: str[] = default[str[]]
    addPtr_string(&lines, "[explorer]")
    addPtr_string(&lines, "useDefault=" + textutils.boolToString(useDefault))
    addPtr_string(&lines, "roots=" + intToStr(seqLenString(roots)))
    for rIdx in 0..<seqLenString(roots):
        if verbose:
            textutils.print("[explorer-debug] root " + intToStr(rIdx) + "\n")
        let entry = seqGetString(roots, rIdx)
        let label = workspaceRootLabel(entry)
        let path = workspaceRootPath(entry)
        addPtr_string(&lines, "root[" + intToStr(rIdx) + "]= " + label + " | " + path)
    if verbose:
        textutils.print("[explorer-debug] roots done\n")
    addPtr_string(&lines, "paths=" + intToStr(seqLenString(paths)))
    addPtr_string(&lines, "items=" + intToStr(seqLenString(items)))
    var blank: int32 = 0
    for idx in 0..<seqLenString(items):
        let display = trimLine(explorerItemDisplayName(seqGetString(items, idx)))
        if len(display) == 0:
            blank = blank + 1
    if verbose:
        textutils.print("[explorer-debug] blank scan done\n")
    addPtr_string(&lines, "blankDisplay=" + intToStr(blank))
    addPtr_string(&lines, "samples:")
    let sampleCount: int32 = minInt(120, seqLenString(items))
    for idx in 0..<sampleCount:
        let item = seqGetString(items, idx)
        let path = trimLine(explorerItemPathPart(item))
        let label = explorerItemLabel(item)
        let display = explorerItemDisplayName(item)
        addPtr_string(&lines, intToStr(idx) + ": path=" + path + " label=" + label + " display=" + display)
    if verbose:
        textutils.print("[explorer-debug] samples done\n")
    var baseRoot: str = ""
    if seqLenString(roots) > 0:
        baseRoot = workspaceRootPath(seqGetString(roots, 0))
    if len(baseRoot) == 0:
        baseRoot = getCurrentDir()
    if verbose:
        textutils.print("[explorer-debug] log path ready\n")
    let logDir = joinPath(baseRoot, WorkspaceStateDir)
    guiEnsureDirExists(logDir)
    let logPath = joinPath(logDir, "explorer.log")
    if verbose:
        textutils.print("[explorer-debug] writing log\n")
    let writeToFile: bool = envFlagEnabled(getEnv("CHENG_IDE_DEBUG_EXPLORER_FILE"), false)
    if ! writeToFile || envFlagEnabled(getEnv("CHENG_IDE_DEBUG_EXPLORER_STDOUT"), false):
        for idx in 0..<seqLenString(lines):
            textutils.print(seqGetString(lines, idx) + "\n")
    if writeToFile:
        let f: File = open(logPath, fmWrite)
        if f == nil:
            if verbose:
                textutils.print("[explorer-debug] open failed\n")
        else:
            for idx in 0..<seqLenString(lines):
                write(f, seqGetString(lines, idx))
                if idx < seqLenString(lines) - 1:
                    write(f, "\n")
            close(f)
    if verbose:
        textutils.print("[explorer-debug] done\n")

fn loadExplorerState(roots: str[], defaultList: str, config: WorkspaceConfig): ExplorerState =
    var state: ExplorerState
    var listText: str = ""
    let listPath = getEnv("CHENG_IDE_FILE_LIST_PATH")
    if len(listPath) > 0 && fileExists(listPath):
        listText = readFile(listPath)
    if len(listText) == 0:
        listText = getEnv("CHENG_IDE_FILE_LIST")
    var useDefault = false
    var paths: str[] = default[str[]]
    if len(listText) > 0:
        if listText == defaultList:
            useDefault = true
        else:
            paths = collectExplorerPathsFromText(listText, roots, config)
            if seqLenString(paths) == 0:
                useDefault = true
    else:
        paths = collectExplorerPathsFromRoots(roots, config)
        if seqLenString(paths) == 0:
            useDefault = true
    if useDefault:
        if len(defaultList) == 0:
            state.items = normalizeExplorerItems("")
        else:
            state.items = normalizeExplorerItems(defaultList)
    else:
        state.items = buildExplorerTreeItems(paths)
    state.allItems = state.items
    state.collapsed = default[str[]]
    for cIdx in 0..<seqLenString(state.allItems):
        let item = seqGetString(state.allItems, cIdx)
        if explorerItemIsDir(item):
            addUniqueString(&state.collapsed, explorerItemKey(item))
    state.items = explorerVisibleItems(state.allItems, state.collapsed)
    state.scroll = 0
    state.selected = -1
    explorerDebugDump(roots, paths, state.allItems, useDefault)
    return state

fn resolvePath(root: str, path: str): str =
    if len(path) == 0:
        return ""
    if isAbsolute(path):
        return path
    if len(root) == 0:
        return path
    return joinPath(root, path)

fn resolveWorkspacePath(state: GuiState, path: str): str =
    return workspaceResolvePath(path, state.workspaceRoots, state.projectRoot)

fn pathRelativeToRoot(root: str, path: str): str =
    if len(path) == 0:
        return ""
    if len(root) == 0:
        return textutils.toForwardSlashes(path)
    let normRoot = textutils.toForwardSlashes(root)
    let normPath = textutils.toForwardSlashes(path)
    if startsWithPrefix(normPath, normRoot):
        let rootLen: int32 = len(normRoot)
        if rootLen == len(normPath):
            return extractFilename(normPath)
        if rootLen < len(normPath) && normPath[rootLen] == '/':
            return sliceFrom(normPath, rootLen + 1)
    return normPath

fn guiWorkspaceDisplayPath(state: GuiState, path: str): str =
    if len(path) == 0:
        return ""
    if seqLenString(state.workspaceRoots) > 1:
        let encoded = workspaceEncodePathForRoots(path, state.workspaceRoots)
        if len(encoded) > 0:
            return encoded
    return pathRelativeToRoot(state.projectRoot, path)

fn guiWorkspaceRootForResolved(state: GuiState, resolved: str): str =
    if len(resolved) == 0:
        return ""
    let idx: int32 = workspaceRootIndexForPath(state.workspaceRoots, resolved)
    if idx >= 0:
        let rootPath = workspaceRootPath(seqGetString(state.workspaceRoots, idx))
        if len(rootPath) > 0:
            return rootPath
    return ""

fn guiWorkspaceActiveRoot(state: GuiState): str =
    if len(state.editor.filePath) > 0:
        let rootPath = guiWorkspaceRootForResolved(state, state.editor.filePath)
        if len(rootPath) > 0:
            return rootPath
    if state.explorer.selected >= 0 && state.explorer.selected < seqLenString(state.explorer.items):
        let item = seqGetString(state.explorer.items, state.explorer.selected)
        var selected = trimLine(explorerItemPathPart(item))
        if len(selected) > 0:
            if lineEndsWithSlash(selected):
                selected = slicePrefix(selected, len(selected) - 1)
            let resolved = workspaceResolvePath(selected, state.workspaceRoots, state.projectRoot)
            let rootPath = guiWorkspaceRootForResolved(state, resolved)
            if len(rootPath) > 0:
                return rootPath
    if len(state.projectRoot) > 0:
        return state.projectRoot
    return getCurrentDir()

fn normalizeDirPath(path: str): str =
    var outVal = textutils.toForwardSlashes(path)
    while len(outVal) > 1 && textutils.endsWith(outVal, "/"):
        outVal = slicePrefix(outVal, len(outVal) - 1)
    return outVal

fn pathIsUnderDir(dirPath: str, path: str): bool =
    if len(dirPath) == 0 || len(path) == 0:
        return false
    let normDir = normalizeDirPath(dirPath)
    let normPath = textutils.toForwardSlashes(path)
    if normDir == normPath:
        return true
    if startsWithPrefix(normPath, normDir):
        let dirLen: int32 = len(normDir)
        if dirLen < len(normPath) && normPath[dirLen] == '/':
            return true
    return false

fn pathReplaceDirPrefix(path: str, sourceDir: str, targetDir: str): str =
    if ! pathIsUnderDir(sourceDir, path):
        return path
    let normSource = normalizeDirPath(sourceDir)
    let normPath = textutils.toForwardSlashes(path)
    if len(normPath) == len(normSource):
        return targetDir
    let suffix = if len(normPath) > len(normSource) + 1: sliceFrom(normPath, len(normSource) + 1) else: ""
    if len(suffix) == 0:
        return targetDir
    return joinPath(targetDir, suffix)

fn guiEnsureDirExists(path: str): bool =
    if len(path) == 0:
        return false
    let normalized = textutils.toForwardSlashes(path)
    var parts: str[] = splitPathSegments(normalized)
    var idx: int32 = 0
    var current: str = ""
    if isAbsolute(normalized):
        if len(normalized) >= 2 && normalized[1] == ':':
            if seqLenString(parts) > 0:
                current = seqGetString(parts, 0)
                idx = 1
        elif normalized[0] == '/':
            current = "/"
    for idxIt in idx..<seqLenString(parts):
        let part = seqGetString(parts, idxIt)
        if len(part) > 0:
            if len(current) == 0:
                current = part
            else:
                current = joinPath(current, part)
            if len(current) > 0 && ! dirExists(current):
                createDir(current)
    return true

fn explorerItemPath(roots: str[], root: str, item: str): str =
    let rawPath = explorerItemPathPart(item)
    let trimmed = trimLine(rawPath)
    if len(trimmed) == 0:
        return ""
    if lineEndsWithSlash(trimmed):
        return ""
    return workspaceResolvePath(trimmed, roots, root)

fn findExplorerIndex(items: str[], roots: str[], root: str, path: str): int32 =
    for idx in 0..<seqLenString(items):
        let candidate = explorerItemPath(roots, root, seqGetString(items, idx))
        if len(candidate) > 0 && candidate == path:
            return idx
    return -1

fn guiRevealExplorerPath(state: GuiState, path: str): GuiState =
    if len(path) == 0:
        return state
    state.explorer = explorerRevealPath(state.explorer, state.workspaceRoots, state.projectRoot, path)
    state.explorer.selected = findExplorerIndex(state.explorer.items, state.workspaceRoots, state.projectRoot, path)
    if state.explorer.selected >= 0:
        state.explorer = ensureExplorerVisible(state.explorer, state.layout)
    return state

fn guiReloadExplorer(state: GuiState): GuiState =
    var selectedPath: str = ""
    if state.explorer.selected >= 0 && state.explorer.selected < seqLenString(state.explorer.items):
        selectedPath = explorerItemPath(state.workspaceRoots, state.projectRoot, seqGetString(state.explorer.items, state.explorer.selected))
    let collapsed: str[] = state.explorer.collapsed
    let config: WorkspaceConfig = guiWorkspaceConfigLoad(state.projectRoot)
    state.explorer = loadExplorerState(state.workspaceRoots, demoFiles, config)
    state.explorer.collapsed = collapsed
    state.explorer.items = explorerVisibleItems(state.explorer.allItems, state.explorer.collapsed)
    if len(selectedPath) > 0:
        state = guiRevealExplorerPath(state, selectedPath)
    elif len(state.editor.filePath) > 0:
        state = guiRevealExplorerPath(state, state.editor.filePath)
    return state

fn guiHandleExplorerHeaderAction(state: GuiState, action: int32): GuiState =
    var next: GuiState = state
    if action == ExplorerActionNewFile:
        next = startOverlay(next, okNewFile)
        return next
    if action == ExplorerActionNewFolder:
        next = startOverlay(next, okNewFolder)
        return next
    if action == ExplorerActionRefresh:
        next = guiReloadExplorer(next)
        next = guiVcsRefreshSilent(next)
        next.statusMsg = "explorer: refreshed"
        return next
    if action == ExplorerActionCollapseAll:
        next.explorer = explorerCollapseAll(next.explorer)
        next.explorer = ensureExplorerSelection(next.explorer)
        next.explorer = ensureExplorerVisible(next.explorer, next.layout)
        next = guiWorkspaceStateSave(next)
        next.statusMsg = "explorer: collapsed"
        return next
    return next

fn guiSearchClear(state: GuiState): GuiState =
    state.search.query = ""
    state.search.matchLine = -1
    state.search.matchCol = -1
    state.searchResults = default[str[]]
    state.searchTotal = 0
    state.searchTruncated = false
    state.searchScroll = 0
    state.statusMsg = "search: cleared"
    return state

fn guiHandleSearchHeaderAction(state: GuiState, action: int32): GuiState =
    var next: GuiState = state
    if action == SearchActionFind:
        next.searchProject = true
        next = startOverlay(next, okSearch)
        return next
    if action == SearchActionClear:
        return guiSearchClear(next)
    return next

when defined(android) || defined(ios) || defined(mobile_host):
    fn guiCodexHasAuthToken(): bool =
        return false

    fn guiCodexAppendAuthStatus(state: GuiState): GuiState =
        return state

    fn guiCodexExtractOutput(payload: str): str =
        return payload

    fn guiCodexFinishDraftFromBuffer(state: GuiState, buffer: EditorState): GuiState =
        return state

    fn guiCodexOpenTarget(state: GuiState, target: str): GuiState =
        return state

    fn guiCodexConnect(state: GuiState): GuiState =
        return state

    fn drawCodexPanel(pixels: void*, width, height, strideBytes: int32, theme: GuiTheme, state: GuiState, layout: GuiLayout,
                      panelX: int32, panelTop: int32, panelW: int32, panelH: int32, headerTop: int32, hoverRow: int32) =
        pixels
        width
        height
        strideBytes
        theme
        state
        layout
        panelX
        panelTop
        panelW
        panelH
        headerTop
        hoverRow

    fn guiCodexClear(state: GuiState): GuiState =
        var next = state
        next.statusMsg = "codex: not supported"
        return next

    fn guiCodexAddSelection(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexAddText(state: GuiState, text: str): GuiState =
        text
        return guiCodexClear state

    fn guiCodexAddFile(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexAsk(state: GuiState, prompt: str): GuiState =
        prompt
        return guiCodexClear state

    fn guiCodexAskSelection(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexAskFile(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexReview(state: GuiState, prompt: str): GuiState =
        prompt
        return guiCodexClear state

    fn guiCodexReviewSelection(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexReviewFile(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexTodo(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexTodoLine(lineText: str): bool =
        lineText
        return false

    fn guiCodexExec(state: GuiState, prompt: str): GuiState =
        prompt
        return guiCodexClear state

    fn guiCodexApply(state: GuiState, patchPath: str): GuiState =
        patchPath
        return guiCodexClear state

    fn guiCodexApplyLastDiff(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexApplyStartFocus(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexPreviewLastDiff(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexPreviewPatch(state: GuiState, patchPath: str): GuiState =
        patchPath
        return guiCodexClear state

    fn guiCodexApprove(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexDecline(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexInterrupt(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexStop(state: GuiState, reason: str): GuiState =
        reason
        return guiCodexClear state

    fn guiCodexRecordHistory(state: GuiState, text: str): GuiState =
        text
        return state

    fn guiCodexStartDraft(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexSyncDraftFromEditor(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexNewThread(state: GuiState, preview: str): GuiState =
        preview
        return guiCodexClear state

    fn guiCodexListThreads(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexSelectThread(state: GuiState, threadId: str): GuiState =
        threadId
        return guiCodexClear state

    fn guiCodexResumeThread(state: GuiState, threadId: str): GuiState =
        threadId
        return guiCodexClear state

    fn guiCodexLogin(state: GuiState, token: str): GuiState =
        token
        return guiCodexClear state

    fn guiCodexLogout(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexStartLoginFlow(state: GuiState): GuiState =
        return guiCodexClear state

    fn codexComputeMetaY(state: GuiState, layout: GuiLayout, contentX, contentMaxW, contentListY: float64): float64 =
        state
        layout
        contentX
        contentMaxW
        contentListY
        return 0.0

    fn codexComputeActionLayout(state: GuiState, layout: GuiLayout, contentX, contentMaxW, metaY: float64,
                                outCalloutTitle: var str, outCalloutBody: var str,
                                outCalloutX, outCalloutY, outCalloutW, outCalloutH: var float64,
                                outCalloutRects: var CodexActionRect[], outExtraRects: var CodexActionRect[],
                                outActionBottom: var float64) =
        state
        layout
        contentX
        contentMaxW
        metaY
        outCalloutTitle = ""
        outCalloutBody = ""
        outCalloutX = 0.0
        outCalloutY = 0.0
        outCalloutW = 0.0
        outCalloutH = 0.0
        outCalloutRects = default[CodexActionRect[]]
        outExtraRects = default[CodexActionRect[]]
        outActionBottom = 0.0

    fn guiCodexIsRunning(state: GuiState): bool =
        state
        return false

    fn guiCodexIsBusy(state: GuiState): bool =
        state
        return false

    fn guiCodexHistoryPrev(state: GuiState): GuiState =
        return state

    fn guiCodexHistoryNext(state: GuiState): GuiState =
        return state

    fn guiCodexQueuePrompt(state: GuiState, prompt: str): GuiState =
        prompt
        return guiCodexClear state

    fn guiCodexRecallQueued(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexOpenConfig(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexTodoPromptForLine(state: GuiState, lineIdx: int32, lineText: str): str =
        state
        lineIdx
        lineText
        return ""

    fn guiCodexUrlFromLine(line: str): str =
        line
        return ""

    fn guiCodexOpenTargetFromLine(line: str): str =
        line
        return ""

    fn guiCodexThreadIdFromLine(line: str): str =
        line
        return ""

    fn guiCodexFeedbackCancel(state: GuiState): GuiState =
        return guiCodexClear state

    fn guiCodexFeedbackHandleInput(state: GuiState, input: str, outHandled: var bool, outClearInput: var bool): GuiState =
        input
        outHandled = false
        outClearInput = false
        return state

    fn guiCodexHandleSlashCommand(state: GuiState, input: str, outHandled: var bool, outClearInput: var bool): GuiState =
        input
        outHandled = false
        outClearInput = false
        return state

    fn guiCodexAuthTick(state: GuiState): GuiState =
        return state

    fn guiCodexTick(state: GuiState): GuiState =
        return state

    fn guiDebugBackendRun(state: GuiState, action: str, args: str): GuiState =
        action
        args
        var next = state
        next.statusMsg = "debugger: not supported"
        return next

    fn guiDebuggerHeader(state: DebuggerState): str =
        state
        return ""

    fn guiDebuggerLines(state: DebuggerState): str[] =
        state
        return default[str[]]

    fn guiDebuggerClear(state: GuiState): GuiState =
        var next = state
        next.statusMsg = "debugger: not supported"
        return next

    fn guiDebuggerSetStatus(state: GuiState, status: str, reason: str): GuiState =
        status
        reason
        return state

    fn guiDebuggerLoad(state: GuiState, path: str): GuiState =
        path
        return guiDebuggerClear state

    fn guiDebuggerRefresh(state: GuiState): GuiState =
        return guiDebuggerClear state

    fn guiDebuggerAddBreakpoint(state: GuiState, target: str): GuiState =
        target
        return guiDebuggerClear state

    fn guiDebuggerRemoveBreakpoint(state: GuiState, token: str): GuiState =
        token
        return guiDebuggerClear state

    fn guiDebuggerHelp(state: GuiState): GuiState =
        return guiDebuggerClear state

    fn guiDebuggerAddWatch(state: GuiState, expr: str): GuiState =
        expr
        return guiDebuggerClear state

    fn guiDebuggerRemoveWatch(state: GuiState, token: str): GuiState =
        token
        return guiDebuggerClear state

    fn guiDebuggerListWatches(state: GuiState): GuiState =
        return guiDebuggerClear state

    fn guiVcsBranchFromSummary(summary: str): str =
        summary
        return ""

    fn guiVcsDiffCommand(state: GuiState, arg: str): VcsCommand =
        state
        arg
        var outVal: VcsCommand
        outVal.cmd = ""
        outVal.workDir = ""
        return outVal

    fn guiVcsCounts(lines: str[]): VcsCounts =
        lines
        var outVal: VcsCounts
        outVal.staged = 0
        outVal.unstaged = 0
        outVal.untracked = 0
        outVal.conflicts = 0
        return outVal

    fn guiVcsCountsLabel(counts: VcsCounts): str =
        counts
        return ""

    fn guiVcsBlame(state: GuiState, arg: str): GuiState =
        arg
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsHistory(state: GuiState, arg: str): GuiState =
        arg
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsStage(state: GuiState, arg: str): GuiState =
        arg
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsUnstage(state: GuiState, arg: str): GuiState =
        arg
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsCommit(state: GuiState, message: str): GuiState =
        message
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsListBranches(state: GuiState): GuiState =
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsCreateBranch(state: GuiState, name: str): GuiState =
        name
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsDeleteBranch(state: GuiState, name: str, force: bool): GuiState =
        name
        force
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsCheckout(state: GuiState, name: str): GuiState =
        name
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsSwitch(state: GuiState, name: str): GuiState =
        name
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsListConflicts(state: GuiState): GuiState =
        var next = state
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsRefreshSilent(state: GuiState): GuiState =
        var next = state
        next.vcsRoot = ""
        next.vcsSummary = "not supported"
        next.vcsLines = default[str[]]
        return next

    fn guiVcsRefresh(state: GuiState): GuiState =
        var next = guiVcsRefreshSilent(state)
        next.statusMsg = "vcs: not supported"
        return next

    fn guiVcsRunCommand(state: GuiState, label: str, command: str, workDir: str): VcsRunResult =
        var outVal: VcsRunResult
        outVal.state = state
        outVal.exitCode = 1
        outVal.state.statusMsg = "vcs: not supported"
        return outVal

fn guiVcsStageAll(state: GuiState): GuiState =
    let res: VcsRunResult = guiVcsRunCommand(state, "stage", "git add -A", guiWorkspaceActiveRoot(state))
    return res.state

fn guiVcsUnstageAll(state: GuiState): GuiState =
    let res: VcsRunResult = guiVcsRunCommand(state, "unstage", "git restore --staged -- .", guiWorkspaceActiveRoot(state))
    if res.exitCode == 0:
        return res.state
    let fallback: VcsRunResult = guiVcsRunCommand(res.state, "unstage", "git reset -q HEAD -- .", guiWorkspaceActiveRoot(res.state))
    return fallback.state

fn guiHandleVcsHeaderAction(state: GuiState, action: int32): GuiState =
    var next: GuiState = state
    if action == VcsActionRefresh:
        next = guiVcsRefreshSilent(next)
        next.statusMsg = "vcs: refreshed"
        return next
    if action == VcsActionStageAll:
        return guiVcsStageAll(next)
    if action == VcsActionUnstageAll:
        return guiVcsUnstageAll(next)
    if action == VcsActionCommit:
        next = startOverlay(next, okCommand)
        next.overlay.input = "commit "
        return next
    return next

fn guiHandleActivityBottomAction(state: GuiState, idx: int32): GuiState =
    var next: GuiState = state
    if idx == ActivityBottomAccount:
        next = guiCodexShow(next)
        if guiCodexHasAuthToken():
            next = guiCodexAppendAuthStatus(next)
            next.statusMsg = "codex: auth"
            return next
        next = startOverlay(next, okCommand)
        next.overlay.input = "codex login "
        next.statusMsg = "codex: login"
        return next
    if idx == ActivityBottomSettings:
        next = startOverlay(next, okCommand)
        next.overlay.input = "theme "
        next.statusMsg = "theme"
        return next
    return next

fn guiWorkspaceStateDir(root: str): str =
    let base = if len(root) > 0: root else: getCurrentDir()
    return joinPath(base, WorkspaceStateDir)

fn guiWorkspaceStatePath(root: str): str =
    return joinPath(guiWorkspaceStateDir(root), WorkspaceStateFile)

fn guiWorkspaceStateNormalizePath(roots: str[], root: str, value: str): str =
    let trimmed = trimLine(value)
    if len(trimmed) == 0:
        return ""
    return workspaceResolvePath(trimmed, roots, root)

fn guiWorkspacePickInitialFile(roots: str[], root: str, state: WorkspaceState): str =
    if len(state.activePath) > 0:
        let resolved = guiWorkspaceStateNormalizePath(roots, root, state.activePath)
        if len(resolved) > 0 && fileExists(resolved):
            return resolved
    for idx in 0..<seqLenString(state.openFiles):
        let resolved = guiWorkspaceStateNormalizePath(roots, root, seqGetString(state.openFiles, idx))
        if len(resolved) > 0 && fileExists(resolved):
            return resolved
    return ""

fn guiWorkspaceStateLoad(root: str): WorkspaceState =
    var state: WorkspaceState = defaultWorkspaceState()
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return state
    let path = guiWorkspaceStatePath(root)
    if ! fileExists(path):
        return state
    let lines: str[] = splitLinesSimple(readFile(path))
    for idx in 0..<seqLenString(lines):
        let raw = trimLine(seqGetString(lines, idx))
        if len(raw) == 0:
            continue
        let sep: int32 = indexOfSubstr(raw, "=", 0)
        if sep < 0:
            continue
        let key = if sep > 0: sliceRange(raw, 0, sep - 1) else: ""
        let value = if sep + 1 <= len(raw) - 1: sliceFrom(raw, sep + 1) else: ""
        if key == "active":
            state.activePath = value
        elif key == "open":
            if seqLenString(state.openFiles) < MaxWorkspaceFiles:
                addUniqueString(&state.openFiles, value)
        elif key == "collapsed":
            if seqLenString(state.collapsed) < MaxWorkspaceCollapsed:
                addUniqueString(&state.collapsed, value)
        elif key == "term":
            if seqLenString(state.terminalLabels) < MaxWorkspaceTerminals:
                addPtr_string(&state.terminalLabels, value)
        elif key == "term_active":
            state.terminalActive = parseInt32(value, 1) - 1
        elif key == "theme":
            state.themeName = trimLine(value)
        elif key == "autosave":
            state.autoSave = if parseBool(value, false): 1 else: 0
        elif key == "format_on_save" || key == "formatonsave" || key == "format_on_save_flag":
            state.formatOnSave = if parseBool(value, false): 1 else: 0
        elif key == "split" || key == "split_active":
            state.splitActive = if parseBool(value, false): 1 else: 0
        elif key == "split_pane" || key == "splitpane":
            state.splitPane = parseInt32(value, -1)
        elif key == "left_w" || key == "left_width":
            state.leftPaneWidth = parseInt32(value, -1)
        elif key == "right_w" || key == "right_width":
            state.rightPaneWidth = parseInt32(value, -1)
        elif key == "left_visible":
            state.leftPaneVisible = if parseBool(value, true): 1 else: 0
        elif key == "left_tab":
            state.leftPaneTab = parseInt32(value, -1)
        elif key == "right_visible":
            state.rightPaneVisible = if parseBool(value, true): 1 else: 0
        elif key == "right_tab":
            state.rightPaneTab = parseInt32(value, -1)
        elif key == "bottom_visible":
            state.bottomPaneVisible = if parseBool(value, true): 1 else: 0
        elif key == "bottom_tab":
            state.bottomPaneTab = parseInt32(value, -1)
        elif key == "bottom_h" || key == "bottom_height":
            state.bottomPaneHeight = parseInt32(value, -1)
    return state

fn guiWorkspaceStateCollectOpenFiles(state: GuiState): str[] =
    var outVal: str[] = default[str[]]
    for idx in 0..<bufferLen(state.buffers):
        let buffer: EditorState = bufferGet(state.buffers, idx)
        if len(buffer.filePath) > 0 && fileExists(buffer.filePath):
            if seqLenString(outVal) < MaxWorkspaceFiles:
                addUniqueString(&outVal, buffer.filePath)
    return outVal

fn guiWorkspaceStateEncodePath(state: GuiState, path: str): str =
    if len(path) == 0:
        return ""
    if seqLenString(state.workspaceRoots) > 1:
        let encoded = workspaceEncodePathForRoots(path, state.workspaceRoots)
        if len(encoded) > 0:
            return encoded
    return pathRelativeToRoot(state.projectRoot, path)

fn guiWorkspaceStateEncode(state: GuiState): str =
    var lines: str[] = default[str[]]
    addPtr_string(&lines, "version=1")
    if len(state.themeName) > 0:
        addPtr_string(&lines, "theme=" + state.themeName)
    let autosaveFlag = if state.autoSave: "1" else: "0"
    addPtr_string(&lines, "autosave=" + autosaveFlag)
    let formatFlag = if state.formatOnSave: "1" else: "0"
    addPtr_string(&lines, "format_on_save=" + formatFlag)
    let splitFlag = if state.editor.splitActive: "1" else: "0"
    addPtr_string(&lines, "split=" + splitFlag)
    addPtr_string(&lines, "split_pane=" + intToStr(state.editor.splitPane))
    if state.leftPaneWidth > 0:
        addPtr_string(&lines, "left_w=" + intToStr(state.leftPaneWidth))
    let leftVisibleFlag = if state.leftPaneVisible: "1" else: "0"
    addPtr_string(&lines, "left_visible=" + leftVisibleFlag)
    addPtr_string(&lines, "left_tab=" + intToStr(leftPaneTabIndex(state.leftPaneTab)))
    if state.rightPaneWidth > 0:
        addPtr_string(&lines, "right_w=" + intToStr(state.rightPaneWidth))
    let rightVisibleFlag = if state.rightPaneVisible: "1" else: "0"
    addPtr_string(&lines, "right_visible=" + rightVisibleFlag)
    addPtr_string(&lines, "right_tab=" + intToStr(rightPaneTabIndex(state.rightPaneTab)))
    let bottomVisibleFlag = if state.bottomPaneVisible: "1" else: "0"
    addPtr_string(&lines, "bottom_visible=" + bottomVisibleFlag)
    addPtr_string(&lines, "bottom_tab=" + intToStr(bottomPaneTabIndex(state.bottomPaneTab)))
    if state.bottomPaneHeight > 0:
        addPtr_string(&lines, "bottom_h=" + intToStr(state.bottomPaneHeight))
    var active: str = ""
    if len(state.editor.filePath) > 0 && fileExists(state.editor.filePath):
        active = guiWorkspaceStateEncodePath(state, state.editor.filePath)
    if len(active) > 0:
        addPtr_string(&lines, "active=" + active)
    let files: str[] = guiWorkspaceStateCollectOpenFiles(state)
    for idx in 0..<seqLenString(files):
        let entry = guiWorkspaceStateEncodePath(state, seqGetString(files, idx))
        if len(entry) > 0:
            addPtr_string(&lines, "open=" + entry)
    for idx in 0..<seqLenString(state.explorer.collapsed):
        if idx >= MaxWorkspaceCollapsed:
            break
        addPtr_string(&lines, "collapsed=" + seqGetString(state.explorer.collapsed, idx))
    let termCount: int32 = terminalSessionLen(state.terminalSessions)
    if termCount > 0:
        let activeIdx: int32 = clampInt(state.terminalSessionActive, 0, termCount - 1)
        addPtr_string(&lines, "term_active=" + intToStr(activeIdx + 1))
    for idx in 0..<termCount:
        if idx >= MaxWorkspaceTerminals:
            break
        let session: TerminalState = terminalSessionGet(state.terminalSessions, idx)
        let label = if len(session.label) > 0: session.label else: "term-" + intToStr(idx + 1)
        addPtr_string(&lines, "term=" + label)
    return joinLines(lines) + "\n"

fn guiDesktopBridgePath(root: str): str =
    return joinPath(guiWorkspaceStateDir(root), DesktopBridgeFile)

fn guiDesktopCommandPath(root: str): str =
    let override: str = getEnv("CHENG_IDE_COMMAND_PATH")
    if len(override) > 0:
        return override
    return joinPath(guiWorkspaceStateDir(root), DesktopCommandFile)

fn guiDesktopCommandAckPath(root: str): str =
    let override: str = getEnv("CHENG_IDE_COMMAND_ACK_PATH")
    if len(override) > 0:
        return override
    return joinPath(guiWorkspaceStateDir(root), DesktopCommandAckFile)

fn guiDesktopBridgeSanitize(text: str): str =
    if len(text) == 0:
        return ""
    var outVal: str = ""
    for idx in 0..<len(text):
        let ch: char = text[idx]
        if ch == '\n' || ch == '\r':
            outVal = outVal + " "
        else:
            outVal = outVal + charToStr(ch)
    return trimLine(outVal)

fn guiDesktopCommandEnabled(): bool =
    return envFlagEnabled(getEnv("CHENG_IDE_COMMAND"), true)

fn guiDesktopCommandParse(content: str): DesktopCommand =
    var cmd: DesktopCommand
    cmd.id = ""
    cmd.schema = ""
    cmd.command = ""
    cmd.path = ""
    cmd.line = 0
    cmd.col = 0
    let lines: str[] = splitLinesSimple(content)
    for idx in 0..<seqLenString(lines):
        let trimmed = trimLine(seqGetString(lines, idx))
        if len(trimmed) == 0 || trimmed[0] == '#':
            continue
        let sep: int32 = indexOfSubstr(trimmed, "=", 0)
        if sep >= 0:
            let key = if sep > 0: sliceRange(trimmed, 0, sep - 1) else: ""
            let value = if sep + 1 < len(trimmed): sliceFrom(trimmed, sep + 1) else: ""
            if key == "command_id":
                cmd.id = trimLine(value)
            elif key == "command_schema":
                cmd.schema = trimLine(value)
            elif key == "command":
                cmd.command = trimLine(value)
            elif key == "path":
                cmd.path = trimLine(value)
            elif key == "line":
                cmd.line = parseInt32(value, 0)
            elif key == "col":
                cmd.col = parseInt32(value, 0)
    return cmd

fn guiDesktopCommandAckEncode(cmd: DesktopCommand, status: str, errorCode: str, message: str, retryable: bool): str =
    var lines: str[] = default[str[]]
    if len(cmd.id) > 0:
        addPtr_string(&lines, "command_id=" + cmd.id)
    if len(cmd.command) > 0:
        addPtr_string(&lines, "command=" + cmd.command)
    addPtr_string(&lines, "command_schema=" + IdeCommandSchemaVersion)
    addPtr_string(&lines, "status=" + status)
    let retryableFlag = if retryable: "1" else: "0"
    addPtr_string(&lines, "retryable=" + retryableFlag)
    if len(errorCode) > 0:
        addPtr_string(&lines, "error_code=" + errorCode)
    if len(message) > 0:
        addPtr_string(&lines, "message=" + guiDesktopBridgeSanitize(message))
    addPtr_string(&lines, "timestamp_ms=" + int64ToStr(guiEpochMs()))
    return joinLines(lines) + "\n"

fn guiDesktopCommandWriteAck(state: GuiState, cmd: DesktopCommand, status: str, errorCode: str, message: str, retryable: bool): GuiState =
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return state
    let path = guiDesktopCommandAckPath(state.projectRoot)
    if len(path) == 0:
        return state
    let dir = guiWorkspaceStateDir(state.projectRoot)
    guiEnsureDirExists(dir)
    let content = guiDesktopCommandAckEncode(cmd, status, errorCode, message, retryable)
    guiWriteTextAtomic(path, content)
    return state

fn guiDesktopCommandHandle(state: GuiState, cmd: DesktopCommand): GuiState =
    var next: GuiState = state
    var status = "ok"
    var errorCode = ""
    var message = ""
    var retryable = false
    if len(cmd.schema) > 0 && cmd.schema != IdeCommandSchemaVersion:
        status = "error"
        errorCode = "schema_mismatch"
        message = "schema " + cmd.schema
    elif len(cmd.command) == 0:
        status = "error"
        errorCode = "missing_command"
        message = "missing command"
    else:
        let lowered = textutils.toLowerAscii(cmd.command)
        if lowered == "open":
            if len(cmd.path) == 0:
                status = "error"
                errorCode = "missing_path"
                message = "missing path"
                retryable = true
            else:
                let resolved = resolveWorkspacePath(next, cmd.path)
                if len(resolved) == 0 || ! fileExists(resolved):
                    status = "error"
                    errorCode = "file_not_found"
                    message = cmd.path
                    retryable = true
                else:
                    var input = cmd.path
                    if cmd.line > 0:
                        input = input + ":" + intToStr(cmd.line)
                        if cmd.col > 0:
                            input = input + ":" + intToStr(cmd.col)
                    next = openEditorInput(next, input)
                    message = "open"
        elif lowered == "locate":
            if cmd.line <= 0:
                status = "error"
                errorCode = "missing_line"
                message = "missing line"
                retryable = true
            else:
                var target = cmd.path
                if len(target) == 0:
                    target = next.editor.filePath
                if len(target) == 0:
                    status = "error"
                    errorCode = "missing_path"
                    message = "missing path"
                    retryable = true
                else:
                    let resolved = resolveWorkspacePath(next, target)
                    if len(resolved) == 0 || ! fileExists(resolved):
                        status = "error"
                        errorCode = "file_not_found"
                        message = target
                        retryable = true
                    else:
                        var input = target + ":" + intToStr(cmd.line)
                        if cmd.col > 0:
                            input = input + ":" + intToStr(cmd.col)
                        next = openEditorInput(next, input)
                        message = "locate"
        elif lowered == "build" || lowered == "run" || lowered == "diag":
            if lowered == "diag":
                if len(cmd.path) > 0:
                    let resolved = resolveWorkspacePath(next, cmd.path)
                    if len(resolved) == 0 || ! fileExists(resolved):
                        status = "error"
                        errorCode = "file_not_found"
                        message = cmd.path
                        retryable = true
                    else:
                        next = openEditorInput(next, cmd.path)
                elif len(next.editor.filePath) == 0:
                    status = "error"
                    errorCode = "missing_path"
                    message = "missing file"
                    retryable = true
            if status != "error":
                next = guiTaskHandleInput(next, lowered)
                status = "queued"
                message = lowered
                retryable = true
        else:
            status = "error"
            errorCode = "unknown_command"
            message = cmd.command
    next = guiDesktopCommandWriteAck(next, cmd, status, errorCode, message, retryable)
    next.renderDirty = true
    return next

fn guiDesktopCommandTick(state: GuiState): GuiState =
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return state
    if ! guiDesktopCommandEnabled():
        return state
    var next: GuiState = state
    let nowMs: int64 = guiNowMs()
    if next.desktopCommandPollMs > 0 && next.desktopCommandNextMs > 0 && nowMs < next.desktopCommandNextMs:
        return next
    if next.desktopCommandPollMs > 0:
        next.desktopCommandNextMs = nowMs + int64(next.desktopCommandPollMs)
    let path = guiDesktopCommandPath(next.projectRoot)
    if len(path) == 0 || ! fileExists(path):
        return next
    let content = readFile(path)
    if len(content) == 0 || len(content) > 65536:
        return next
    let cmd = guiDesktopCommandParse(content)
    if len(cmd.id) == 0:
        return next
    if cmd.id == next.desktopCommandLastId:
        return next
    next = guiDesktopCommandHandle(next, cmd)
    next.desktopCommandLastId = cmd.id
    if fileExists(path):
        removeFile(path)
    return next

fn guiDesktopBridgeCountDiag(diags: diag.seq_GuiDiagnostic, sev: diag.GuiDiagSeverity): int32 =
    var count: int32 = 0
    for idx in 0..<diags.len:
        let item: diag.GuiDiagnostic = diag.guiDiagGet_GuiDiagnostic(diags, idx)
        if item.severity == sev:
            count = count + 1
    return count

fn guiDesktopBridgeTaskLine(state: GuiState): str =
    let total: int32 = seqLenString(state.taskLog)
    if total <= 0:
        return ""
    let line = guiDesktopBridgeSanitize(seqGetString(state.taskLog, total - 1))
    if len(line) > MaxDesktopBridgeTaskLine:
        return slicePrefix(line, MaxDesktopBridgeTaskLine)
    return line

fn guiIdeVersion(): str =
    let override: str = getEnv("CHENG_IDE_VERSION")
    if len(override) > 0:
        return override
    return IdeVersionDefault

fn guiDesktopBridgeEncode(state: GuiState): str =
    var lines: str[] = default[str[]]
    addPtr_string(&lines, "version=1")
    addPtr_string(&lines, "bridge_schema=" + IdeBridgeSchemaVersion)
    addPtr_string(&lines, "ide_version=" + guiIdeVersion())
    addPtr_string(&lines, "capabilities=" + IdeBridgeCapabilities)
    if len(state.projectRoot) > 0:
        addPtr_string(&lines, "root=" + state.projectRoot)
    var active: str = ""
    if len(state.editor.filePath) > 0 && fileExists(state.editor.filePath):
        active = guiWorkspaceStateEncodePath(state, state.editor.filePath)
    if len(active) > 0:
        addPtr_string(&lines, "active=" + active)
    let files: str[] = guiWorkspaceStateCollectOpenFiles(state)
    for idx in 0..<seqLenString(files):
        if idx >= MaxDesktopBridgeOpen:
            break
        let entry = guiWorkspaceStateEncodePath(state, seqGetString(files, idx))
        if len(entry) > 0:
            addPtr_string(&lines, "open=" + entry)
    addPtr_string(&lines, "open_count=" + intToStr(seqLenString(files)))
    let errCount = guiDesktopBridgeCountDiag(state.diagnostics, diag.gdsError)
    let warnCount = guiDesktopBridgeCountDiag(state.diagnostics, diag.gdsWarning)
    let infoCount = guiDesktopBridgeCountDiag(state.diagnostics, diag.gdsInfo)
    addPtr_string(&lines, "diag_errors=" + intToStr(errCount))
    addPtr_string(&lines, "diag_warnings=" + intToStr(warnCount))
    addPtr_string(&lines, "diag_info=" + intToStr(infoCount))
    let activeFlag = if state.taskRunner.active: "1" else: "0"
    addPtr_string(&lines, "task_active=" + activeFlag)
    if len(state.taskRunner.job.label) > 0:
        addPtr_string(&lines, "task_label=" + guiDesktopBridgeSanitize(state.taskRunner.job.label))
    var runner = state.taskRunner
    addPtr_string(&lines, "task_queue=" + intToStr(guiTaskQueueLen(runner)))
    let lastTask = guiDesktopBridgeTaskLine(state)
    if len(lastTask) > 0:
        addPtr_string(&lines, "task_last=" + lastTask)
    if len(state.statusMsg) > 0:
        addPtr_string(&lines, "status=" + guiDesktopBridgeSanitize(state.statusMsg))
    let nowMs: int64 = guiEpochMs()
    addPtr_string(&lines, "timestamp_ms=" + int64ToStr(nowMs))
    addPtr_string(&lines, "heartbeat_ts=" + int64ToStr(nowMs))
    return joinLines(lines) + "\n"

fn guiWriteTextAtomic(path: str, content: str): bool =
    let tmpPath = path + ".tmp"
    let f: File = open(tmpPath, fmWrite)
    if f == nil:
        return false
    write(f, content)
    close(f)
    if renameFile(tmpPath, path):
        return true
    if fileExists(path):
        removeFile(path)
        if renameFile(tmpPath, path):
            return true
    if fileExists(tmpPath):
        removeFile(tmpPath)
    return false

fn guiDesktopBridgeSave(state: GuiState): GuiState =
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return state
    if ! envFlagEnabled(getEnv("CHENG_IDE_BRIDGE"), true):
        return state
    if len(state.projectRoot) == 0:
        return state
    let dir = guiWorkspaceStateDir(state.projectRoot)
    guiEnsureDirExists(dir)
    let path = guiDesktopBridgePath(state.projectRoot)
    let content = guiDesktopBridgeEncode(state)
    if ! guiWriteTextAtomic(path, content):
        let f: File = open(path, fmWrite)
        if f != nil:
            write(f, content)
            close(f)
    return state

fn guiWorkspaceStateSave(state: GuiState): GuiState =
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return state
    if len(state.projectRoot) == 0:
        return state
    let debugIO: bool = envFlagEnabled(getEnv("CHENG_IDE_DEBUG_IO"), false)
    if debugIO:
        textutils.print("[io] workspace save start\n")
    var next: GuiState = syncActiveBuffer(state)
    if debugIO:
        textutils.print("[io] buffers synced\n")
    next = guiTerminalSyncActiveSession(next)
    if debugIO:
        textutils.print("[io] terminal synced\n")
    let dir = guiWorkspaceStateDir(next.projectRoot)
    guiEnsureDirExists(dir)
    let path = guiWorkspaceStatePath(next.projectRoot)
    let content = guiWorkspaceStateEncode(next)
    if debugIO:
        textutils.print("[io] write " + path + "\n")
    let f: File = open(path, fmWrite)
    if f == nil:
        if debugIO:
            textutils.print("[io] open failed\n")
        next.statusMsg = "workspace save failed"
        return next
    if debugIO:
        textutils.print("[io] open ok\n")
    write(f, content)
    close(f)
    if debugIO:
        textutils.print("[io] write done\n")
    next = guiDesktopBridgeSave(next)
    return next

fn sanitizeRecoveryName(name: str): str =
    if len(name) == 0:
        return "file"
    var outVal: str = ""
    for idx in 0..<len(name):
        let ch: char = name[idx]
        if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_' || ch == '-' || ch == '.':
            outVal = outVal + charToStr(ch)
        else:
            outVal = outVal + "_"
    if len(outVal) == 0:
        outVal = "file"
    if len(outVal) > 64:
        outVal = slicePrefix(outVal, 64)
    return outVal

fn int64ToStr(value: int64): str =
    if value == 0:
        return "0"
    var v: int64 = value
    var neg = false
    if v < 0:
        neg = true
        v = 0 - v
    var outVal: str = ""
    while v > 0:
        let digit: int64 = v % 10
        let ch: char = chr(int32(digit) + 48)
        outVal = charToStr(ch) + outVal
        v = v / 10
    if neg:
        outVal = "-" + outVal
    return outVal

fn hashString32(text: str): int32 =
    var h: uint32 = 2166136261
    for idx in 0..<len(text):
        h = h ^ uint32(ord(text[idx]))
        h = h * 16777619
    var signed: int32 = int32(h)
    if signed < 0:
        signed = -signed
    return signed

fn guiRecoveryDir(root: str): str =
    return joinPath(guiWorkspaceStateDir(root), RecoveryDirName)

fn guiRecoveryPathFor(state: GuiState, path: str): str =
    if len(path) == 0:
        return ""
    let base = sanitizeRecoveryName(extractFilename(path))
    let hashVal = intToStr(hashString32(path))
    let fileName = base + "-" + hashVal + ".recover"
    return joinPath(guiRecoveryDir(state.projectRoot), fileName)

fn guiRecoveryMaybeLoad(state: GuiState, editor: EditorState): RecoveryLoad =
    var outVal: RecoveryLoad
    outVal.editor = editor
    outVal.recovered = false
    if ! state.recoveryEnabled:
        return outVal
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return outVal
    if len(editor.filePath) == 0:
        return outVal
    let maxBytes: int32 = largeFileLimitFromEnv("CHENG_IDE_RECOVERY_BYTES", RecoveryMaxBytes)
    if maxBytes <= 0:
        return outVal
    if editor.largeFile || (editor.largeFileBytes > 0 && editor.largeFileBytes >= maxBytes):
        return outVal
    let path = guiRecoveryPathFor(state, editor.filePath)
    if len(path) == 0 || ! fileExists(path):
        return outVal
    let snapshot = readFile(path)
    if len(snapshot) == 0:
        return outVal
    let baseContent = joinLines(editor.lines)
    let headerEnd: int32 = indexOfSubstr(snapshot, "\n", 0)
    if headerEnd < 0:
        return outVal
    let body = if headerEnd + 1 <= len(snapshot) - 1: sliceFrom(snapshot, headerEnd + 1) else: ""
    if body == baseContent:
        removeFile(path)
        return outVal
    var recovered: EditorState = applyUndoSnapshot(editor, snapshot)
    recovered.dirty = true
    outVal.editor = recovered
    outVal.recovered = true
    return outVal

fn guiRecoveryClearForPath(state: GuiState, path: str): GuiState =
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return state
    if len(path) == 0:
        return state
    let recoveryPath = guiRecoveryPathFor(state, path)
    if len(recoveryPath) == 0:
        return state
    if fileExists(recoveryPath):
        removeFile(recoveryPath)
    return state

fn guiRecoveryWriteAll(state: GuiState): GuiState =
    if ! state.recoveryEnabled:
        return state
    if state.autoSave:
        return state
    let skipIO: str = getEnv("CHENG_IDE_SKIP_IO")
    if len(skipIO) > 0:
        return state
    var next: GuiState = syncActiveBuffer(state)
    let maxBytes: int32 = largeFileLimitFromEnv("CHENG_IDE_RECOVERY_BYTES", RecoveryMaxBytes)
    if maxBytes <= 0:
        return next
    let debugIO: bool = envFlagEnabled(getEnv("CHENG_IDE_DEBUG_IO"), false)
    let dir = guiRecoveryDir(next.projectRoot)
    guiEnsureDirExists(dir)
    for idx in 0..<bufferLen(next.buffers):
        let buffer: EditorState = bufferGet(next.buffers, idx)
        if buffer.dirty && len(buffer.filePath) > 0 && ! buffer.largeFile:
            if buffer.largeFileBytes > 0 && buffer.largeFileBytes >= maxBytes:
                continue
            let snapshot = encodeUndoSnapshot(buffer)
            if len(snapshot) <= maxBytes:
                let path = guiRecoveryPathFor(next, buffer.filePath)
                if len(path) > 0:
                    let f: File = open(path, fmWrite)
                    if f != nil:
                        write(f, snapshot)
                        close(f)
                        if debugIO:
                            textutils.print("[io] recovery write " + path + "\n")
    return next

fn largeFileLimitFromEnv(envName: str, fallback: int32): int32 =
    let raw = getEnv(envName)
    if len(raw) == 0:
        return fallback
    let value: int32 = parseInt32(raw, fallback)
    if value <= 0:
        return fallback
    return value

fn resetSemanticScanState(state: EditorState): EditorState =
    state.semanticScanActive = false
    state.semanticScanLine = 0
    state.semanticScanVersion = state.bufferVersion
    state.semanticScanBuildIdx = 0
    state.semanticScanRaw = default[str[]]
    state.semanticScanEntries = default[str[]]
    state.semanticScanBlockKind = ""
    state.semanticScanBlockIndent = 0
    state.semanticScanBlockChildIndent = -1
    return state

fn invalidateSemanticState(state: EditorState, clearEntries: bool): EditorState =
    state.semanticReady = false
    if clearEntries:
        state.semanticEntries = default[str[]]
    return resetSemanticScanState(state)

fn loadEditorState(path: str, fallbackText: str): EditorState =
    var state: EditorState
    state.cursorLine = 0
    state.cursorCol = 0
    state.desiredCol = 0
    state.scrollLine = 0
    state.splitActive = false
    state.splitPane = 0
    state.splitScrollLine = 0
    state.filePath = path
    state.bufferId = nextBufferId
    nextBufferId = nextBufferId + 1
    state.bufferVersion = 1
    state.dirty = false
    state.selectionActive = false
    state.selectionAnchorLine = 0
    state.selectionAnchorCol = 0
    state.multiCursors = newCursorList()
    state.undoStack = default[str[]]
    state.redoStack = default[str[]]
    state.selectionHistory = default[str[]]
    state.foldedRanges = default[str[]]
    state = invalidateSemanticState(state, true)
    state.outlineReady = false
    state.outlineEntries = default[str[]]
    state.outlineScanActive = false
    state.outlineScanLine = 0
    state.outlineScanVersion = 0
    state.outlineScanEntries = default[str[]]
    var content: str = ""
    if len(path) > 0:
        if fileExists(path):
            content = readFile(path)
        else:
            content = ""
    else:
        content = fallbackText
    var rawLines: str[] = splitLinesSimple(content)
    state.lines = normalizeLines(rawLines)
    let lineLimit: int32 = largeFileLimitFromEnv("CHENG_IDE_LARGE_FILE_LINES", LargeFileLineLimit)
    let byteLimit: int32 = largeFileLimitFromEnv("CHENG_IDE_LARGE_FILE_BYTES", LargeFileByteLimit)
    let lineCount: int32 = seqLenString(state.lines)
    let byteCount: int32 = len(content)
    state.largeFileLines = lineCount
    state.largeFileBytes = byteCount
    state.largeFile = (lineLimit > 0 && lineCount >= lineLimit) || (byteLimit > 0 && byteCount >= byteLimit)
    return state

fn lineLength(state: EditorState, lineIndex: int32): int32 =
    if lineIndex < 0 || lineIndex >= seqLenString(state.lines):
        return 0
    return len(seqGetString(state.lines, lineIndex))

fn splitByChar(text: str, sep: char): str[] =
    var outVal: str[] = default[str[]]
    var start: int32 = 0
    for idx in 0..total:
        if idx == total || text[idx] == sep:
            if idx > start:
                addPtr_string(&outVal, sliceRange(text, start, idx - 1))
            else:
                addPtr_string(&outVal, "")
            start = idx + 1
    return outVal

fn splitCommandArgs(text: str): str[] =
    var outVal: str[] = default[str[]]
    var token: str = ""
    var idx: int32 = 0
    var inQuote: bool = false
    var quoteChar: char = '\0'
    while idx < len(text):
        let ch: char = text[idx]
        if inQuote:
            if ch == '\\' && idx + 1 < len(text):
                let next: char = text[idx + 1]
                if next == quoteChar || next == '\\':
                    token = token + charToStr(next)
                    idx = idx + 2
                    continue
            if ch == quoteChar:
                inQuote = false
            else:
                token = token + charToStr(ch)
            idx = idx + 1
            continue
        if ch == '"' || ch == '\'':
            inQuote = true
            quoteChar = ch
            idx = idx + 1
            continue
        if ch == ' ' || ch == '\t':
            if len(token) > 0:
                addPtr_string(&outVal, token)
                token = ""
            idx = idx + 1
            continue
        token = token + charToStr(ch)
        idx = idx + 1
    if len(token) > 0:
        addPtr_string(&outVal, token)
    return outVal

fn joinTokens(tokens: str[], startIdx: int32): str =
    var outVal: str = ""
    for idx in startIdx..<seqLenString(tokens):
        if len(outVal) > 0:
            outVal = outVal + " "
        outVal = outVal + seqGetString(tokens, idx)
    return outVal

fn parseSingleArg(text: str): str =
    let trimmed = trimLine(text)
    if len(trimmed) == 0:
        return ""
    let tokens: str[] = splitCommandArgs(trimmed)
    if seqLenString(tokens) == 0:
        return ""
    if seqLenString(tokens) == 1:
        return seqGetString(tokens, 0)
    return trimmed

fn parseMoveArgs(text: str): MoveArgs =
    var outVal: MoveArgs
    let trimmed = trimLine(text)
    if len(trimmed) == 0:
        return outVal
    let arrow: int32 = indexOfSubstr(trimmed, "->", 0)
    if arrow >= 0:
        let left = if arrow > 0: sliceRange(trimmed, 0, arrow - 1) else: ""
        let right = if arrow + 2 <= len(trimmed) - 1: sliceFrom(trimmed, arrow + 2) else: ""
        outVal.src = parseSingleArg(left)
        outVal.dst = parseSingleArg(right)
        return outVal
    let tokens: str[] = splitCommandArgs(trimmed)
    if seqLenString(tokens) >= 2:
        outVal.src = seqGetString(tokens, 0)
        outVal.dst = seqGetString(tokens, 1)
    return outVal

fn parseBool(text: str, defaultValue: bool): bool =
    let lowered = textutils.toLowerAscii(trimLine(text))
    if lowered == "1" || lowered == "true" || lowered == "on" || lowered == "yes":
        return true
    if lowered == "0" || lowered == "false" || lowered == "off" || lowered == "no":
        return false
    return defaultValue

fn encodeUndoSnapshot(state: EditorState): str =
    let lineCount: int32 = seqLenString(state.lines)
    let dirtyFlag = if state.dirty: "1" else: "0"
    let selFlag = if state.selectionActive: "1" else: "0"
    let header = intToStr(state.cursorLine) + "\t" + intToStr(state.cursorCol) + "\t" + intToStr(state.desiredCol) + "\t" + intToStr(state.scrollLine) + "\t" + dirtyFlag + "\t" + selFlag + "\t" + intToStr(state.selectionAnchorLine) + "\t" + intToStr(state.selectionAnchorCol) + "\t" + intToStr(lineCount)
    return header + "\n" + joinLines(state.lines)

fn applyUndoSnapshot(state: EditorState, snapshot: str): EditorState =
    let headerEnd: int32 = indexOfSubstr(snapshot, "\n", 0)
    if headerEnd < 0:
        return state
    let header = sliceRange(snapshot, 0, headerEnd - 1)
    let body = if headerEnd + 1 <= len(snapshot) - 1: sliceFrom(snapshot, headerEnd + 1) else: ""
    let parts: str[] = splitByChar(header, '\t')
    if seqLenString(parts) < 9:
        return state
    state.cursorLine = parseInt32(seqGetString(parts, 0), state.cursorLine)
    state.cursorCol = parseInt32(seqGetString(parts, 1), state.cursorCol)
    state.desiredCol = parseInt32(seqGetString(parts, 2), state.desiredCol)
    state.scrollLine = parseInt32(seqGetString(parts, 3), state.scrollLine)
    state.dirty = parseBool(seqGetString(parts, 4), state.dirty)
    state.selectionActive = parseBool(seqGetString(parts, 5), state.selectionActive)
    state.selectionAnchorLine = parseInt32(seqGetString(parts, 6), state.selectionAnchorLine)
    state.selectionAnchorCol = parseInt32(seqGetString(parts, 7), state.selectionAnchorCol)
    let lineCount: int32 = parseInt32(seqGetString(parts, 8), 0)
    var lines: str[] = splitLinesSimple(body)
    state.multiCursors = newCursorList()
    state.selectionHistory = default[str[]]
    state.foldedRanges = default[str[]]
    state = invalidateSemanticState(state, true)
    state.outlineReady = false
    state.outlineEntries = default[str[]]
    if lineCount > 0:
        while seqLenString(lines) < lineCount:
            addPtr_string(&lines, "")
        while seqLenString(lines) > lineCount:
            seqDeleteString(&lines, seqLenString(lines) - 1)
    state.lines = normalizeLines(lines)
    return state

fn pushUndo(state: EditorState): EditorState =
    var next = state
    addPtr_string(&next.undoStack, encodeUndoSnapshot(state))
    next.redoStack = default[str[]]
    next.selectionHistory = default[str[]]
    next.foldedRanges = default[str[]]
    if seqLenString(next.undoStack) > MaxUndoEntries:
        seqDeleteString(&next.undoStack, 0)
    return next

fn undoEditor(state: EditorState): EditorState =
    if seqLenString(state.undoStack) == 0:
        return state
    var next = state
    let lastIdx: int32 = seqLenString(next.undoStack) - 1
    let snapshot: str = seqGetString(next.undoStack, lastIdx)
    seqDeleteString(&next.undoStack, lastIdx)
    addPtr_string(&next.redoStack, encodeUndoSnapshot(state))
    next = applyUndoSnapshot(next, snapshot)
    return next

fn redoEditor(state: EditorState): EditorState =
    if seqLenString(state.redoStack) == 0:
        return state
    var next = state
    let lastIdx: int32 = seqLenString(next.redoStack) - 1
    let snapshot: str = seqGetString(next.redoStack, lastIdx)
    seqDeleteString(&next.redoStack, lastIdx)
    addPtr_string(&next.undoStack, encodeUndoSnapshot(state))
    next = applyUndoSnapshot(next, snapshot)
    return next

fn selectionRange(state: EditorState): SelectionRange =
    var outVal: SelectionRange
    outVal.active = false
    if ! state.selectionActive:
        return outVal
    if state.selectionAnchorLine == state.cursorLine && state.selectionAnchorCol == state.cursorCol:
        return outVal
    if state.selectionAnchorLine < state.cursorLine || (state.selectionAnchorLine == state.cursorLine && state.selectionAnchorCol <= state.cursorCol):
        outVal.startLine = state.selectionAnchorLine
        outVal.startCol = state.selectionAnchorCol
        outVal.endLine = state.cursorLine
        outVal.endCol = state.cursorCol
    else:
        outVal.startLine = state.cursorLine
        outVal.startCol = state.cursorCol
        outVal.endLine = state.selectionAnchorLine
        outVal.endCol = state.selectionAnchorCol
    outVal.active = true
    return outVal

fn selectionRangeEqual(a: SelectionRange, b: SelectionRange): bool =
    if a.active != b.active:
        return false
    if ! a.active:
        return true
    return a.startLine == b.startLine && a.startCol == b.startCol && a.endLine == b.endLine && a.endCol == b.endCol

fn setSelectionRange(state: EditorState, startLine, startCol, endLine, endCol: int32): EditorState =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return state
    var sLine: int32 = clampIndex(startLine, lineCount)
    var eLine: int32 = clampIndex(endLine, lineCount)
    var sCol: int32 = startCol
    var eCol: int32 = endCol
    if sLine > eLine || (sLine == eLine && sCol > eCol):
        let tmpLine = sLine
        let tmpCol = sCol
        sLine = eLine
        sCol = eCol
        eLine = tmpLine
        eCol = tmpCol
    let sText = seqGetString(state.lines, sLine)
    let eText = seqGetString(state.lines, eLine)
    sCol = clampInt(sCol, 0, len(sText))
    eCol = clampInt(eCol, 0, len(eText))
    var next: EditorState = state
    next.selectionActive = true
    next.selectionAnchorLine = sLine
    next.selectionAnchorCol = sCol
    next.cursorLine = eLine
    next.cursorCol = eCol
    next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    return next

fn selectionSnapshot(state: EditorState): str =
    let sel: SelectionRange = selectionRange(state)
    let activeFlag: str = if sel.active: "1" else: "0"
    let anchorLine: int32 = if sel.active: state.selectionAnchorLine else: state.cursorLine
    let anchorCol: int32 = if sel.active: state.selectionAnchorCol else: state.cursorCol
    return activeFlag + "\t" + intToStr(anchorLine) + "\t" + intToStr(anchorCol) + "\t" + intToStr(state.cursorLine) + "\t" + intToStr(state.cursorCol)

fn applySelectionSnapshot(state: EditorState, snapshot: str): EditorState =
    let parts: str[] = splitByChar(snapshot, '\t')
    if seqLenString(parts) < 5:
        return state
    let active: bool = parseBool(seqGetString(parts, 0), false)
    let anchorLine: int32 = parseInt32(seqGetString(parts, 1), state.selectionAnchorLine)
    let anchorCol: int32 = parseInt32(seqGetString(parts, 2), state.selectionAnchorCol)
    let cursorLine: int32 = parseInt32(seqGetString(parts, 3), state.cursorLine)
    let cursorCol: int32 = parseInt32(seqGetString(parts, 4), state.cursorCol)
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return state
    var next: EditorState = state
    next.cursorLine = clampIndex(cursorLine, lineCount)
    let cursorText = seqGetString(next.lines, next.cursorLine)
    next.cursorCol = clampInt(cursorCol, 0, len(cursorText))
    if active:
        next.selectionActive = true
        next.selectionAnchorLine = clampIndex(anchorLine, lineCount)
        let anchorText = seqGetString(next.lines, next.selectionAnchorLine)
        next.selectionAnchorCol = clampInt(anchorCol, 0, len(anchorText))
    else:
        next.selectionActive = false
        next.selectionAnchorLine = next.cursorLine
        next.selectionAnchorCol = next.cursorCol
    next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    return next

fn clearSelectionHistory(state: EditorState): EditorState =
    if seqLenString(state.selectionHistory) == 0:
        return state
    state.selectionHistory = default[str[]]
    return state

fn pushSelectionHistory(state: EditorState): EditorState =
    var next: EditorState = state
    let snapshot: str = selectionSnapshot(state)
    addPtr_string(&next.selectionHistory, snapshot)
    if seqLenString(next.selectionHistory) > MaxSelectionHistory:
        seqDeleteString(&next.selectionHistory, 0)
    return next

fn restoreSelectionHistory(state: EditorState): EditorState =
    let count: int32 = seqLenString(state.selectionHistory)
    if count <= 0:
        return state
    var next: EditorState = state
    let lastIdx: int32 = count - 1
    let snapshot: str = seqGetString(next.selectionHistory, lastIdx)
    seqDeleteString(&next.selectionHistory, lastIdx)
    next = applySelectionSnapshot(next, snapshot)
    return next

fn tokenRangeAtCursor(state: EditorState): SelectionRange =
    var outVal: SelectionRange
    outVal.active = false
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return outVal
    let lineIdx: int32 = clampIndex(state.cursorLine, lineCount)
    let lineText = seqGetString(state.lines, lineIdx)
    let lineLen: int32 = len(lineText)
    if lineLen <= 0:
        return outVal
    var col: int32 = clampInt(state.cursorCol, 0, lineLen)
    var start: int32 = col
    var finish: int32 = col
    var found = false
    if col < lineLen && syntax.isIdentChar(lineText[col]):
        start = col
        while start > 0 && syntax.isIdentChar(lineText[start - 1]):
            start = start - 1
        finish = col
        while finish < lineLen && syntax.isIdentChar(lineText[finish]):
            finish = finish + 1
        found = true
    elif col > 0 && syntax.isIdentChar(lineText[col - 1]):
        start = col - 1
        while start > 0 && syntax.isIdentChar(lineText[start - 1]):
            start = start - 1
        finish = col
        while finish < lineLen && syntax.isIdentChar(lineText[finish]):
            finish = finish + 1
        found = true
    if ! found:
        if col < lineLen && lineText[col] != ' ' && lineText[col] != '\t':
            start = col
            finish = col
            while start > 0 && lineText[start - 1] != ' ' && lineText[start - 1] != '\t':
                start = start - 1
            while finish < lineLen && lineText[finish] != ' ' && lineText[finish] != '\t':
                finish = finish + 1
            found = true
        elif col > 0 && lineText[col - 1] != ' ' && lineText[col - 1] != '\t':
            start = col - 1
            while start > 0 && lineText[start - 1] != ' ' && lineText[start - 1] != '\t':
                start = start - 1
            finish = col
            while finish < lineLen && lineText[finish] != ' ' && lineText[finish] != '\t':
                finish = finish + 1
            found = true
    if ! found:
        return outVal
    outVal.active = true
    outVal.startLine = lineIdx
    outVal.startCol = start
    outVal.endLine = lineIdx
    outVal.endCol = finish
    return outVal

fn selectionIsFullLines(state: EditorState, sel: SelectionRange): bool =
    if ! sel.active:
        return false
    if sel.startCol != 0:
        return false
    let endLen: int32 = lineLength(state, sel.endLine)
    return sel.endCol == endLen

fn selectionRangeForLines(state: EditorState, startLine: int32, endLine: int32): SelectionRange =
    var outVal: SelectionRange
    outVal.active = false
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return outVal
    let sLine: int32 = clampIndex(startLine, lineCount)
    let eLine: int32 = clampIndex(endLine, lineCount)
    let startIdx: int32 = minInt(sLine, eLine)
    let endIdx: int32 = maxInt(sLine, eLine)
    outVal.active = true
    outVal.startLine = startIdx
    outVal.startCol = 0
    outVal.endLine = endIdx
    outVal.endCol = lineLength(state, endIdx)
    return outVal

fn selectionIndentBase(state: EditorState, startLine: int32, endLine: int32): int32 =
    if startLine < 0 || endLine < 0:
        return -1
    for idx in startLine..endLine:
        if idx >= seqLenString(state.lines):
            break
        let lineText = seqGetString(state.lines, idx)
        if len(trimLine(lineText)) > 0:
            return leadingWhitespaceLen(lineText)
    return -1

fn expandLineRangeByIndent(state: EditorState, startLine: int32, endLine: int32): LineRange =
    var outVal: LineRange
    outVal.active = false
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return outVal
    let sLine: int32 = clampIndex(startLine, lineCount)
    let eLine: int32 = clampIndex(endLine, lineCount)
    let baseIndent: int32 = selectionIndentBase(state, sLine, eLine)
    if baseIndent < 0:
        return outVal
    var top: int32 = sLine
    while top > 0:
        let prevText = seqGetString(state.lines, top - 1)
        if len(trimLine(prevText)) == 0:
            top = top - 1
            continue
        if leadingWhitespaceLen(prevText) < baseIndent:
            break
        top = top - 1
    var bottom: int32 = eLine
    while bottom + 1 < lineCount:
        let nextText = seqGetString(state.lines, bottom + 1)
        if len(trimLine(nextText)) == 0:
            bottom = bottom + 1
            continue
        if leadingWhitespaceLen(nextText) < baseIndent:
            break
        bottom = bottom + 1
    outVal.active = true
    outVal.startLine = top
    outVal.endLine = bottom
    return outVal

fn expandSelection(state: EditorState): EditorState =
    var next: EditorState = clearMultiCursors(state)
    let current: SelectionRange = selectionRange(next)
    var expanded: SelectionRange
    expanded.active = false
    if ! current.active:
        expanded = tokenRangeAtCursor(next)
        if ! expanded.active:
            expanded = selectionRangeForLines(next, next.cursorLine, next.cursorLine)
    elif ! selectionIsFullLines(next, current):
        expanded = selectionRangeForLines(next, current.startLine, current.endLine)
    else:
        let blockRange: LineRange = expandLineRangeByIndent(next, current.startLine, current.endLine)
        if blockRange.active:
            expanded = selectionRangeForLines(next, blockRange.startLine, blockRange.endLine)
        if ! expanded.active || selectionRangeEqual(expanded, current):
            expanded = selectionRangeForLines(next, 0, seqLenString(next.lines) - 1)
    if expanded.active && ! selectionRangeEqual(expanded, current):
        next = pushSelectionHistory(next)
        next = setSelectionRange(next, expanded.startLine, expanded.startCol, expanded.endLine, expanded.endCol)
    return next

fn shrinkSelection(state: EditorState): EditorState =
    if seqLenString(state.selectionHistory) == 0:
        return state
    var next: EditorState = clearMultiCursors(state)
    next = restoreSelectionHistory(next)
    return next

fn absInt(value: int32): int32 =
    if value < 0:
        return 0 - value
    return value

fn foldRangeEntry(startLine: int32, endLine: int32): str =
    return intToStr(startLine) + ":" + intToStr(endLine)

fn parseFoldRangeEntry(entry: str): LineRange =
    var outVal: LineRange
    outVal.active = false
    let parts: str[] = splitByChar(entry, ':')
    if seqLenString(parts) < 2:
        return outVal
    let startLine: int32 = parseInt32(seqGetString(parts, 0), -1)
    let endLine: int32 = parseInt32(seqGetString(parts, 1), -1)
    if startLine < 0 || endLine < 0 || endLine <= startLine:
        return outVal
    outVal.active = true
    outVal.startLine = startLine
    outVal.endLine = endLine
    return outVal

fn foldRangeIndex(state: EditorState, startLine: int32): int32 =
    for idx in 0..<seqLenString(state.foldedRanges):
        let entry = seqGetString(state.foldedRanges, idx)
        let parsed: LineRange = parseFoldRangeEntry(entry)
        if parsed.active && parsed.startLine == startLine:
            return idx
    return -1

fn foldRangeForLine(state: EditorState, lineIdx: int32): LineRange =
    var outVal: LineRange
    outVal.active = false
    if state.largeFile:
        return outVal
    for idx in 0..<seqLenString(state.foldedRanges):
        let entry = seqGetString(state.foldedRanges, idx)
        let parsed: LineRange = parseFoldRangeEntry(entry)
        if parsed.active && lineIdx >= parsed.startLine && lineIdx <= parsed.endLine:
            return parsed
    return outVal

fn isLineHidden(state: EditorState, lineIdx: int32): bool =
    if state.largeFile:
        return false
    let range: LineRange = foldRangeForLine(state, lineIdx)
    return range.active && lineIdx > range.startLine && lineIdx <= range.endLine

fn normalizeVisibleLine(state: EditorState, lineIdx: int32): int32 =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return 0
    var idx: int32 = clampIndex(lineIdx, lineCount)
    if state.largeFile:
        return idx
    let range: LineRange = foldRangeForLine(state, idx)
    if range.active && idx > range.startLine && idx <= range.endLine:
        return range.startLine
    return idx

fn lastVisibleLine(state: EditorState): int32 =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return 0
    if state.largeFile:
        return lineCount - 1
    ensureVisibleLineCache(state)
    if len(visibleLineCacheLines) == 0:
        return 0
    let lastIdx: int32 = len(visibleLineCacheLines) - 1
    return visibleLineCacheLines[lastIdx]

fn scrollLineForPane(state: EditorState, pane: int32): int32 =
    if pane == 1:
        return state.splitScrollLine
    return state.scrollLine

fn setScrollLineForPane(state: EditorState, pane: int32, value: int32): EditorState =
    if pane == 1:
        state.splitScrollLine = value
    else:
        state.scrollLine = value
    return state

fn activeScrollLine(state: EditorState): int32 =
    if state.splitActive && state.splitPane == 1:
        return state.splitScrollLine
    return state.scrollLine

fn setActiveScrollLine(state: EditorState, value: int32): EditorState =
    if state.splitActive && state.splitPane == 1:
        state.splitScrollLine = value
    else:
        state.scrollLine = value
    return state

fn ensureVisibleLineCache(state: EditorState) =
    if state.largeFile:
        return
    let lineCount: int32 = seqLenString(state.lines)
    if state.bufferId == visibleLineCacheBufferId && state.bufferVersion == visibleLineCacheVersion && len(visibleLineCacheRows) == lineCount:
        return
    visibleLineCacheBufferId = state.bufferId
    visibleLineCacheVersion = state.bufferVersion
    visibleLineCacheLines = default[int32[]]
    var cacheRows: int32[lineCount]
    visibleLineCacheRows = cacheRows
    for idx in 0..<lineCount:
        visibleLineCacheRows[idx] = -1
    var row: int32 = 0
    for idx in 0..<lineCount:
        if ! isLineHidden(state, idx):
            visibleLineCacheLines.add(idx)
            visibleLineCacheRows[idx] = row
            row = row + 1

fn visibleRowCached(lineIdx: int32): int32 =
    if lineIdx < 0 || lineIdx >= len(visibleLineCacheRows):
        return -1
    return visibleLineCacheRows[lineIdx]

fn visibleLineCount(state: EditorState): int32 =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return 0
    if state.largeFile:
        return lineCount
    ensureVisibleLineCache(state)
    return len(visibleLineCacheLines)

fn moveVisibleLine(state: EditorState, lineIdx: int32, delta: int32): int32 =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return 0
    if state.largeFile:
        return clampIndex(lineIdx + delta, lineCount)
    ensureVisibleLineCache(state)
    let current: int32 = normalizeVisibleLine(state, lineIdx)
    let currentRow: int32 = visibleRowCached(current)
    if currentRow < 0 || delta == 0:
        return current
    var targetRow: int32 = currentRow + delta
    if targetRow < 0:
        targetRow = 0
    if targetRow >= len(visibleLineCacheLines):
        targetRow = len(visibleLineCacheLines) - 1
    if targetRow < 0:
        return current
    return visibleLineCacheLines[targetRow]

fn visibleLineAtOffset(state: EditorState, startLine: int32, offset: int32): int32 =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return 0
    var lineIdx: int32 = normalizeVisibleLine(state, startLine)
    if offset <= 0:
        return lineIdx
    if state.largeFile:
        return clampIndex(lineIdx + offset, lineCount)
    ensureVisibleLineCache(state)
    let baseRow: int32 = visibleRowCached(lineIdx)
    if baseRow < 0:
        return lineIdx
    var targetRow: int32 = baseRow + offset
    if targetRow < 0:
        targetRow = 0
    if targetRow >= len(visibleLineCacheLines):
        return lastVisibleLine(state)
    return visibleLineCacheLines[targetRow]

fn maxScrollLine(state: EditorState, visibleLines: int32): int32 =
    let totalVisible: int32 = visibleLineCount(state)
    if totalVisible <= visibleLines:
        return 0
    let offset: int32 = totalVisible - visibleLines
    return visibleLineAtOffset(state, 0, offset)

fn visibleRowForLine(state: EditorState, startLine: int32, targetLine: int32, maxRows: int32): int32 =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return -1
    if state.largeFile:
        let base: int32 = clampIndex(startLine, lineCount)
        let target: int32 = clampIndex(targetLine, lineCount)
        let row: int32 = target - base
        if row < 0 || row > maxRows:
            return -1
        return row
    ensureVisibleLineCache(state)
    let baseLine: int32 = normalizeVisibleLine(state, startLine)
    let baseRow: int32 = visibleRowCached(baseLine)
    let targetRow: int32 = visibleRowCached(targetLine)
    if baseRow < 0 || targetRow < 0:
        return -1
    let row: int32 = targetRow - baseRow
    if row < 0 || row > maxRows:
        return -1
    return row

fn foldableRangeAtLine(lines: str[], lineIdx: int32): LineRange =
    var outVal: LineRange
    outVal.active = false
    let lineCount: int32 = seqLenString(lines)
    if lineIdx < 0 || lineIdx >= lineCount - 1:
        return outVal
    let lineText = seqGetString(lines, lineIdx)
    if isBlankLine(lineText):
        return outVal
    let baseIndent: int32 = leadingWhitespaceLen(lineText)
    var nextIdx: int32 = lineIdx + 1
    for idx in lineIdx + 1..<lineCount:
        if ! isBlankLine(seqGetString(lines, idx)):
            nextIdx = idx
            break
        nextIdx = idx + 1
    if nextIdx >= lineCount:
        return outVal
    let nextIndent: int32 = leadingWhitespaceLen(seqGetString(lines, nextIdx))
    if nextIndent <= baseIndent:
        return outVal
    var endIdx: int32 = nextIdx
    for idx in nextIdx + 1..<lineCount:
        let text = seqGetString(lines, idx)
        if isBlankLine(text):
            endIdx = idx
            continue
        let indent: int32 = leadingWhitespaceLen(text)
        if indent <= baseIndent:
            break
        endIdx = idx
    outVal.active = true
    outVal.startLine = lineIdx
    outVal.endLine = endIdx
    return outVal

fn toggleFoldAtLine(state: EditorState, lineIdx: int32): EditorState =
    var next: EditorState = state
    let existingIdx: int32 = foldRangeIndex(next, lineIdx)
    if existingIdx >= 0:
        seqDeleteString(&next.foldedRanges, existingIdx)
        next.bufferVersion = next.bufferVersion + 1
        return next
    let range: LineRange = foldableRangeAtLine(state.lines, lineIdx)
    if ! range.active:
        return state
    addPtr_string(&next.foldedRanges, foldRangeEntry(range.startLine, range.endLine))
    next.bufferVersion = next.bufferVersion + 1
    if next.cursorLine > range.startLine && next.cursorLine <= range.endLine:
        next.cursorLine = range.startLine
        let lineText = seqGetString(next.lines, next.cursorLine)
        next.cursorCol = clampInt(next.cursorCol, 0, len(lineText))
        next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    next.selectionActive = false
    next.multiCursors = newCursorList()
    return next

fn toggleEditorSplit(state: EditorState): EditorState =
    var next: EditorState = state
    if ! next.splitActive:
        next.splitActive = true
        next.splitPane = 0
        next.splitScrollLine = next.scrollLine
        return next
    if next.splitPane == 1:
        next.scrollLine = next.splitScrollLine
    next.splitActive = false
    next.splitPane = 0
    return next

fn selectionLineRange(state: EditorState): LineRange =
    var outVal: LineRange
    outVal.active = false
    let sel: SelectionRange = selectionRange(state)
    if ! sel.active:
        return outVal
    var startLine: int32 = sel.startLine
    var endLine: int32 = sel.endLine
    if endLine > startLine && sel.endCol == 0:
        endLine = endLine - 1
    if endLine < startLine:
        return outVal
    outVal.active = true
    outVal.startLine = startLine
    outVal.endLine = endLine
    return outVal

fn setLineSelection(state: EditorState, anchorLine: int32, currentLine: int32): EditorState =
    var next: EditorState = state
    let lineCount: int32 = seqLenString(next.lines)
    let anchorIdx: int32 = clampIndex(anchorLine, lineCount)
    let currentIdx: int32 = clampIndex(currentLine, lineCount)
    let anchorLen: int32 = lineLength(next, anchorIdx)
    let currentLen: int32 = lineLength(next, currentIdx)
    next.selectionActive = true
    if currentIdx >= anchorIdx:
        next.selectionAnchorLine = anchorIdx
        next.selectionAnchorCol = 0
        next.cursorLine = currentIdx
        next.cursorCol = currentLen
    else:
        next.selectionAnchorLine = anchorIdx
        next.selectionAnchorCol = anchorLen
        next.cursorLine = currentIdx
        next.cursorCol = 0
    next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    return next

fn lineOutdentCount(lineText: str): int32 =
    if len(lineText) == 0:
        return 0
    let first: char = lineText[0]
    if first == '\t':
        return 1
    var count: int32 = 0
    for idx in 0..<len(lineText):
        if idx >= TabSize || lineText[idx] != ' ':
            break
        count = idx + 1
    return count

fn indentSelectionLines(state: EditorState, selRange: LineRange): EditorState =
    if ! selRange.active:
        return state
    var next: EditorState = pushUndo(state)
    let indentText: str = makeSpaces(TabSize)
    for lineIdx in selRange.startLine..selRange.endLine:
        if lineIdx >= seqLenString(next.lines):
            break
        let lineText = seqGetString(next.lines, lineIdx)
        seqSetString(&next.lines, lineIdx, indentText + lineText)
    if next.selectionAnchorLine >= selRange.startLine && next.selectionAnchorLine <= selRange.endLine:
        next.selectionAnchorCol = next.selectionAnchorCol + TabSize
    if next.cursorLine >= selRange.startLine && next.cursorLine <= selRange.endLine:
        next.cursorCol = next.cursorCol + TabSize
        next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    next.selectionActive = true
    next.multiCursors = newCursorList()
    next.dirty = true
    return next

fn outdentSelectionLines(state: EditorState, selRange: LineRange): EditorState =
    if ! selRange.active:
        return state
    var next: EditorState = pushUndo(state)
    var anchorCol: int32 = next.selectionAnchorCol
    var cursorCol: int32 = next.cursorCol
    for lineIdx in selRange.startLine..selRange.endLine:
        if lineIdx >= seqLenString(next.lines):
            break
        let lineText = seqGetString(next.lines, lineIdx)
        let removeCount: int32 = lineOutdentCount(lineText)
        if removeCount > 0:
            seqSetString(&next.lines, lineIdx, sliceFrom(lineText, removeCount))
        if lineIdx == next.selectionAnchorLine:
            anchorCol = maxInt(0, anchorCol - minInt(anchorCol, removeCount))
        if lineIdx == next.cursorLine:
            cursorCol = maxInt(0, cursorCol - minInt(cursorCol, removeCount))
    next.selectionAnchorCol = anchorCol
    next.cursorCol = cursorCol
    next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    next.selectionActive = true
    next.multiCursors = newCursorList()
    next.dirty = true
    return next

fn selectionOrCursorLineRange(state: EditorState): LineRange =
    let selRange: LineRange = selectionLineRange(state)
    if selRange.active:
        return selRange
    var outVal: LineRange
    outVal.active = false
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return outVal
    let lineIdx: int32 = clampIndex(state.cursorLine, lineCount)
    outVal.active = true
    outVal.startLine = lineIdx
    outVal.endLine = lineIdx
    return outVal

fn selectCurrentLine(state: EditorState): EditorState =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return state
    let lineIdx: int32 = clampIndex(state.cursorLine, lineCount)
    var next: EditorState = clearMultiCursors(state)
    next = setLineSelection(next, lineIdx, lineIdx)
    return next

fn selectAll(state: EditorState): EditorState =
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return state
    let lastLine: int32 = lineCount - 1
    let lastCol: int32 = lineLength(state, lastLine)
    var next: EditorState = clearMultiCursors(state)
    next = setSelectionRange(next, 0, 0, lastLine, lastCol)
    return next

fn duplicateSelectionOrLine(state: EditorState): EditorState =
    let sel: SelectionRange = selectionRange(state)
    if sel.active:
        let text: str = selectionText(state)
        if len(text) == 0:
            return state
        var next: EditorState = pushUndo(state)
        let insertLine: int32 = sel.endLine
        let insertCol: int32 = sel.endCol
        next = clearMultiCursors(next)
        next.selectionActive = false
        next.cursorLine = insertLine
        next.cursorCol = insertCol
        next.desiredCol = desiredColForLine(next, insertLine, insertCol)
        next = insertText(next, text)
        next.selectionActive = true
        next.selectionAnchorLine = insertLine
        next.selectionAnchorCol = insertCol
        return next
    let range: LineRange = selectionOrCursorLineRange(state)
    if ! range.active:
        return state
    let lineIdx: int32 = range.startLine
    if lineIdx < 0 || lineIdx >= seqLenString(state.lines):
        return state
    let lineText = seqGetString(state.lines, lineIdx)
    var next: EditorState = pushUndo(state)
    seqInsertString(&next.lines, lineIdx + 1, lineText)
    next.cursorLine = lineIdx + 1
    next.cursorCol = clampInt(state.cursorCol, 0, len(lineText))
    next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    next.selectionActive = false
    next.multiCursors = newCursorList()
    next.dirty = true
    return next

fn moveSelectionLines(state: EditorState, delta: int32): EditorState =
    if delta == 0:
        return state
    let range: LineRange = selectionOrCursorLineRange(state)
    if ! range.active:
        return state
    let lineCount: int32 = seqLenString(state.lines)
    if lineCount <= 0:
        return state
    if delta < 0 && range.startLine <= 0:
        return state
    if delta > 0 && range.endLine >= lineCount - 1:
        return state
    var next: EditorState = pushUndo(state)
    if delta < 0:
        let prevLine = seqGetString(next.lines, range.startLine - 1)
        seqDeleteString(&next.lines, range.startLine - 1)
        seqInsertString(&next.lines, range.endLine, prevLine)
    else:
        let nextLine = seqGetString(next.lines, range.endLine + 1)
        seqDeleteString(&next.lines, range.endLine + 1)
        seqInsertString(&next.lines, range.startLine, nextLine)
    let shift: int32 = if delta < 0: -1 else: 1
    let hasSelection: bool = selectionRange(state).active
    next.cursorLine = clampIndex(state.cursorLine + shift, seqLenString(next.lines))
    if hasSelection:
        next.selectionActive = true
        next.selectionAnchorLine = clampIndex(state.selectionAnchorLine + shift, seqLenString(next.lines))
    else:
        next.selectionActive = false
    let cursorLineText = seqGetString(next.lines, next.cursorLine)
    next.cursorCol = clampInt(next.cursorCol, 0, len(cursorLineText))
    next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    if next.selectionActive:
        let anchorLineText = seqGetString(next.lines, next.selectionAnchorLine)
        next.selectionAnchorCol = clampInt(next.selectionAnchorCol, 0, len(anchorLineText))
    next.multiCursors = newCursorList()
    next.dirty = true
    return next

fn deleteSelectionLines(state: EditorState): EditorState =
    let range: LineRange = selectionOrCursorLineRange(state)
    if ! range.active:
        return state
    var next: EditorState = pushUndo(state)
    let removeCount: int32 = range.endLine - range.startLine + 1
    for idx in 0..<removeCount:
        if ! (range.startLine < seqLenString(next.lines)):
            break
        seqDeleteString(&next.lines, range.startLine)
    if seqLenString(next.lines) == 0:
        addPtr_string(&next.lines, "")
    next.cursorLine = clampIndex(range.startLine, seqLenString(next.lines))
    next.cursorCol = 0
    next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    next.selectionActive = false
    next.multiCursors = newCursorList()
    next.dirty = true
    return next

fn makeCursorPos(line, col: int32): CursorPos =
    var outVal: CursorPos
    outVal.line = line
    outVal.col = col
    return outVal

fn cursorEqual(a: CursorPos, b: CursorPos): bool =
    return a.line == b.line && a.col == b.col

fn cursorLess(a: CursorPos, b: CursorPos): bool =
    if a.line < b.line:
        return true
    if a.line > b.line:
        return false
    return a.col < b.col

fn cursorIndex(list: CursorList, target: CursorPos): int32 =
    for idx in 0..<seqLenCursor(list):
        if cursorEqual(seqGetCursor(list, idx), target):
            return idx
    return -1

fn cursorListContains(list: CursorList, target: CursorPos): bool =
    return cursorIndex(list, target) >= 0

fn sortCursorList(list: CursorList): CursorList =
    var outVal: CursorList = list
    let count: int32 = seqLenCursor(outVal)
    for i in 0..<count:
        for j in i + 1..<count:
            let a: CursorPos = seqGetCursor(outVal, i)
            let b: CursorPos = seqGetCursor(outVal, j)
            if cursorLess(b, a):
                seqSetCursor(&outVal, i, b)
                seqSetCursor(&outVal, j, a)
    return outVal

fn clearMultiCursors(state: EditorState): EditorState =
    if seqLenCursor(state.multiCursors) == 0:
        return state
    state.multiCursors = newCursorList()
    return state

fn hasMultiCursors(state: EditorState): bool =
    return seqLenCursor(state.multiCursors) > 0

fn addMultiCursorUnique(list: CursorList, pos: CursorPos): CursorList =
    if cursorListContains(list, pos):
        return list
    addPtr_cursor(&list, pos)
    return list

fn removeMultiCursor(list: CursorList, pos: CursorPos): CursorList =
    var idx: int32 = cursorIndex(list, pos)
    if idx < 0:
        return list
    seqDeleteCursor(&list, idx)
    return list

fn collectCursorList(state: EditorState): CursorCollection =
    var outVal: CursorCollection
    outVal.positions = newCursorList()
    let primary: CursorPos = makeCursorPos(state.cursorLine, state.cursorCol)
    addPtr_cursor(&outVal.positions, primary)
    for idx in 0..<seqLenCursor(state.multiCursors):
        let pos: CursorPos = seqGetCursor(state.multiCursors, idx)
        if ! cursorEqual(pos, primary) && ! cursorListContains(outVal.positions, pos):
            addPtr_cursor(&outVal.positions, pos)
    outVal.positions = sortCursorList(outVal.positions)
    outVal.primaryIdx = cursorIndex(outVal.positions, primary)
    if outVal.primaryIdx < 0:
        outVal.primaryIdx = 0
    return outVal

fn assignCursors(state: EditorState, positions: CursorList, primaryIdx: int32): EditorState =
    let count: int32 = seqLenCursor(positions)
    if count <= 0:
        return clearMultiCursors(state)
    var pIdx: int32 = primaryIdx
    if pIdx < 0 || pIdx >= count:
        pIdx = 0
    let primary: CursorPos = seqGetCursor(positions, pIdx)
    state.cursorLine = primary.line
    state.cursorCol = primary.col
    state.desiredCol = desiredColForLine(state, primary.line, primary.col)
    var extras: CursorList = newCursorList()
    for idx in 0..<count:
        if idx != pIdx:
            let pos: CursorPos = seqGetCursor(positions, idx)
            if ! cursorEqual(pos, primary) && ! cursorListContains(extras, pos):
                addPtr_cursor(&extras, pos)
    state.multiCursors = extras
    return state

fn addMultiCursorVertical(state: EditorState, delta: int32): EditorState =
    if delta == 0:
        return state
    let cursors: CursorCollection = collectCursorList(state)
    var positions: CursorList = cursors.positions
    let count: int32 = seqLenCursor(positions)
    let primary: CursorPos = makeCursorPos(state.cursorLine, state.cursorCol)
    for idx in 0..<count:
        let pos: CursorPos = seqGetCursor(positions, idx)
        let nextPos: CursorPos = if delta < 0: moveCursorPosUp(state, pos) else: moveCursorPosDown(state, pos)
        if ! cursorEqual(nextPos, pos) && ! cursorListContains(positions, nextPos):
            addPtr_cursor(&positions, nextPos)
    positions = sortCursorList(positions)
    let primaryIdx: int32 = cursorIndex(positions, primary)
    var next: EditorState = assignCursors(state, positions, primaryIdx)
    next.selectionActive = false
    return next

fn clearSelection(state: EditorState): EditorState =
    state.selectionActive = false
    return state

fn startSelection(state: EditorState): EditorState =
    if ! state.selectionActive:
        state.selectionActive = true
        state.selectionAnchorLine = state.cursorLine
        state.selectionAnchorCol = state.cursorCol
    return state

fn selectionText(state: EditorState): str =
    let sel: SelectionRange = selectionRange(state)
    if ! sel.active:
        return ""
    if sel.startLine < 0 || sel.endLine >= seqLenString(state.lines):
        return ""
    if sel.startLine == sel.endLine:
        let lineText = seqGetString(state.lines, sel.startLine)
        if sel.endCol <= sel.startCol:
            return ""
        return sliceRange(lineText, sel.startCol, sel.endCol - 1)
    var outVal = ""
    let firstLine = seqGetString(state.lines, sel.startLine)
    outVal = outVal + sliceFrom(firstLine, sel.startCol)
    outVal = outVal + "\n"
    for lineIdx in sel.startLine + 1..<sel.endLine:
        outVal = outVal + seqGetString(state.lines, lineIdx) + "\n"
    let lastLine = seqGetString(state.lines, sel.endLine)
    if sel.endCol > 0:
        outVal = outVal + sliceTo(lastLine, sel.endCol)
    return outVal

fn deleteSelection(state: EditorState): EditorState =
    let sel: SelectionRange = selectionRange(state)
    if ! sel.active:
        return state
    var next = state
    if sel.startLine == sel.endLine:
        let lineText = seqGetString(next.lines, sel.startLine)
        let left = sliceTo(lineText, sel.startCol)
        let right = if sel.endCol < len(lineText): sliceFrom(lineText, sel.endCol) else: ""
        seqSetString(&next.lines, sel.startLine, left + right)
    else:
        let firstLine = seqGetString(next.lines, sel.startLine)
        let lastLine = seqGetString(next.lines, sel.endLine)
        let left = sliceTo(firstLine, sel.startCol)
        let right = if sel.endCol < len(lastLine): sliceFrom(lastLine, sel.endCol) else: ""
        seqSetString(&next.lines, sel.startLine, left + right)
        let removeCount: int32 = sel.endLine - sel.startLine
        for i in 0..<removeCount:
            if ! (sel.startLine + 1 < seqLenString(next.lines)):
                break
            seqDeleteString(&next.lines, sel.startLine + 1)
    next.cursorLine = sel.startLine
    next.cursorCol = sel.startCol
    next.desiredCol = desiredColForLine(next, next.cursorLine, next.cursorCol)
    next.selectionActive = false
    next.dirty = true
    return next

fn ensureCursorVisible(state: EditorState, layout: GuiLayout): EditorState =
    let lineCount: int32 = seqLenString(state.lines)
    let visibleLines: int32 = maxInt(1, int32(float64(layout.editorH) / layout.lineHeight))
    if lineCount <= 0:
        state.scrollLine = 0
        state.splitScrollLine = 0
        return state
    if isLineHidden(state, state.cursorLine):
        state.cursorLine = normalizeVisibleLine(state, state.cursorLine)
        let lineText = seqGetString(state.lines, state.cursorLine)
        state.cursorCol = clampInt(state.cursorCol, 0, len(lineText))
        state.desiredCol = desiredColForLine(state, state.cursorLine, state.cursorCol)
    var scrollLine: int32 = activeScrollLine(state)
    let startLine: int32 = normalizeVisibleLine(state, scrollLine)
    if state.cursorLine < startLine:
        scrollLine = state.cursorLine
    else:
        let row: int32 = visibleRowForLine(state, startLine, state.cursorLine, lineCount)
        if row < 0:
            scrollLine = state.cursorLine
        elif row >= visibleLines:
            let offset: int32 = row - visibleLines + 1
            scrollLine = visibleLineAtOffset(state, startLine, offset)
    let maxScroll: int32 = maxScrollLine(state, visibleLines)
    scrollLine = clampInt(normalizeVisibleLine(state, scrollLine), 0, maxScroll)
    state = setActiveScrollLine(state, scrollLine)
    return state

fn joinLines(lines: str[]): str =
    var outVal: str = ""
    let count: int32 = seqLenString(lines)
    for idx in 0..<count:
        outVal = outVal + seqGetString(lines, idx)
        if idx < count - 1:
            outVal = outVal + "\n"
    return outVal

fn pushTerminalLine(state: TerminalState, line: str): TerminalState =
    addPtr_string(&state.lines, line)
    while seqLenString(state.lines) > MaxTerminalLines:
        seqDeleteString(&state.lines, 0)
    return state

fn initTerminalState(label: str): TerminalState =
    var term: TerminalState
    term.label = label
    term.input = ""
    term.lines = default[str[]]
    term.mode = tmCommand
    term.ptyActive = false
    term.ptyFd = -1
    term.ptyPid = 0
    term.ptyRemainder = ""
    term.ptyAnsiRemainder = ""
    addPtr_string(&term.lines, "Cheng IDE ready")
    return term

fn guiTerminalEnsureSessions(state: GuiState): GuiState =
    if terminalSessionLen(state.terminalSessions) <= 0:
        if len(state.terminal.label) == 0:
            if state.terminalSessionCounter <= 0:
                state.terminalSessionCounter = 1
            state.terminal.label = "term-" + intToStr(state.terminalSessionCounter)
        terminalSessionInsert(&state.terminalSessions, 0, state.terminal)
        state.terminalSessionActive = 0
    else:
        let count: int32 = terminalSessionLen(state.terminalSessions)
        if count > 0:
            state.terminalSessionActive = clampInt(state.terminalSessionActive, 0, count - 1)
        if state.terminalSessionCounter < count:
            state.terminalSessionCounter = count
    return state

fn guiTerminalSyncActiveSession(state: GuiState): GuiState =
    if terminalSessionLen(state.terminalSessions) <= 0:
        return guiTerminalEnsureSessions(state)
    let idx: int32 = clampInt(state.terminalSessionActive, 0, terminalSessionLen(state.terminalSessions) - 1)
    state.terminalSessionActive = idx
    terminalSessionSet(&state.terminalSessions, idx, state.terminal)
    return state

fn guiTerminalListSessions(state: GuiState): GuiState =
    state = guiTerminalEnsureSessions(state)
    state = guiTerminalSyncActiveSession(state)
    let count: int32 = terminalSessionLen(state.terminalSessions)
    state.terminal = pushTerminalLine(state.terminal, "terminals: " + intToStr(count))
    for idx in 0..<count:
        let session: TerminalState = terminalSessionGet(state.terminalSessions, idx)
        let mark = if idx == state.terminalSessionActive: "*" else: " "
        let label = if len(session.label) > 0: session.label else: "term-" + intToStr(idx + 1)
        state.terminal = pushTerminalLine(state.terminal, mark + " " + intToStr(idx + 1) + ": " + label)
    return state

fn guiTerminalSwitchSession(state: GuiState, idx: int32): GuiState =
    state = guiTerminalEnsureSessions(state)
    let count: int32 = terminalSessionLen(state.terminalSessions)
    if count <= 0:
        state.statusMsg = "terminal: none"
        return state
    if idx < 0 || idx >= count:
        state.statusMsg = "terminal: invalid"
        return state
    state = guiTerminalSyncActiveSession(state)
    let session: TerminalState = terminalSessionGet(state.terminalSessions, idx)
    state.terminal = session
    state.terminalSessionActive = idx
    let label = if len(session.label) > 0: session.label else: "term-" + intToStr(idx + 1)
    state.statusMsg = "terminal: " + label
    return state

fn guiTerminalNextSession(state: GuiState): GuiState =
    state = guiTerminalEnsureSessions(state)
    let count: int32 = terminalSessionLen(state.terminalSessions)
    if count <= 1:
        state.statusMsg = "terminal: single"
        return state
    let nextIdx: int32 = (state.terminalSessionActive + 1) % count
    return guiTerminalSwitchSession(state, nextIdx)

fn guiTerminalPrevSession(state: GuiState): GuiState =
    state = guiTerminalEnsureSessions(state)
    let count: int32 = terminalSessionLen(state.terminalSessions)
    if count <= 1:
        state.statusMsg = "terminal: single"
        return state
    var prevIdx: int32 = state.terminalSessionActive - 1
    if prevIdx < 0:
        prevIdx = count - 1
    return guiTerminalSwitchSession(state, prevIdx)

fn guiTerminalNewSession(state: GuiState): GuiState =
    state = guiTerminalEnsureSessions(state)
    state = guiTerminalSyncActiveSession(state)
    state.terminalSessionCounter = state.terminalSessionCounter + 1
    let label = "term-" + intToStr(state.terminalSessionCounter)
    let session: TerminalState = initTerminalState(label)
    let idx: int32 = terminalSessionLen(state.terminalSessions)
    terminalSessionInsert(&state.terminalSessions, idx, session)
    state.terminal = session
    state.terminalSessionActive = idx
    state.statusMsg = "terminal: new " + label
    return state

fn guiTerminalCloseSession(state: GuiState): GuiState =
    state = guiTerminalEnsureSessions(state)
    let count: int32 = terminalSessionLen(state.terminalSessions)
    if count <= 1:
        state.statusMsg = "terminal: last"
        return state
    state = guiTerminalSyncActiveSession(state)
    let idx: int32 = state.terminalSessionActive
    let current: TerminalState = terminalSessionGet(state.terminalSessions, idx)
    if current.ptyActive:
        ptyClose(current.ptyFd)
        var exitCode: int32 = -1
        ptyWait(current.ptyPid, &exitCode)
    terminalSessionDelete(&state.terminalSessions, idx)
    let newCount: int32 = count - 1
    var nextIdx: int32 = idx
    if nextIdx >= newCount:
        nextIdx = newCount - 1
    let nextSession: TerminalState = terminalSessionGet(state.terminalSessions, nextIdx)
    state.terminal = nextSession
    state.terminalSessionActive = nextIdx
    let label = if len(nextSession.label) > 0: nextSession.label else: "term-" + intToStr(nextIdx + 1)
    state.statusMsg = "terminal: " + label
    return state

fn guiTerminalShutdownAll(state: GuiState): GuiState =
    if terminalSessionLen(state.terminalSessions) <= 0:
        if state.terminal.ptyActive:
            ptyClose(state.terminal.ptyFd)
            var exitCode: int32 = -1
            ptyWait(state.terminal.ptyPid, &exitCode)
        return state
    state = guiTerminalSyncActiveSession(state)
    let count: int32 = terminalSessionLen(state.terminalSessions)
    for idx in 0..<count:
        let session: TerminalState = terminalSessionGet(state.terminalSessions, idx)
        if session.ptyActive:
            ptyClose(session.ptyFd)
            var exitCode: int32 = -1
            ptyWait(session.ptyPid, &exitCode)
    return state

fn guiTaskLogAdd(state: GuiState, line: str): GuiState =
    if len(line) == 0:
        return state
    addPtr_string(&state.taskLog, line)
    while seqLenString(state.taskLog) > MaxTaskLogLines:
        seqDeleteString(&state.taskLog, 0)
    state.renderDirty = true
    return state

fn guiTaskQueueLen(runner: var TaskRunner): int32 =
    let total: int32 = len(runner.queue)
    if total <= runner.queueHead:
        return 0
    return total - runner.queueHead

fn guiTaskQueueCompact(runner: var TaskRunner) =
    let total: int32 = len(runner.queue)
    if runner.queueHead <= 0:
        return
    if runner.queueHead < total / 2:
        return
    var nextQueue: TaskJob[] = default[TaskJob[]]
    for idx in runner.queueHead..<total:
        addPtr[TaskJob](&nextQueue, runner.queue[idx])
    runner.queue = nextQueue
    runner.queueHead = 0

fn guiTaskQueuePop(runner: var TaskRunner): TaskJob =
    var job: TaskJob
    if guiTaskQueueLen(runner) <= 0:
        return job
    job = runner.queue[runner.queueHead]
    runner.queueHead = runner.queueHead + 1
    guiTaskQueueCompact(runner)
    return job

fn guiTaskQueueRemoveDiagnostics(runner: var TaskRunner) =
    let total: int32 = len(runner.queue)
    if total <= runner.queueHead:
        return
    var nextQueue: TaskJob[] = default[TaskJob[]]
    for idx in runner.queueHead..<total:
        let job = runner.queue[idx]
        if job.kind != tkDiagnostics:
            addPtr[TaskJob](&nextQueue, job)
    runner.queue = nextQueue
    runner.queueHead = 0

fn guiTaskRunnerHandleLine(state: GuiState, line: str): GuiState =
    if len(line) == 0:
        return state
    var next: GuiState = state
    if next.taskRunner.job.kind == tkCodexExec || next.taskRunner.job.kind == tkCodexApply:
        next = guiTaskLogAdd(next, line)
        return next
    next.terminal = pushTerminalLine(next.terminal, line)
    next = guiTaskLogAdd(next, line)
    return next

fn guiTaskRunnerStart(state: GuiState, job: TaskJob): GuiState =
    var next: GuiState = state
    if len(job.command) == 0:
        return next
    if ! ptySupported():
        let msg = "task: pty unsupported"
        next.statusMsg = msg
        next.terminal = pushTerminalLine(next.terminal, msg)
        next = guiTaskLogAdd(next, msg)
        if job.kind == tkDiagnostics:
            next.diagPending = false
        elif job.kind == tkCodexExec || job.kind == tkCodexApply:
            next.codex.status = "error"
            next = guiCodexAppendLine(next, "error: pty unsupported")
        return next
    var fd: int32 = -1
    var pid: int64 = 0
    let workDir = if len(job.workDir) > 0: job.workDir else: guiWorkspaceActiveRoot(next)
    let ok: bool = ptySpawn(job.command, workDir, &fd, &pid)
    if ! ok:
        let msg = "task: start failed"
        next.statusMsg = msg
        next.terminal = pushTerminalLine(next.terminal, msg)
        next = guiTaskLogAdd(next, msg)
        if job.kind == tkDiagnostics:
            next.diagPending = false
        elif job.kind == tkCodexExec || job.kind == tkCodexApply:
            next.codex.status = "error"
            next = guiCodexAppendLine(next, "error: start failed")
        return next
    next.taskRunner.active = true
    next.taskRunner.job = job
    next.taskRunner.ptyFd = fd
    next.taskRunner.ptyPid = pid
    next.taskRunner.ptyRemainder = ""
    next.taskRunner.ptyAnsiRemainder = ""
    next.taskRunner.rawOutput = ""
    if job.kind == tkDiagnostics:
        next.statusMsg = "diag: running"
        next.terminal = pushTerminalLine(next.terminal, "[diag] " + job.command)
        next = guiTaskLogAdd(next, "[diag] " + job.command)
    elif job.kind == tkCodexExec:
        next.codex.status = "running"
        next.statusMsg = "codex: exec"
    elif job.kind == tkCodexApply:
        next.codex.status = "applying"
        next.statusMsg = "codex: apply"
    else:
        next.statusMsg = "task: running"
        next.terminal = pushTerminalLine(next.terminal, "[task] " + job.command)
        next = guiTaskLogAdd(next, "[task] " + job.command)
    next.renderDirty = true
    next = guiDesktopBridgeSave(next)
    return next

fn guiTaskRunnerEnqueue(state: GuiState, job: TaskJob): GuiState =
    var next: GuiState = state
    if job.kind == tkDiagnostics:
        guiTaskQueueRemoveDiagnostics(next.taskRunner)
    addPtr[TaskJob](&next.taskRunner.queue, job)
    if next.taskRunner.active:
        if job.kind == tkDiagnostics:
            next.statusMsg = "diag: queued"
        elif job.kind == tkCodexExec:
            next.codex.status = "queued"
            next.statusMsg = "codex: exec queued"
        elif job.kind == tkCodexApply:
            next.codex.status = "queued"
            next.statusMsg = "codex: apply queued"
        else:
            next.statusMsg = "task: queued"
        return next
    if guiTaskQueueLen(next.taskRunner) > 0:
        let startJob = guiTaskQueuePop(next.taskRunner)
        return guiTaskRunnerStart(next, startJob)
    return next

fn guiTaskRunnerConsumeOutput(state: GuiState, output: str): GuiState =
    if len(output) == 0:
        return state
    var next: GuiState = state
    next.taskRunner.rawOutput = next.taskRunner.rawOutput + output
    var text = next.taskRunner.ptyAnsiRemainder + output
    next.taskRunner.ptyAnsiRemainder = ""
    var lineBuf: str = next.taskRunner.ptyRemainder
    var idx: int32 = 0
    var segStart: int32 = 0
    let total: int32 = len(text)
    while idx < total:
        let ch: char = text[idx]
        if ch == '\x1b':
            if segStart < idx:
                lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
            let nextIdx: int32 = skipAnsiSequence(text, idx)
            if nextIdx < 0:
                next.taskRunner.ptyAnsiRemainder = sliceFrom(text, idx)
                segStart = idx
                break
            idx = nextIdx
            segStart = idx
            continue
        if ch == '\r':
            if segStart < idx:
                lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
            if idx + 1 < total && text[idx + 1] == '\n':
                next = guiTaskRunnerHandleLine(next, lineBuf)
                lineBuf = ""
                idx = idx + 2
                segStart = idx
                continue
            lineBuf = ""
            idx = idx + 1
            segStart = idx
            continue
        if ch == '\n':
            if segStart < idx:
                lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
            next = guiTaskRunnerHandleLine(next, lineBuf)
            lineBuf = ""
            idx = idx + 1
            segStart = idx
            continue
        if ch == chr(8):
            if segStart < idx:
                lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
            let bufLen: int32 = len(lineBuf)
            if bufLen > 0:
                lineBuf = slicePrefix(lineBuf, bufLen - 1)
            idx = idx + 1
            segStart = idx
            continue
        idx = idx + 1
    if idx > segStart:
        lineBuf = lineBuf + sliceRange(text, segStart, idx - 1)
    next.taskRunner.ptyRemainder = lineBuf
    return next

fn guiTaskRunnerFinish(state: GuiState, exitCode: int32): GuiState =
    var next: GuiState = state
    let job = next.taskRunner.job
    let exitText = "exit=" + intToStr(exitCode)
    if job.kind == tkDiagnostics:
        next.langDiagnostics = guiParseDiagOutput(next.taskRunner.rawOutput, job.filePath)
        next.diagnosticsDirty = true
        next.statusMsg = "diag: " + intToStr(next.langDiagnostics.len)
        next.terminal = pushTerminalLine(next.terminal, "diag " + exitText)
        next = guiTaskLogAdd(next, "diag " + exitText)
    elif job.kind == tkCodexExec:
        let parsed = guiCodexExtractOutput(next.taskRunner.rawOutput)
        if len(parsed) > 0:
            let lines = splitLinesSimple(parsed)
            for idx in 0..<seqLenString(lines):
                let lineText = trimLine(seqGetString(lines, idx))
                if len(lineText) > 0:
                    next = guiCodexAppendLine(next, lineText)
        else:
            let lines = splitLinesSimple(next.taskRunner.rawOutput)
            for idx in 0..<seqLenString(lines):
                let lineText = trimLine(seqGetString(lines, idx))
                if len(lineText) > 0:
                    next = guiCodexAppendLine(next, lineText)
        next.codex.status = if exitCode == 0: "done" else: "error"
        next.statusMsg = "codex: exec"
    elif job.kind == tkCodexApply:
        if len(next.taskRunner.rawOutput) > 0:
            let lines = splitLinesSimple(next.taskRunner.rawOutput)
            for idx in 0..<seqLenString(lines):
                let lineText = trimLine(seqGetString(lines, idx))
                if len(lineText) > 0:
                    next = guiCodexAppendLine(next, lineText)
        next.codex.status = if exitCode == 0: "applied" else: "error"
        next.statusMsg = "codex: apply"
    else:
        next.terminal = pushTerminalLine(next.terminal, exitText)
        next = guiTaskLogAdd(next, "task " + exitText)
        next.statusMsg = "task " + exitText
    next.renderDirty = true
    next.taskRunner.active = false
    next.taskRunner.ptyFd = -1
    next.taskRunner.ptyPid = 0
    next.taskRunner.ptyRemainder = ""
    next.taskRunner.ptyAnsiRemainder = ""
    next.taskRunner.rawOutput = ""
    next = guiDesktopBridgeSave(next)
    if guiTaskQueueLen(next.taskRunner) > 0:
        let startJob = guiTaskQueuePop(next.taskRunner)
        return guiTaskRunnerStart(next, startJob)
    return next

fn guiTaskRunnerTick(state: GuiState): GuiState =
    var next: GuiState = state
    if ! next.taskRunner.active:
        if guiTaskQueueLen(next.taskRunner) > 0:
            let job = guiTaskQueuePop(next.taskRunner)
            return guiTaskRunnerStart(next, job)
        return next
    for loops in 0..<8:
        var eof: int32 = 0
        let chunk: str = ptyRead(next.taskRunner.ptyFd, 4096, &eof)
        if eof != 0:
            if len(next.taskRunner.ptyRemainder) > 0:
                next = guiTaskRunnerHandleLine(next, next.taskRunner.ptyRemainder)
            ptyClose(next.taskRunner.ptyFd)
            var exitCode: int32 = -1
            ptyWait(next.taskRunner.ptyPid, &exitCode)
            return guiTaskRunnerFinish(next, exitCode)
        if len(chunk) == 0:
            break
        next = guiTaskRunnerConsumeOutput(next, chunk)
    return next

fn guiCodexShow(state: GuiState): GuiState =
    var next: GuiState = state
    next.leftPaneVisible = true
    next.leftPaneTab = lpCodex
    if len(next.codex.status) == 0 || next.codex.status == "idle":
        next.codex.status = "ready"
    if next.codex.authPending:
        next.codex.authStatus = "pending"
    elif len(next.codex.authStatus) == 0:
        if next.codex.ptyActive:
            next.codex.authStatus = "checking"
        else:
            next.codex.authStatus = "signed-out"
    next.focus = fkCodex
    return next

fn codexLogEnabled(): bool =
    return envFlagEnabled(getEnv("CHENG_IDE_CODEX_LOG"), false)

fn codexLog(msg: str) =
    if codexLogEnabled():
        textutils.print("[codex] " + msg + "\n")

fn codexLogIoEnabled(): bool =
    let raw = getEnv("CHENG_IDE_CODEX_LOG_IO")
    if len(raw) > 0:
        return envFlagEnabled(raw, false)
    return codexLogEnabled()

fn codexLogIo(msg: str) =
    if codexLogIoEnabled():
        textutils.print("[codex-io] " + msg + "\n")

fn guiCodexDisabled(): bool =
    return envFlagEnabled(getEnv("CHENG_IDE_CODEX_DISABLE"), false)

fn guiCodexCliPath(): str =
    let override = getEnv("CHENG_CODEX_CLI")
    if len(override) > 0:
        return override
    var current = getCurrentDir()
    for depth in 0..<4:
        if len(current) == 0:
            break
        let localBin = joinPath(current, "codex-cheng-bin")
        if fileExists(localBin):
            return localBin
        var localCli = joinPath(current, "codex-cheng/codex-cheng")
        if fileExists(localCli):
            return localCli
        localCli = joinPath(current, "codex-cheng/build/codex-cheng")
        if fileExists(localCli):
            return localCli
        let parent = parentDir(current)
        if parent == current:
            break
        current = parent
    let baseParent = parentDir(getCurrentDir())
    let devRoot = joinPath(baseParent, "codex-lbcheng")
    var devCli = joinPath(devRoot, "codex-cheng")
    devCli = joinPath(devCli, "build")
    devCli = joinPath(devCli, "codex-cheng")
    if fileExists(devCli):
        return devCli
    return ""

fn guiCodexAppendLine(state: GuiState, line: str): GuiState =
    if len(line) == 0:
        return state
    addPtr_string(&state.codex.lines, line)
    while seqLenString(state.codex.lines) > MaxTaskLogLines:
        seqDeleteString(&state.codex.lines, 0)
    state.renderDirty = true
    return state

fn codexLineKind(line: str): CodexMessageKind =
    let lowered = textutils.toLowerAscii(trimLine(line))
    if startsWithPrefix(lowered, "you:"):
        return ckUser
    if startsWithPrefix(lowered, "codex:") || startsWithPrefix(lowered, "assistant:"):
        return ckAssistant
    if startsWithPrefix(lowered, "tool:") || startsWithPrefix(lowered, "exec:") || startsWithPrefix(lowered, "patch:") || startsWithPrefix(lowered, "plan:"):
        return ckTool
    return ckSystem

fn codexLineLabel(kind: CodexMessageKind): str =
    case kind:
        of ckUser:
            return "You"
        of ckAssistant:
            return "Codex"
        of ckTool:
            return "Tool"
        else:
            return "System"

fn codexStripPrefix(line: str): str =
    let trimmed = trimLine(line)
    let lowered = textutils.toLowerAscii(trimmed)
    if startsWithPrefix(lowered, "you:"):
        return trimLine(sliceFrom(trimmed, 4))
    if startsWithPrefix(lowered, "codex:"):
        return trimLine(sliceFrom(trimmed, 6))
    if startsWithPrefix(lowered, "assistant:"):
        return trimLine(sliceFrom(trimmed, 10))
    if startsWithPrefix(lowered, "tool:"):
        return trimLine(sliceFrom(trimmed, 5))
    if startsWithPrefix(lowered, "exec:"):
        return trimLine(sliceFrom(trimmed, 5))
    if startsWithPrefix(lowered, "patch:"):
        return trimLine(sliceFrom(trimmed, 6))
    if startsWithPrefix(lowered, "plan:"):
        return trimLine(sliceFrom(trimmed, 5))
    if startsWithPrefix(lowered, "auth:"):
        return trimLine(sliceFrom(trimmed, 5))
    if startsWithPrefix(lowered, "status:"):
        return trimLine(sliceFrom(trimmed, 7))
    if startsWithPrefix(lowered, "thread:"):
        return trimLine(sliceFrom(trimmed, 7))
    return trimmed

fn guiCodexIsAuthed(state: GuiState): bool =
    if state.codex.authPending:
        return false
    let authText = textutils.toLowerAscii(trimLine(state.codex.authStatus))
    if len(authText) == 0:
        return guiCodexHasAuthToken()
    if indexOfSubstr(authText, "signed-in", 0) >= 0:
        return true
    if indexOfSubstr(authText, "apikey", 0) >= 0:
        return true
    if indexOfSubstr(authText, "chatgpt", 0) >= 0:
        return true
    if indexOfSubstr(authText, "not-required", 0) >= 0:
        return true
    return false

fn codexActions(state: GuiState): CodexAction[] =
    var out: CodexAction[] = default[CodexAction[]]
    let hasAuth: bool = guiCodexIsAuthed(state)
    if state.codex.approval.active:
        var approve: CodexAction
        approve.label = "Approve"
        approve.cmd = "approve"
        approve.enabled = true
        addPtr[CodexAction](&out, approve)
        var decline: CodexAction
        decline.label = "Decline"
        decline.cmd = "decline"
        decline.enabled = true
        addPtr[CodexAction](&out, decline)
    if ! hasAuth:
        var login: CodexAction
        login.label = if state.codex.authPending: "Login (Pending)" else: "Login"
        login.cmd = "login"
        login.enabled = ! state.codex.authPending
        addPtr[CodexAction](&out, login)
    var connect: CodexAction
    if state.codex.ptyActive:
        connect.label = "Stop"
        connect.cmd = "stop"
        connect.enabled = true
    else:
        connect.label = "Connect"
        connect.cmd = "connect"
        connect.enabled = true
    addPtr[CodexAction](&out, connect)
    var newThread: CodexAction
    newThread.label = "New"
    newThread.cmd = "new"
    newThread.enabled = state.codex.ptyActive
    addPtr[CodexAction](&out, newThread)
    var threads: CodexAction
    threads.label = "Threads"
    threads.cmd = "threads"
    threads.enabled = true
    addPtr[CodexAction](&out, threads)
    var resume: CodexAction
    resume.label = "Resume"
    resume.cmd = "resume"
    resume.enabled = state.codex.ptyActive && len(state.codex.threadId) > 0
    addPtr[CodexAction](&out, resume)
    let statusLower = textutils.toLowerAscii(state.codex.status)
    if state.codex.ptyActive && len(state.codex.threadId) > 0 && len(state.codex.turnId) > 0 && (indexOfSubstr(statusLower, "run", 0) >= 0 || indexOfSubstr(statusLower, "review", 0) >= 0):
        var interrupt: CodexAction
        interrupt.label = "Interrupt"
        interrupt.cmd = "interrupt"
        interrupt.enabled = true
        addPtr[CodexAction](&out, interrupt)
    var preview: CodexAction
    preview.label = "Preview Diff"
    preview.cmd = "preview"
    preview.enabled = len(state.codex.lastDiff) > 0
    addPtr[CodexAction](&out, preview)
    var apply: CodexAction
    apply.label = "Apply Diff"
    apply.cmd = "apply"
    apply.enabled = len(state.codex.lastDiff) > 0
    addPtr[CodexAction](&out, apply)
    var clear: CodexAction
    clear.label = "Clear"
    clear.cmd = "clear"
    clear.enabled = true
    addPtr[CodexAction](&out, clear)
    return out

fn codexActionGlyph(action: CodexAction): str =
    if ! useCodicons():
        return ""
    if action.cmd == "login":
        return codiconGlyph(CodiconAccount)
    if action.cmd == "logout":
        return codiconGlyph(CodiconAccount)
    if action.cmd == "connect":
        return codiconGlyph(CodiconTerminal)
    if action.cmd == "stop":
        return codiconGlyph(CodiconClose)
    if action.cmd == "new":
        return codiconGlyph(CodiconEdit)
    if action.cmd == "threads":
        return codiconGlyph(CodiconHistory)
    if action.cmd == "resume":
        return codiconGlyph(CodiconRun)
    if action.cmd == "preview":
        return codiconGlyph(CodiconDiff)
    if action.cmd == "apply":
        return codiconGlyph(CodiconDiffAdded)
    if action.cmd == "clear":
        return codiconGlyph(CodiconCloseDirty)
    if action.cmd == "approve":
        return codiconGlyph(CodiconCheck)
    if action.cmd == "decline":
        return codiconGlyph(CodiconClose)
    if action.cmd == "interrupt":
        return codiconGlyph(CodiconClose)
    if action.cmd == "settings":
        return codiconGlyph(CodiconSettingsGear)
    if action.cmd == "apikey":
        return codiconGlyph(CodiconKey)
    if action.cmd == "send":
        return codiconGlyph(CodiconSend)
    return ""

fn codexHeaderActionMask(action: CodexAction): IconMask =
    if action.cmd == "new":
        if ensureCodexEditIconMask():
            return codexEditIconMask
    if action.cmd == "stop":
        if ensureCodexCloseIconMask():
            return codexCloseIconMask
    return iconMaskEmpty()

fn codexHeaderActionScale(layout: GuiLayout, mask: IconMask): float64 =
    if mask.h <= 0:
        return 1.0
    let target: float64 = explorerHeaderActionFont(layout)
    return target / float64(mask.h)

fn codexHeaderActionWidth(layout: GuiLayout, action: CodexAction): float64 =
    let mask = codexHeaderActionMask(action)
    if iconMaskValid(mask):
        let scale = codexHeaderActionScale(layout, mask)
        return float64(mask.w) * scale
    let glyph = codexActionGlyph(action)
    if len(glyph) > 0:
        return textWidthForFont(glyph, explorerHeaderActionFont(layout), layout)
    return 0.0

fn codexToolbarActions(state: GuiState): CodexAction[] =
    var out: CodexAction[] = default[CodexAction[]]
    let statusLower = textutils.toLowerAscii(state.codex.status)
    let running: bool = state.codex.ptyActive && (indexOfSubstr(statusLower, "run", 0) >= 0 || indexOfSubstr(statusLower, "review", 0) >= 0 || indexOfSubstr(statusLower, "apply", 0) >= 0)
    if running:
        var stop: CodexAction
        stop.label = "Stop"
        stop.cmd = "stop"
        stop.enabled = true
        addPtr[CodexAction](&out, stop)
    var newThread: CodexAction
    newThread.label = "New Chat"
    newThread.cmd = "new"
    newThread.enabled = state.codex.ptyActive
    addPtr[CodexAction](&out, newThread)
    var threads: CodexAction
    threads.label = "History"
    threads.cmd = "threads"
    threads.enabled = true
    addPtr[CodexAction](&out, threads)
    var resume: CodexAction
    resume.label = "Resume"
    resume.cmd = "resume"
    resume.enabled = state.codex.ptyActive && len(state.codex.threadId) > 0
    addPtr[CodexAction](&out, resume)
    var settings: CodexAction
    settings.label = "Settings"
    settings.cmd = "settings"
    settings.enabled = true
    addPtr[CodexAction](&out, settings)
    return out

fn codexInlineActions(state: GuiState, showLogin: bool): CodexAction[] =
    var out: CodexAction[] = default[CodexAction[]]
    if showLogin:
        var login: CodexAction
        login.label = if state.codex.authPending: "Signing in..." else: "Sign in"
        login.cmd = "login"
        login.enabled = ! state.codex.authPending
        addPtr[CodexAction](&out, login)
        var apiKey: CodexAction
        apiKey.label = "Use API key"
        apiKey.cmd = "apikey"
        apiKey.enabled = true
        addPtr[CodexAction](&out, apiKey)
    elif ! state.codex.ptyActive:
        var connect: CodexAction
        connect.label = "Connect"
        connect.cmd = "connect"
        connect.enabled = true
        addPtr[CodexAction](&out, connect)
    if state.codex.approval.active:
        var approve: CodexAction
        approve.label = "Approve"
        approve.cmd = "approve"
        approve.enabled = true
        addPtr[CodexAction](&out, approve)
        var decline: CodexAction
        decline.label = "Decline"
        decline.cmd = "decline"
        decline.enabled = true
        addPtr[CodexAction](&out, decline)
    if len(state.codex.lastDiff) > 0:
        var preview: CodexAction
        preview.label = "Preview Diff"
        preview.cmd = "preview"
        preview.enabled = true
        addPtr[CodexAction](&out, preview)
        var apply: CodexAction
        apply.label = "Apply Diff"
        apply.cmd = "apply"
        apply.enabled = true
        addPtr[CodexAction](&out, apply)
    return out

fn codexInlineActionRects(actions: CodexAction[], layout: GuiLayout, startX, startY, maxW: float64): CodexActionRect[] =
    var rects: CodexActionRect[] = default[CodexActionRect[]]
    if actions.len == 0:
        return rects
    let scale: float64 = layout.scale
    let gapX: float64 = 6.0 * scale
    let gapY: float64 = 6.0 * scale
    let padX: float64 = 8.0 * scale
    let padY: float64 = 4.0 * scale
    let btnH: float64 = layout.smallFont + padY * 2.0
    var cursorX: float64 = startX
    var cursorY: float64 = startY
    for idx in 0..<actions.len:
        let action = actions[idx]
        let icon = codexActionGlyph(action)
        let iconW: float64 = if len(icon) > 0: textWidthForFont(icon, layout.smallFont, layout) else: 0.0
        let gap: float64 = if len(icon) > 0 && len(action.label) > 0: 6.0 * scale else: 0.0
        let textW: float64 = textWidthForFont(action.label, layout.smallFont, layout)
        let btnW: float64 = iconW + gap + textW + padX * 2.0
        if cursorX + btnW > startX + maxW && cursorX > startX:
            cursorX = startX
            cursorY = cursorY + btnH + gapY
        var rect: CodexActionRect
        rect.action = action
        rect.x = cursorX
        rect.y = cursorY
        rect.w = btnW
        rect.h = btnH
        addPtr[CodexActionRect](&rects, rect)
        cursorX = cursorX + btnW + gapX
    return rects

fn codexToolbarActionRects(state: GuiState, layout: GuiLayout, leftX, rightX: float64, headerTop: int32, headerH: int32): CodexActionRect[] =
    var rects: CodexActionRect[] = default[CodexActionRect[]]
    let actions = codexToolbarActions(state)
    if actions.len == 0:
        return rects
    let gap: float64 = explorerHeaderActionGap(layout)
    let pad: float64 = explorerHeaderActionPad(layout)
    let scale: float64 = layout.scale
    var cursorX: float64 = rightX
    let idxBase = actions.len - 1
    if idxBase >= 0:
        for idxRev in 0..idxBase:
            let idx = idxBase - idxRev
            let action = actions[idx]
            let iconW: float64 = codexHeaderActionWidth(layout, action)
            if iconW > 0.0:
                cursorX = cursorX - iconW
                let rectX: float64 = cursorX - pad
                let rectY: float64 = float64(headerTop) + 2.0 * scale
                let rectH: float64 = float64(headerH) - 4.0 * scale
                var rect: CodexActionRect
                rect.action = action
                rect.x = rectX
                rect.y = rectY
                rect.w = iconW + pad * 2.0
                rect.h = rectH
                addPtr[CodexActionRect](&rects, rect)
                cursorX = rectX - gap
                if cursorX < leftX:
                    break
    return rects

fn codexActionRects(state: GuiState, layout: GuiLayout, startX, startY, maxW: float64): CodexActionRect[] =
    return codexInlineActionRects(codexActions(state), layout, startX, startY, maxW)

fn codexMessageHeight(layout: GuiLayout): float64 =
    return layout.lineHeight * 2.6

fn codexInputHeight(layout: GuiLayout): float64 =
    return layout.lineHeight * 2.8

fn codexContextLabel(item: str): str =
    let trimmed = trimLine(item)
    if len(trimmed) == 0:
        return ""
    let lineEnd: int32 = indexOfSubstr(trimmed, "\n", 0)
    if lineEnd > 0:
        return trimLine(sliceRange(trimmed, 0, lineEnd - 1))
    return trimmed

fn codexActionStartY(state: GuiState, layout: GuiLayout, contentListY: float64): float64 =
    var y: float64 = contentListY
    if len(state.codex.threadId) > 0:
        y = y + layout.lineHeight
    let contextCount: int32 = seqLenString(state.codex.contextItems)
    if contextCount > 0:
        let maxItems: int32 = minInt(contextCount, 3)
        y = y + layout.lineHeight
        y = y + float64(maxItems) * layout.lineHeight
        if contextCount > maxItems:
            y = y + layout.lineHeight
    return y

fn codexChipPadX(layout: GuiLayout): float64 =
    return 8.0 * layout.scale

fn codexChipPadY(layout: GuiLayout): float64 =
    return 3.0 * layout.scale

fn codexChipHeight(layout: GuiLayout): float64 =
    return layout.smallFont + codexChipPadY(layout) * 2.0

fn codexChipWidth(text: str, layout: GuiLayout): float64 =
    return textWidthForFont(text, layout.smallFont, layout) + codexChipPadX(layout) * 2.0
