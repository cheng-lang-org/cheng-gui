import std/seqs
import gui/examples_games/common/protocol
import gui/examples_games/common/p2p_node
import gui/examples_games/common/gui_runtime
import gui/examples_games/common/session_store
import gui/examples_games/common/string_utils as sutil
import gui/examples_games/mahjong4/state as mj

const
    GameId = "mahjong4"


type
    MahjongAppContext =
        scene: GuiSceneState
        node: P2PNode
        gameState: mj.Mahjong4State
        isHost: bool
        roomCode: str
        localName: str
        localToken: str
        localSeat: int32
        hostPeerId: str
        hostAddr: str
        peerBySeat: str[]
        lastPublicSnapshot: str
        lastPrivateSnapshot: str

var gCtx: MahjongAppContext
var gCtxInited = false

fn i32ToStr(value: int32): str =
    return intToStr(value)

fn joinIntList(values: int32[]): str =
    if len(values) <= 0:
        return ""
    var parts: str[] = default[str[]]
    for idx in 0..<len(values):
        add(parts, i32ToStr(values[idx]))
    return sutil.joinWith(parts, ",")

fn safeSeqGet(items: str[], idx: int32): str =
    if idx < 0 || idx >= len(items):
        return ""
    return get(items, idx)

fn peerAt(seat: int32): str =
    if ! gCtxInited:
        return ""
    if seat < 0 || seat >= mj.MahjongPlayerCount:
        return ""
    if seat >= len(gCtx.peerBySeat):
        return ""
    return get(gCtx.peerBySeat, seat)

fn peerSet(seat: int32, peerId: str) =
    if ! gCtxInited:
        return
    if seat < 0 || seat >= mj.MahjongPlayerCount:
        return
    var next: str[] = default[str[]]
    for idx in 0..<mj.MahjongPlayerCount:
        if idx == seat:
            add(next, peerId)
        else:
            add(next, peerAt(idx))
    gCtx.peerBySeat = next

fn parseInputByPipe(text: str): str[] =
    let raw: str[] = sutil.splitByChar(text, '|')
    var outVal: str[] = default[str[]]
    for idx in 0..<len(raw):
        add(outVal, sutil.strip(raw[idx]))
    return outVal

fn parseCommand(text: str): tuple[actionType: str, args: str] =
    let trimmed: str = sutil.strip(text)
    if len(trimmed) == 0:
        return (actionType: "", args: "")
    let pos: int32 = sutil.indexOfSubstr(trimmed, " ", 0)
    if pos < 0:
        return (actionType: sutil.toLowerAscii(trimmed), args: "")
    var left = ""
    var right = ""
    if pos > 0:
        left = sutil.sliceRange(trimmed, 0, pos - 1)
    if pos + 1 < len(trimmed):
        right = sutil.sliceRange(trimmed, pos + 1, len(trimmed) - 1)
    return (actionType: sutil.toLowerAscii(left), args: sutil.strip(right))

fn defaultListenAddr(): str =
    let port: int32 = 20000 + int32(sutil.nowMillis() % int64(1000))
    return "/ip4/0.0.0.0/tcp/" + i32ToStr(port)

fn makeRoomCode(): str =
    return "M" + i32ToStr(int32(sutil.nowMillis() % int64(1000000)))

fn makeToken(name: str): str =
    let base: str = if len(name) > 0: name else: "mahjong"
    return base + "-" + intToStr(int32(sutil.nowMillis()))

fn addLog(text: str) =
    if ! gCtxInited:
        return
    gCtx.scene = addSceneLog(gCtx.scene, text, 220)

fn newAction(id: str, label: str): GuiActionRect =
    var a: GuiActionRect
    a.id = id
    a.label = label
    a.enabled = true
    return a

fn fillBaseActions(actions: var GuiActionRect[]) =
    actions = []
    add(actions, newAction("create", "Create Room"))
    add(actions, newAction("join", "Join Host"))
    add(actions, newAction("ready", "Ready"))
    add(actions, newAction("start", "Start"))
    add(actions, newAction("send", "Send Action"))
    add(actions, newAction("next", "Next Round"))
    add(actions, newAction("bot", "Bot Fill"))
    add(actions, newAction("reconnect", "Reconnect"))

fn ensureContext(scene: GuiSceneState) =
    if gCtxInited:
        return
    gCtx.scene = scene
    gCtx.gameState = mj.newState()
    gCtx.isHost = false
    gCtx.roomCode = ""
    gCtx.localName = "Player"
    gCtx.localToken = ""
    gCtx.localSeat = -1
    gCtx.hostPeerId = ""
    gCtx.hostAddr = ""
    gCtx.peerBySeat = []
    setLen(gCtx.peerBySeat, mj.MahjongPlayerCount)
    gCtx.lastPublicSnapshot = ""
    gCtx.lastPrivateSnapshot = ""
    fillBaseActions(gCtx.scene.actions)
    gCtx.scene.description = "Cmd: discard W1 / peng / chi / gang / hu fans=QingYiSe,ZiMo,selfdraw=1 / pass"
    gCtxInited = true

fn firstEmptySeat(state: mj.Mahjong4State): int32 =
    for idx in 0..<mj.MahjongPlayerCount:
        let p: mj.MahjongPlayer = state.players[idx]
        if len(p.token) == 0:
            return idx
    return -1

fn findSeatByToken(state: mj.Mahjong4State, token: str): int32 =
    return mj.recoverPlayerSession(state, token)

fn saveLocalSession() =
    if ! gCtxInited:
        return
    if len(gCtx.localName) > 0 && len(gCtx.localToken) > 0:
        savePlayerToken(GameId, gCtx.localName, gCtx.localToken)
    if len(gCtx.hostAddr) > 0:
        saveLastEndpoint(GameId, gCtx.roomCode + "|" + gCtx.hostPeerId + "|" + gCtx.hostAddr + "|" + gCtx.localName)

fn publishActionApplied(applied: ActionApplied) =
    if ! gCtxInited || gCtx.node == nil:
        return
    let env: NetEnvelope = actionAppliedToEnvelope(applied, GameId, gCtx.roomCode, p2pSelfPeerId(gCtx.node))
    let errText: str = p2pPublishPublic(gCtx.node, encodeNetEnvelope(env))
    errText

fn pushPrivateSyncToSeat(seat: int32) =
    if ! gCtxInited || gCtx.node == nil:
        return
    if seat < 0 || seat >= mj.MahjongPlayerCount:
        return
    let peerId: str = peerAt(seat)
    if len(peerId) == 0:
        return
    let game: mj.Mahjong4State = gCtx.gameState
    let p: mj.MahjongPlayer = game.players[seat]
    let token: str = p.token
    if len(token) == 0:
        return

    var msg: PrivateSync = initPrivateSync()
    msg.playerToken = token
    msg.privateSnapshot = mj.buildPrivateSnapshot(game, seat)
    msg.allowedActions = "ready,start,discard,chi,peng,gang,hu,pass,next_round"
    msg.stateSeq = game.seq

    let env: NetEnvelope = privateSyncToEnvelope(msg, GameId, gCtx.roomCode, p2pSelfPeerId(gCtx.node), peerId)
    let resp: str = p2pRequestPrivate(gCtx.node, peerId, encodeNetEnvelope(env))
    resp

fn broadcastPrivateSyncAll() =
    for seat in 0..<mj.MahjongPlayerCount:
        pushPrivateSyncToSeat(seat)

fn applyHostAction(req: ActionRequest) =
    let applied: ActionApplied = mj.applyAction(gCtx.gameState, req.seat, req)
    if applied.applied:
        addLog("[Host] action applied: " + req.actionType + " " + req.actionArgs)
    else:
        addLog("[Host] action rejected: " + applied.note)
    publishActionApplied(applied)
    broadcastPrivateSyncAll()

fn handleJoinEnvelope(env: NetEnvelope) =
    let joinMsg: RoomJoin = envelopeToRoomJoin(env)
    var seat: int32 = findSeatByToken(gCtx.gameState, joinMsg.playerToken)
    if seat < 0:
        seat = firstEmptySeat(gCtx.gameState)
    if seat < 0:
        addLog("room full")
        return

    mj.setPlayer(gCtx.gameState, seat, joinMsg.playerName, joinMsg.playerToken, true, false)
    peerSet(seat, env.senderPeerId)
    addLog("player joined seat=" + i32ToStr(seat))
    let game: mj.Mahjong4State = gCtx.gameState

    var applied: ActionApplied = initActionApplied()
    applied.applied = true
    applied.actionType = "join"
    applied.actionArgs = joinMsg.playerName
    applied.stateSeq = game.seq + int64(1)
    game.seq = applied.stateSeq
    applied.publicSnapshot = mj.buildPublicSnapshot(game)
    publishActionApplied(applied)
    pushPrivateSyncToSeat(seat)

fn handleActionRequestEnvelope(env: NetEnvelope) =
    var req: ActionRequest = envelopeToActionRequest(env)
    if req.seat < 0:
        req.seat = findSeatByToken(gCtx.gameState, req.playerToken)
    if req.seat < 0:
        addLog("unknown action request")
        return
    if len(peerAt(req.seat)) == 0:
        peerSet(req.seat, env.senderPeerId)
    applyHostAction(req)

fn consumePublicMessages() =
    if ! gCtxInited || gCtx.node == nil:
        return
    var msg: P2PPublicMessage
    while p2pPollPublic(gCtx.node, msg):
        let env: NetEnvelope = decodeNetEnvelope(msg.envelopeText)
        if env.game != GameId:
            continue
        if len(gCtx.roomCode) > 0 && env.roomCode != gCtx.roomCode:
            continue

        if env.kind == "room_hello":
            if ! gCtx.isHost:
                gCtx.hostPeerId = env.senderPeerId
                gCtx.hostAddr = env.publicPayload

        elif env.kind == "room_join" && gCtx.isHost:
            handleJoinEnvelope(env)

        elif env.kind == "action_request" && gCtx.isHost:
            handleActionRequestEnvelope(env)

        elif env.kind == "action_applied":
            let applied: ActionApplied = envelopeToActionApplied(env)
            gCtx.lastPublicSnapshot = applied.publicSnapshot
            addLog("sync: " + applied.actionType)

fn privateRequestHandler(reqText: str): str =
    if ! gCtxInited:
        return reqText
    let env: NetEnvelope = decodeNetEnvelope(reqText)
    if env.game != GameId:
        return reqText

    if env.kind == "private_sync":
        gCtx.lastPrivateSnapshot = env.privatePayload
        let seatByToken: int32 = findSeatByToken(gCtx.gameState, env.playerToken)
        if seatByToken >= 0:
            gCtx.localSeat = seatByToken
        addLog("private snapshot received")
        var ack: NetEnvelope = initNetEnvelope()
        ack.kind = "ack"
        ack.game = GameId
        ack.roomCode = gCtx.roomCode
        ack.ok = true
        return encodeNetEnvelope(ack)

    if env.kind == "reconnect_claim" && gCtx.isHost:
        let claim: ReconnectClaim = envelopeToReconnectClaim(env)
        let seat: int32 = findSeatByToken(gCtx.gameState, claim.playerToken)
        var reply: NetEnvelope = initNetEnvelope()
        reply.kind = "reconnect_snapshot"
        reply.game = GameId
        reply.roomCode = gCtx.roomCode
        if seat < 0:
            reply.ok = false
            reply.errorMessage = "token not found"
            return encodeNetEnvelope(reply)

        var snap: ReconnectSnapshot = initReconnectSnapshot()
        snap.publicSnapshot = mj.buildPublicSnapshot(gCtx.gameState)
        snap.privateSnapshot = mj.buildPrivateSnapshot(gCtx.gameState, seat)
        snap.allowedActions = "ready,start,discard,chi,peng,gang,hu,pass,next_round"
        let game: mj.Mahjong4State = gCtx.gameState
        snap.stateSeq = game.seq
        snap.seat = seat
        reply = reconnectSnapshotToEnvelope(snap, GameId, gCtx.roomCode, p2pSelfPeerId(gCtx.node), env.senderPeerId)
        reply.ok = true
        return encodeNetEnvelope(reply)

    if env.kind == "reconnect_snapshot":
        let snap: ReconnectSnapshot = envelopeToReconnectSnapshot(env)
        gCtx.lastPublicSnapshot = snap.publicSnapshot
        gCtx.lastPrivateSnapshot = snap.privateSnapshot
        gCtx.localSeat = snap.seat
        addLog("reconnect recovered seat=" + i32ToStr(snap.seat))
        var ack: NetEnvelope = initNetEnvelope()
        ack.kind = "ack"
        ack.game = GameId
        ack.roomCode = gCtx.roomCode
        ack.ok = true
        return encodeNetEnvelope(ack)

    return reqText

fn tryCreateRoom(input: str) =
    let parts: str[] = parseInputByPipe(input)
    let room: str = if len(safeSeqGet(parts, 0)) > 0: safeSeqGet(parts, 0) else: makeRoomCode()
    let listenAddr: str = if len(safeSeqGet(parts, 1)) > 0: safeSeqGet(parts, 1) else: defaultListenAddr()
    let name: str = if len(safeSeqGet(parts, 2)) > 0: safeSeqGet(parts, 2) else: "Host"

    gCtx.roomCode = room
    gCtx.localName = name
    gCtx.localToken = loadPlayerToken(GameId, name)
    if len(gCtx.localToken) == 0:
        gCtx.localToken = makeToken(name)

    gCtx.node = initP2PNode(GameId, room)
    let err: str = p2pStart(gCtx.node, listenAddr, true)
    if len(err) > 0:
        addLog("create room failed: " + err)
        return

    p2pSetRequestHandler(gCtx.node, privateRequestHandler)
    gCtx.isHost = true
    gCtx.localSeat = 0
    gCtx.hostPeerId = p2pSelfPeerId(gCtx.node)
    gCtx.hostAddr = p2pListenAddr(gCtx.node)

    mj.setPlayer(gCtx.gameState, 0, name, gCtx.localToken, true, false)
    peerSet(0, gCtx.hostPeerId)

    var hello: RoomHello = initRoomHello()
    hello.game = GameId
    hello.roomCode = room
    hello.hostPeerId = gCtx.hostPeerId
    hello.hostMultiaddr = gCtx.hostAddr
    hello.note = "room_open"
    let pubErr: str = p2pPublishPublic(gCtx.node, encodeNetEnvelope(roomHelloToEnvelope(hello)))
    pubErr

    addLog("room created room=" + room)
    saveLocalSession()

fn tryJoinRoom(input: str) =
    let parts: str[] = parseInputByPipe(input)
    let room: str = safeSeqGet(parts, 0)
    let hostPeerId: str = safeSeqGet(parts, 1)
    let hostAddr: str = safeSeqGet(parts, 2)
    let name: str = if len(safeSeqGet(parts, 3)) > 0: safeSeqGet(parts, 3) else: "Player"
    let listenAddr: str = if len(safeSeqGet(parts, 4)) > 0: safeSeqGet(parts, 4) else: defaultListenAddr()

    if len(room) == 0 || len(hostPeerId) == 0 || len(hostAddr) == 0:
        addLog("join args missing")
        return

    gCtx.roomCode = room
    gCtx.localName = name
    gCtx.localToken = loadPlayerToken(GameId, name)
    if len(gCtx.localToken) == 0:
        gCtx.localToken = makeToken(name)

    gCtx.node = initP2PNode(GameId, room)
    let startErr: str = p2pStart(gCtx.node, listenAddr, false)
    if len(startErr) > 0:
        addLog("node start failed: " + startErr)
        return
    p2pSetRequestHandler(gCtx.node, privateRequestHandler)

    let connErr: str = p2pConnectHost(gCtx.node, hostPeerId, hostAddr)
    if len(connErr) > 0:
        addLog("connect host failed: " + connErr)
        return

    gCtx.isHost = false
    gCtx.hostPeerId = hostPeerId
    gCtx.hostAddr = hostAddr
    gCtx.localSeat = -1

    var joinMsg: RoomJoin = initRoomJoin()
    joinMsg.playerName = name
    joinMsg.playerToken = gCtx.localToken
    joinMsg.desiredSeat = -1
    let env: NetEnvelope = roomJoinToEnvelope(joinMsg, GameId, room, p2pSelfPeerId(gCtx.node))
    let joinErr: str = p2pPublishPublic(gCtx.node, encodeNetEnvelope(env))
    joinErr
    addLog("join request sent")
    saveLocalSession()

fn sendAction(kind: str, args: str) =
    if ! gCtxInited || gCtx.node == nil:
        addLog("please create or join a room first")
        return
    var req: ActionRequest = initActionRequest()
    req.actionType = kind
    req.actionArgs = args
    let game: mj.Mahjong4State = gCtx.gameState
    req.clientSeq = game.seq + int64(1)
    req.playerToken = gCtx.localToken
    req.seat = gCtx.localSeat
    if gCtx.isHost:
        applyHostAction(req)
    else:
        let env: NetEnvelope = actionRequestToEnvelope(req, GameId, gCtx.roomCode, p2pSelfPeerId(gCtx.node))
        let errText: str = p2pPublishPublic(gCtx.node, encodeNetEnvelope(env))
        errText

fn runBotStep() =
    if ! gCtxInited || ! gCtx.isHost:
        addLog("only host can run bot")
        return
    let game: mj.Mahjong4State = gCtx.gameState
    let seat: int32 = game.turnSeat
    if seat < 0 || seat >= mj.MahjongPlayerCount:
        addLog("no active seat now")
        return
    let botReq: ActionRequest = mj.makeBotAction(game, seat)
    applyHostAction(botReq)

fn requestReconnect() =
    if ! gCtxInited || gCtx.node == nil || gCtx.isHost:
        addLog("only client can reconnect")
        return
    var claim: ReconnectClaim = initReconnectClaim()
    claim.playerToken = gCtx.localToken
    claim.playerName = gCtx.localName
    let env: NetEnvelope = reconnectClaimToEnvelope(claim, GameId, gCtx.roomCode, p2pSelfPeerId(gCtx.node))
    let respText: str = p2pRequestPrivate(gCtx.node, gCtx.hostPeerId, encodeNetEnvelope(env))
    if len(respText) == 0:
        addLog("reconnect failed: " + p2pLastError(gCtx.node))
        return
    let ack: str = privateRequestHandler(respText)
    ack

fn handleAction(actionId: str, input: str) =
    if actionId == "create":
        tryCreateRoom(input)
    elif actionId == "join":
        tryJoinRoom(input)
    elif actionId == "ready":
        sendAction("ready", "")
    elif actionId == "start":
        sendAction("start", "")
    elif actionId == "send":
        let cmd = parseCommand(input)
        sendAction(cmd.actionType, cmd.args)
    elif actionId == "next":
        sendAction("next_round", "")
    elif actionId == "bot":
        runBotStep()
    elif actionId == "reconnect":
        requestReconnect()

fn refreshScene(base: GuiSceneState): GuiSceneState =
    var scene: GuiSceneState = base
    if ! gCtxInited:
        return scene
    let game: mj.Mahjong4State = gCtx.gameState

    var conn: str[] = []
    add(conn, "role=" + (if gCtx.isHost: "host" else: "client"))
    add(conn, "room=" + gCtx.roomCode)
    if gCtx.node != nil:
        add(conn, "selfPeer=" + p2pSelfPeerId(gCtx.node))
        add(conn, "listen=" + p2pListenAddr(gCtx.node))
    add(conn, "hostPeer=" + gCtx.hostPeerId)
    add(conn, "hostAddr=" + gCtx.hostAddr)
    scene.connectionLines = conn

    var seats: str[] = []
    for i in 0..<mj.MahjongPlayerCount:
        let p: mj.MahjongPlayer = game.players[i]
        add(
            seats,
            i32ToStr(i) + ". " + p.name + " [" + (if p.online: "on" else: "off") + "] ready=" + (if p.ready: "Y" else: "N")
            + " hand=" + i32ToStr(len(p.hand)) + " score=" + i32ToStr(game.scores[i])
        )
    scene.seatLines = seats

    var status: str[] = []
    add(status, "localName=" + gCtx.localName)
    add(status, "localSeat=" + i32ToStr(gCtx.localSeat))
    add(status, "localToken=" + gCtx.localToken)
    add(status, "stage=" + game.stage)
    add(status, "dealer=" + i32ToStr(game.dealerSeat) + " turn=" + i32ToStr(game.turnSeat))
    add(status, "last_discard=" + i32ToStr(game.lastDiscardSeat) + ":" + game.lastDiscardTile)
    add(status, "reaction=" + (if game.reactionStage: "1" else: "0") + " pending_hu=" + joinIntList(game.pendingHuSeats))
    add(status, "winners=" + joinIntList(game.winnerSeats) + " wall_left=" + i32ToStr(len(game.wall)))
    if len(gCtx.lastPrivateSnapshot) > 0:
        add(status, "private=ok")
    scene.statusLines = status

    if len(gCtx.lastPublicSnapshot) > 0:
        scene.notice = "latest public snapshot: " + sutil.sliceRange(gCtx.lastPublicSnapshot, 0, sutil.minInt(120, len(gCtx.lastPublicSnapshot) - 1))
    else:
        scene.notice = "public snapshot not received yet"

    fillBaseActions(scene.actions)
    return scene

fn reducer(scene: GuiSceneState, eventKind: str, payload: str): GuiSceneState =
    ensureContext(scene)
    gCtx.scene = scene

    if eventKind == "tick":
        if gCtx.node != nil:
            p2pTick(gCtx.node)
            consumePublicMessages()

    elif eventKind == "action":
        let inputText: str = sutil.strip(gCtx.scene.inputState.text)
        handleAction(payload, inputText)

    elif eventKind == "submit":
        let cmd = parseCommand(payload)
        sendAction(cmd.actionType, cmd.args)

    gCtx.scene = refreshScene(gCtx.scene)
    return gCtx.scene

fn runMahjong4Example(): int32 =
    var scene: GuiSceneState = newSceneState("Mahjong 4", "Guobiao rules with chi/peng/gang/hu")
    scene.icon = "M"
    scene.rating = "4.9"
    fillBaseActions(scene.actions)
    scene.inputState.placeholder = "create room|listen|name; join room|hostPeer|hostAddr|name|listen; send discard W1"
    return runExampleApp(scene, reducer)
