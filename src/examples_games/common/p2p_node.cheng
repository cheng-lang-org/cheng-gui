import std/seqs
import gui/examples_games/common/string_utils as sutil
import std/os

fn nodeGetEnv(name: str): str =
    return os.getEnv(name)

fn joinPath(a: str, b: str): str =
    if len(a) == 0:
        return b
    if len(b) == 0:
        return a
    if a[len(a) - 1] == '/':
        return a + b
    return a + "/" + b

fn nodeFileExists(path: str): bool =
    return os.fileExists(path)

fn nodeDirExists(path: str): bool =
    return nodeFileExists(path)

fn nodeCreateDir(path: str) =
    os.createDir(path)

fn nodeWriteFile(path: str, text: str) =
    os.writeFile(path, text)

fn nodeReadFile(path: str): str =
    return os.readFile(path)

type
    P2PPublicMessage =
        topic: str
        envelopeText: str
        senderPeerId: str
        timestampMs: int64

    P2PRequestHandler = fn(reqText: str): str

    P2PNode = ref
        started: bool
        isHost: bool
        game: str
        roomCode: str
        publicTopic: str
        listenAddr: str
        hostPeerId: str
        hostMultiaddr: str
        connectedHostPeerId: str
        selfPeerId: str
        tickCount: int64
        nextDmId: int64
        lastError: str
        publicInbox: P2PPublicMessage[]
        requestHandlerSet: bool
        requestHandler: P2PRequestHandler
        backendMode: str
        busRootDir: str
        publicLogPath: str
        dmReqPath: str
        dmRespPath: str
        publicReadLine: int32
        dmReqReadLine: int32
        dmRespReadLine: int32
        seenPublicMsgIds: str[]
        seenDmReqIds: str[]
        pendingRespIds: str[]
        pendingRespTexts: str[]

var allNodes: P2PNode[]
var nextPeerCounter: int64 = int64(1)

fn i64ToStr(v: int64): str =
    return intToStr(int32(v))

fn makeTopic(game: str, roomCode: str): str =
    return "game/" + game + "/" + roomCode + "/public"

fn makePeerId(prefix: str): str =
    let id: int64 = nextPeerCounter
    nextPeerCounter = nextPeerCounter + int64(1)
    return prefix + "-" + i64ToStr(id) + "-" + i64ToStr(sutil.nowMillis())

fn sanitizeKey(raw: str): str =
    var outVal = ""
    for idx in 0..<len(raw):
        let ch: char = raw[idx]
        if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_' || ch == '-':
            outVal = outVal + charToStr(ch)
        else:
            outVal = outVal + "_"
    if len(outVal) <= 0:
        return "default"
    return outVal

fn setError(node: P2PNode, text: str): str =
    if node != nil:
        node.lastError = text
    return text

fn envLower(name: str): str =
    return sutil.toLowerAscii(sutil.strip(nodeGetEnv(name)))

fn preferP2PMode(): str =
    let mode: str = envLower("GAMES_P2P_MODE")
    if mode == "mock":
        return "mock"
    if mode == "real":
        return "real"
    return "real"

fn allowMockFallback(): bool =
    let raw: str = envLower("GAMES_P2P_ALLOW_MOCK_FALLBACK")
    if raw == "0" || raw == "false" || raw == "no":
        return false
    return true

fn addNode(node: P2PNode) =
    if node == nil || len(node.selfPeerId) <= 0:
        return
    for idx in 0..<len(allNodes):
        if get(allNodes, idx) == node:
            return
    add(allNodes, node)

fn removeNode(node: P2PNode) =
    if node == nil:
        return
    var next: P2PNode[] = default[P2PNode[]]
    for idx in 0..<len(allNodes):
        let item: P2PNode = get(allNodes, idx)
        if item != node:
            add(next, item)
    allNodes = next

fn findNode(peerId: str): P2PNode =
    if len(peerId) <= 0:
        return nil
    for idx in 0..<len(allNodes):
        let node: P2PNode = get(allNodes, idx)
        if node != nil && node.started && node.selfPeerId == peerId:
            return node
    return nil

fn safeGet(items: str[], idx: int32): str =
    if idx < 0 || idx >= len(items):
        return ""
    return get(items, idx)

fn containsText(items: var str[], value: str): bool =
    for idx in 0..<len(items):
        if get(items, idx) == value:
            return true
    return false

fn addSeenLimited(items: var str[], value: str, keepMax: int32) =
    if len(value) <= 0:
        return
    if containsText(items, value):
        return
    add(items, value)
    if len(items) <= keepMax:
        return
    var clipped: str[] = default[str[]]
    for idx in len(items) - keepMax..<len(items):
        add(clipped, get(items, idx))
    items = clipped

fn trimPublicInbox(node: P2PNode) =
    if node == nil:
        return
    if len(node.publicInbox) <= 360:
        return
    var clipped: P2PPublicMessage[] = default[P2PPublicMessage[]]
    for idx in len(node.publicInbox) - 300..<len(node.publicInbox):
        add(clipped, get(node.publicInbox, idx))
    node.publicInbox = clipped

fn ensureDir(path: str) =
    if len(path) <= 0:
        return
    if ! nodeDirExists(path):
        nodeCreateDir(path)

fn appendLine(path: str, line: str) =
    var text = ""
    if nodeFileExists(path):
        text = nodeReadFile(path)
    nodeWriteFile(path, text + line + "\n")

fn loadLines(path: str): str[] =
    var outVal: str[] = default[str[]]
    if ! nodeFileExists(path):
        return outVal
    return sutil.splitLines(nodeReadFile(path))

fn busRootPath(game: str, roomCode: str): str =
    return joinPath(joinPath("build/examples_games/p2p_bus", sanitizeKey(game)), sanitizeKey(roomCode))

fn reqPathFor(rootDir: str, peerId: str): str =
    return joinPath(rootDir, "dm_req_" + sanitizeKey(peerId) + ".log")

fn respPathFor(rootDir: str, peerId: str): str =
    return joinPath(rootDir, "dm_resp_" + sanitizeKey(peerId) + ".log")

fn initP2PNode(game: str, roomCode: str): P2PNode =
    var node: P2PNode
    new(node)
    node.started = false
    node.isHost = false
    node.game = game
    node.roomCode = roomCode
    node.publicTopic = makeTopic(game, roomCode)
    node.listenAddr = ""
    node.hostPeerId = ""
    node.hostMultiaddr = ""
    node.connectedHostPeerId = ""
    node.selfPeerId = ""
    node.tickCount = int64(0)
    node.nextDmId = int64(0)
    node.lastError = ""
    node.publicInbox = default[P2PPublicMessage[]]
    node.requestHandlerSet = false
    node.requestHandler = nil
    node.backendMode = ""
    node.busRootDir = ""
    node.publicLogPath = ""
    node.dmReqPath = ""
    node.dmRespPath = ""
    node.publicReadLine = 0
    node.dmReqReadLine = 0
    node.dmRespReadLine = 0
    node.seenPublicMsgIds = default[str[]]
    node.seenDmReqIds = default[str[]]
    node.pendingRespIds = default[str[]]
    node.pendingRespTexts = default[str[]]
    return node

fn startMock(node: P2PNode, listenAddr: str, isHost: bool): str =
    node.backendMode = "mock"
    node.isHost = isHost
    node.listenAddr = listenAddr
    if len(node.selfPeerId) <= 0:
        node.selfPeerId = makePeerId("mock")
    if node.isHost:
        node.hostPeerId = node.selfPeerId
        node.hostMultiaddr = listenAddr
        node.connectedHostPeerId = node.selfPeerId
    node.started = true
    node.lastError = ""
    addNode(node)
    return ""

fn startReal(node: P2PNode, listenAddr: str, isHost: bool): str =
    node.backendMode = "real"
    node.isHost = isHost
    node.listenAddr = listenAddr
    if len(node.selfPeerId) <= 0:
        node.selfPeerId = makePeerId("real")
    node.busRootDir = busRootPath(node.game, node.roomCode)
    ensureDir("build")
    ensureDir("build/examples_games")
    ensureDir("build/examples_games/p2p_bus")
    ensureDir(joinPath("build/examples_games/p2p_bus", sanitizeKey(node.game)))
    ensureDir(node.busRootDir)
    node.publicLogPath = joinPath(node.busRootDir, "public.log")
    node.dmReqPath = reqPathFor(node.busRootDir, node.selfPeerId)
    node.dmRespPath = respPathFor(node.busRootDir, node.selfPeerId)
    if ! nodeFileExists(node.publicLogPath):
        nodeWriteFile(node.publicLogPath, "")
    if ! nodeFileExists(node.dmReqPath):
        nodeWriteFile(node.dmReqPath, "")
    if ! nodeFileExists(node.dmRespPath):
        nodeWriteFile(node.dmRespPath, "")
    if node.isHost:
        node.hostPeerId = node.selfPeerId
        node.hostMultiaddr = listenAddr
        node.connectedHostPeerId = node.selfPeerId
    node.started = true
    node.lastError = ""
    return ""

fn p2pStart(node: P2PNode, listenAddr: str, isHost: bool): str =
    if node == nil:
        return "p2p node nil"
    if node.started:
        return ""
    node.publicTopic = makeTopic(node.game, node.roomCode)
    node.listenAddr = listenAddr
    node.isHost = isHost
    if preferP2PMode() == "mock":
        return startMock(node, listenAddr, isHost)
    let realErr: str = startReal(node, listenAddr, isHost)
    if len(realErr) <= 0:
        return ""
    if ! allowMockFallback():
        return setError(node, realErr)
    let mockErr: str = startMock(node, listenAddr, isHost)
    if len(mockErr) > 0:
        return setError(node, realErr + " | mock fallback failed: " + mockErr)
    node.lastError = ""
    return ""

fn p2pStop(node: P2PNode) =
    if node == nil || ! node.started:
        return
    if node.backendMode == "mock":
        removeNode(node)
    node.started = false

fn p2pSelfPeerId(node: P2PNode): str =
    if node == nil || ! node.started:
        return ""
    return node.selfPeerId

fn p2pListenAddr(node: P2PNode): str =
    if node == nil || ! node.started:
        return ""
    return node.listenAddr

fn p2pLastError(node: P2PNode): str =
    if node == nil:
        return ""
    return node.lastError

fn p2pConnectHost(node: P2PNode, hostPeerId: str, hostMultiaddr: str): str =
    if node == nil || ! node.started:
        return setError(node, "p2p not started")
    if node.backendMode == "mock":
        let hostNode: P2PNode = findNode(hostPeerId)
        if hostNode == nil:
            return setError(node, "host not found")
        if len(hostMultiaddr) > 0 && hostNode.listenAddr != hostMultiaddr:
            return setError(node, "host multiaddr mismatch")
        node.connectedHostPeerId = hostPeerId
        node.hostPeerId = hostPeerId
        node.hostMultiaddr = hostNode.listenAddr
        node.lastError = ""
        return ""
    if len(hostPeerId) <= 0:
        return setError(node, "host peerId empty")
    node.connectedHostPeerId = hostPeerId
    node.hostPeerId = hostPeerId
    node.hostMultiaddr = hostMultiaddr
    node.lastError = ""
    return ""

fn p2pPublishPublic(node: P2PNode, envelopeText: str): str =
    if node == nil || ! node.started:
        return setError(node, "p2p not started")
    if node.backendMode == "mock":
        for idx in 0..<len(allNodes):
            let peer: P2PNode = get(allNodes, idx)
            if peer != nil && peer.started && peer.publicTopic == node.publicTopic:
                var msg: P2PPublicMessage
                msg.topic = node.publicTopic
                msg.envelopeText = envelopeText
                msg.senderPeerId = node.selfPeerId
                msg.timestampMs = sutil.nowMillis()
                add(peer.publicInbox, msg)
                trimPublicInbox(peer)
        node.lastError = ""
        return ""

    let msgId: str = makePeerId("pub")
    let line: str =
        "pub\t" +
        sutil.escapeField(msgId) + "\t" +
        sutil.escapeField(node.publicTopic) + "\t" +
        sutil.escapeField(node.selfPeerId) + "\t" +
        i64ToStr(sutil.nowMillis()) + "\t" +
        sutil.escapeField(envelopeText)
    appendLine(node.publicLogPath, line)
    node.lastError = ""
    return ""

fn storePendingResponse(node: P2PNode, reqId: str, text: str) =
    if node == nil || len(reqId) <= 0:
        return
    for idx in 0..<len(node.pendingRespIds):
        if get(node.pendingRespIds, idx) == reqId:
            node.pendingRespTexts[idx] = text
            return
    add(node.pendingRespIds, reqId)
    add(node.pendingRespTexts, text)
    if len(node.pendingRespIds) > 256:
        var clippedIds: str[] = default[str[]]
        var clippedTexts: str[] = default[str[]]
        let clipStart: int32 = len(node.pendingRespIds) - 200
        for idx in clipStart..<len(node.pendingRespIds):
            add(clippedIds, get(node.pendingRespIds, idx))
            add(clippedTexts, get(node.pendingRespTexts, idx))
        node.pendingRespIds = clippedIds
        node.pendingRespTexts = clippedTexts

fn takePendingResponse(node: P2PNode, reqId: str, outText: var str): bool =
    if node == nil || len(reqId) <= 0:
        return false
    for idx in 0..<len(node.pendingRespIds):
        if get(node.pendingRespIds, idx) == reqId:
            outText = get(node.pendingRespTexts, idx)
            var nextIds: str[] = default[str[]]
            var nextTexts: str[] = default[str[]]
            for j in 0..<len(node.pendingRespIds):
                if j != idx:
                    add(nextIds, get(node.pendingRespIds, j))
                    add(nextTexts, get(node.pendingRespTexts, j))
            node.pendingRespIds = nextIds
            node.pendingRespTexts = nextTexts
            return true
    return false

fn processRealPublic(node: P2PNode) =
    let lines: str[] = loadLines(node.publicLogPath)
    if node.publicReadLine < 0 || node.publicReadLine > len(lines):
        node.publicReadLine = 0
    for idx in node.publicReadLine..<len(lines):
        let raw: str = sutil.strip(lines[idx])
        if len(raw) > 0:
            let parts: str[] = sutil.splitByChar(raw, '\t')
            if len(parts) >= 6 && parts[0] == "pub":
                let msgId: str = sutil.unescapeField(parts[1])
                let topic: str = sutil.unescapeField(parts[2])
                if topic == node.publicTopic && ! containsText(node.seenPublicMsgIds, msgId):
                    addSeenLimited(node.seenPublicMsgIds, msgId, 800)
                    var msg: P2PPublicMessage
                    msg.topic = topic
                    msg.senderPeerId = sutil.unescapeField(parts[3])
                    msg.timestampMs = sutil.parseInt64(parts[4], sutil.nowMillis())
                    msg.envelopeText = sutil.unescapeField(parts[5])
                    add(node.publicInbox, msg)
    node.publicReadLine = len(lines)
    trimPublicInbox(node)

fn processRealDmRequests(node: P2PNode) =
    let lines: str[] = loadLines(node.dmReqPath)
    if node.dmReqReadLine < 0 || node.dmReqReadLine > len(lines):
        node.dmReqReadLine = 0
    for idx in node.dmReqReadLine..<len(lines):
        let raw: str = sutil.strip(lines[idx])
        if len(raw) > 0:
            let parts: str[] = sutil.splitByChar(raw, '\t')
            if len(parts) >= 6 && parts[0] == "req":
                let reqId: str = sutil.unescapeField(parts[1])
                let fromPeer: str = sutil.unescapeField(parts[2])
                let toPeer: str = sutil.unescapeField(parts[3])
                if toPeer == node.selfPeerId && ! containsText(node.seenDmReqIds, reqId):
                    addSeenLimited(node.seenDmReqIds, reqId, 800)
                    let reqText: str = sutil.unescapeField(parts[5])
                    var outText = reqText
                    if node.requestHandlerSet && node.requestHandler != nil:
                        outText = node.requestHandler(reqText)
                    let respLine: str =
                        "resp\t" +
                        sutil.escapeField(reqId) + "\t" +
                        sutil.escapeField(node.selfPeerId) + "\t" +
                        sutil.escapeField(fromPeer) + "\t" +
                        i64ToStr(sutil.nowMillis()) + "\t" +
                        sutil.escapeField(outText)
                    appendLine(respPathFor(node.busRootDir, fromPeer), respLine)
    node.dmReqReadLine = len(lines)

fn processRealDmResponses(node: P2PNode) =
    let lines: str[] = loadLines(node.dmRespPath)
    if node.dmRespReadLine < 0 || node.dmRespReadLine > len(lines):
        node.dmRespReadLine = 0
    for idx in node.dmRespReadLine..<len(lines):
        let raw: str = sutil.strip(lines[idx])
        if len(raw) > 0:
            let parts: str[] = sutil.splitByChar(raw, '\t')
            if len(parts) >= 6 && parts[0] == "resp":
                let reqId: str = sutil.unescapeField(parts[1])
                let toPeer: str = sutil.unescapeField(parts[3])
                if toPeer == node.selfPeerId:
                    storePendingResponse(node, reqId, sutil.unescapeField(parts[5]))
    node.dmRespReadLine = len(lines)

fn p2pRequestPrivate(node: P2PNode, peerId: str, envelopeText: str): str =
    if node == nil || ! node.started:
        setError(node, "p2p not started")
        return ""

    if node.backendMode == "mock":
        let target: P2PNode = findNode(peerId)
        if target == nil:
            setError(node, "peer not found")
            return ""
        node.nextDmId = node.nextDmId + int64(1)
        node.lastError = ""
        if target.requestHandlerSet && target.requestHandler != nil:
            return target.requestHandler(envelopeText)
        return envelopeText

    if len(peerId) <= 0:
        setError(node, "peer empty")
        return ""
    node.nextDmId = node.nextDmId + int64(1)
    let reqId: str = node.selfPeerId + "#" + i64ToStr(node.nextDmId) + "#" + i64ToStr(sutil.nowMillis())
    let reqLine: str =
        "req\t" +
        sutil.escapeField(reqId) + "\t" +
        sutil.escapeField(node.selfPeerId) + "\t" +
        sutil.escapeField(peerId) + "\t" +
        i64ToStr(sutil.nowMillis()) + "\t" +
        sutil.escapeField(envelopeText)
    appendLine(reqPathFor(node.busRootDir, peerId), reqLine)

    let deadline: int64 = sutil.nowMillis() + int64(1400)
    var outText = ""
    while sutil.nowMillis() <= deadline:
        processRealDmResponses(node)
        if takePendingResponse(node, reqId, outText):
            node.lastError = ""
            return outText
        processRealDmRequests(node)
    setError(node, "dm request timeout")
    return ""

fn p2pSetRequestHandler(node: P2PNode, handler: P2PRequestHandler) =
    if node == nil:
        return
    node.requestHandler = handler
    node.requestHandlerSet = handler != nil

fn p2pPollPublic(node: P2PNode, outMsg: var P2PPublicMessage): bool =
    if node == nil || len(node.publicInbox) <= 0:
        return false
    outMsg = get(node.publicInbox, 0)
    var next: P2PPublicMessage[] = default[P2PPublicMessage[]]
    for idx in 1..<len(node.publicInbox):
        add(next, get(node.publicInbox, idx))
    node.publicInbox = next
    return true

fn p2pTick(node: P2PNode) =
    if node == nil || ! node.started:
        return
    node.tickCount = node.tickCount + int64(1)
    if node.backendMode == "mock":
        return
    processRealPublic(node)
    processRealDmRequests(node)
    processRealDmResponses(node)
